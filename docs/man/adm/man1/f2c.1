. \" Definitions of L and LR for the benefit of systems
. \" whose -man lacks them...
.de L
.nh
.if n \%`\\$1'
.if t \%\&\f(CW\\$1\fP
.hy 14
..
.de LR
.nh
.if n \%`\\$1'\\$2
.if t \%\&\f(CW\\$1\fR\\$2
.hy 14
..
.TH F2C 1
.CT 1 prog_other
.SH NAME
f2c \(mi Convert Fortran 77 to C or C++
.SH SYNOPSIS
.B f2c
[
.I option ...
]
.I file ...
.SH DESCRIPTION
.I F2c
converts Fortran 77 source code in
.I files
with names ending in
.L .f
or
.L .F
to C (or C++) source files in the
current directory, with
.L .c
substituted
for the final
.L .f
or
.LR .F .
If no Fortran files are named, 
.I f2c
reads Fortran from standard input and
writes C on standard output.
.I File
names that end with
.L .p
or
.L .P
are taken to be prototype
files, as produced by option
.LR -P ,
and are read first.
.PP
The options are
.HP
.BR -w ,
.BR -w66 ,
.BR -onetrip ,
.BR -u ,
.BR -C ,
.BR -I2 ,
.B -I4 
(default),
.BR -U
.br
Same as in 
.IR f77 (1).
.PD0
.TP
.B -A
Produce
.SM ANSI
C.
Default is old-style C.
.TP
.B -a
Make local variables automatic rather than static
unless they appear in a 
.SM "DATA, EQUIVALENCE, NAMELIST,"
or
.SM SAVE
statement.
.TP
.B -C++
Output C++ code.
.TP
.B -c
Include original Fortran source as comments.
.TP
.B -E
Declare uninitialized
.SM COMMON 
to be
.B Extern
(overridably defined in
.F f2c.h
as
.B extern).
.TP
.B -ec
Place uninitialized 
.SM COMMON
blocks in separate files:
.B COMMON /ABC/
appears in file
.BR abc_com.c .
Option 
.LR -e1c 
bundles the separate files 
into the output file, with comments that give an unbundling
.IR sed (1)
script.
.TP
.B -ext
Complain about
.IR f77 (1)
extensions.
.TP
.B -g
Include original Fortran line numbers as comments.
.TP
.B -i2
Similar to
.BR -I2 ,
but assume a modified
.I libF77
and
.I libI77
(compiled with 
.BR -Df2c_i2 ),
so
.SM INTEGER
and
.SM LOGICAL
variables may be assigned by
.SM INQUIRE.
.TP
.B -it
Infer types of untyped
.SM EXTERNAL
arguments from usage.
.TP
.B -P
Write a 
.IB file .P
of ANSI (or C++) prototypes
for procedures defined in each input 
.IB file .f
or
.IB file .F .
When reading Fortran from standard input, write prototypes
at the beginning of standard output.
Implies
.B -A
unless option
.L -C++
is present.
.TP
.B -p
Supply preprocessor definitions to make common-block members 
look like local variables.
.TP
.B -R
Do not promote
.SM REAL
functions and operations to
.SM DOUBLE PRECISION.
Option
.L -!R
confirms the default, which imitates
.IR f77 .
.TP
.B -r8
Promote
.SM REAL
to
.SM DOUBLE PRECISION, COMPLEX
to
.SM DOUBLE COMPLEX.
.TP
.BI -T dir
Put temporary files in directory 
.I dir.
.TP
.B -w8
Suppress warnings when
.SM COMMON
or
.SM EQUIVALENCE
forces odd-word alignment of doubles.
.TP
.BI -W n
Assume
.I n
characters/word (default 4)
when initializing numeric variables with character data.
.TP
.B -z
Do not implicitly recognize
.SM DOUBLE COMPLEX.
.TP
.B -!c
Inhibit C output, but produce 
.B -P
output.
.TP
.B -!I
Reject
.B include
statements.
.TP
.B -!P
Do not attempt to infer
.SM ANSI
or C++
prototypes from usage.
.PD
.PP
The resulting C invokes the support routines of
.IR f77 ;
object code should be loaded by
.I f77
or with 
.IR ld (1)
or
.IR cc (1)
options
.BR "-lI77 -lF77 -lm" .
.SH FILES
.F /usr/include/f2c.h
.br
Other files as in
.IR f77 (1).
.SH "SEE ALSO"
S. I. Feldman and
P. J. Weinberger,
`A Portable Fortran 77 Compiler',
this manual, Volume 2.
.SH BUGS
Floating-point constant expressions are 
accurate to at most 16 or 17 decimal places.
.br
Untypable
.SM EXTERNAL
functions are declared 
.BR int .
