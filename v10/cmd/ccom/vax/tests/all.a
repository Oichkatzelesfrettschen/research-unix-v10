!<arch>
1.i             599578850   170   4     100664  8131      `
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	int	daddr_t;
typedef	char *	caddr_t;
typedef	u_short ino_t;
typedef	int	swblk_t;
typedef	int	size_t;
typedef	int	time_t;
typedef	int	label_t[14];
typedef	short	dev_t;
typedef	int	off_t;
typedef long	portid_t;
typedef struct	fd_set { int fds_bits[1]; } fd_set;
struct ar_hdr {
	char	ar_name[16];
	char	ar_date[12];
	char	ar_uid[6];
	char	ar_gid[6];
	char	ar_mode[8];
	char	ar_size[10];
	char	ar_fmag[2];
};
extern	struct	_iobuf {
	int	_cnt;
	char	*_ptr;
	char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
extern char	_ctype[];
struct exec {
	long	a_magic;	
unsigned long	a_text;		
unsigned long	a_data;		
unsigned long	a_bss;		
unsigned long	a_syms;		
unsigned long	a_entry;	
unsigned long	a_trsize;	
unsigned long	a_drsize;	
};
struct relocation_info {
	int	r_address;	
unsigned int	r_symbolnum:24,	
		r_pcrel:1, 	
		r_length:2,	
		r_extern:1,	
		:4;		
};
struct	nlist {
	union {
		char	*n_name;	
		long	n_strx;		
	} n_un;
unsigned char	n_type;		
	char	n_other;	
	short	n_desc;		
unsigned long	n_value;	
};
struct	stat
{
	dev_t	st_dev;
	ino_t	st_ino;
	unsigned short 	st_mode;
	short  	st_nlink;
	short  	st_uid;
	short  	st_gid;
	dev_t	st_rdev;
	off_t	st_size;
	time_t	st_atime;
	time_t	st_mtime;
	time_t	st_ctime;
};
int	aflg, gflg, nflg, oflg, pflg, uflg; 
int	rflg = 1;
char	**xargv;
int	archive;
struct	ar_hdr	archdr;
union {
	char	mag_armag[8+1];
	struct	exec mag_exp;
} mag_un;
struct _iobuf	*fi;
off_t	off;
off_t	ftell();
char	*malloc();
char	*realloc();
char	*strp;
char	*stab();
off_t	strsiz;
int	compare();
int	narg;
int	errs;
main(argc, argv)
char **argv;
{
	if (--argc>0 && argv[1][0]=='-' && argv[1][1]!=0) {
		argv++;
		while (*++*argv) switch (**argv) {
		case 'n':
			nflg++;
			continue;
		case 'g':
			gflg++;
			continue;
		case 'u':
			uflg++;
			continue;
		case 'r':
			rflg = -1;
			continue;
		case 'p':
			pflg++;
			continue;
		case 'o':
			oflg++;
			continue;
		case 'a':
			aflg++;
			continue;
		default:
			fprintf((&_iob[2]), "nm: invalid argument -%c\n",
			    *argv[0]);
			exit(2);
		}
		argc--;
	}
	if (argc == 0) {
		argc = 1;
		argv[1] = "a.out";
	}
	narg = argc;
	xargv = argv;
	while (argc--) {
		++xargv;
		namelist();
	}
	exit(errs);
}
namelist()
{
	register int j;
	archive = 0;
	fi = fopen(*xargv, "r");
	if (fi == 0) {
		error(0, "cannot open");
		return;
	}
	off = 8;
	fread((char *)&mag_un, 1, sizeof(mag_un), fi);
	if (mag_un.mag_exp.a_magic == 0177545) {
		error(0, "old archive");
		return;
	}
	if (strncmp(mag_un.mag_armag, "!<arch>\n", 8)==0)
		archive++;
	else if (     (((mag_un.mag_exp).a_magic)!=0407		 && ((mag_un.mag_exp).a_magic)!=0410		 && ((mag_un.mag_exp).a_magic)!=0413		)) {
		error(0, "bad format");
		return;
	}
	fseek(fi, 0L, 0);
	if (archive) {
		nextel(fi);
		if (narg > 1)
			printf("\n%s:\n", *xargv);
	}
	do {
		off_t o;
		register i, n;
		struct nlist *symp = 0;
		struct nlist sym;
		struct stat stb;
		fread((char *)&mag_un.mag_exp, 1, sizeof(struct exec), fi);
		if (     (((mag_un.mag_exp).a_magic)!=0407		 && ((mag_un.mag_exp).a_magic)!=0410		 && ((mag_un.mag_exp).a_magic)!=0413		))
			continue;
		if (archive == 0)
			fstat(	((fi)->_file), &stb);
		o =  	( 	((mag_un.mag_exp).a_magic==0413		 ? 1024 : sizeof (struct exec)) + (mag_un.mag_exp).a_text+(mag_un.mag_exp).a_data + (mag_un.mag_exp).a_trsize+(mag_un.mag_exp).a_drsize) - sizeof (struct exec);
		fseek(fi, o, 1);
		n = mag_un.mag_exp.a_syms / sizeof(struct nlist);
		if (n == 0) {
			error(0, "no name list");
			continue;
		}
		if ( 	( 	( 	((mag_un.mag_exp).a_magic==0413		 ? 1024 : sizeof (struct exec)) + (mag_un.mag_exp).a_text+(mag_un.mag_exp).a_data + (mag_un.mag_exp).a_trsize+(mag_un.mag_exp).a_drsize) + (mag_un.mag_exp).a_syms) + sizeof (off_t) >
		    (archive ? off : stb.st_size))
			error(1, "old format .o (no string table) or truncated file");
		i = 0;
		if (strp)
			free(strp), strp = 0;
		while (--n >= 0) {
			fread((char *)&sym, 1, sizeof(sym), fi);
			if (gflg && (sym.n_type&01		)==0)
				continue;
			if ((sym.n_type&0xe0		) && (!aflg||gflg||uflg))
				continue;
			if (symp==0)
				symp = (struct nlist *)
				    malloc(sizeof(struct nlist));
			else
				symp = (struct nlist *)
				    realloc(symp,
					(i+1)*sizeof(struct nlist));
			if (symp == 0)
				error(1, "out of memory");
			symp[i++] = sym;
		}
		if (archive && ftell(fi)+sizeof(off_t) >= off) {
			error(0, "no string table (old format .o?)");
			continue;
		}
		if (fread((char *)&strsiz,sizeof(strsiz),1,fi) != 1) {
			error(0, "no string table (old format .o?)");
			goto out;
		}
		strp = (char *)malloc(strsiz);
		if (strp == 0)
			error(1, "ran out of memory");
		if (fread(strp+sizeof(strsiz),strsiz-sizeof(strsiz),1,fi) != 1)
			error(1, "error reading string table");
		for (j = 0; j < i; j++)
			if (symp[j].n_un.n_strx)
				symp[j].n_un.n_name =
				    symp[j].n_un.n_strx + strp;
			else
				symp[j].n_un.n_name = "";
		if (pflg==0)
			qsort(symp, i, sizeof(struct nlist), compare);
		if ((archive || narg>1) && oflg==0)
			printf("\n%s:\n", archive ? archdr.ar_name : *xargv);
		psyms(symp, i);
		if (symp)
			free((char *)symp), symp = 0;
		if (strp)
			free((char *)strp), strp = 0;
	} while(archive && nextel(fi));
out:
	fclose(fi);
}
psyms(symp, nsyms)
	register struct nlist *symp;
	int nsyms;
{
	register int n, c;
	for (n=0; n<nsyms; n++) {
		c = symp[n].n_type;
		if (c & 0xe0		) {
			if (oflg) {
				if (archive)
					printf("%s:", *xargv);
				printf("%s:", archive ? archdr.ar_name : *xargv);
			}
			printf("%08x - %02x %04x %5.5s %s\n",
			    symp[n].n_value,
			    symp[n].n_other & 0xff, symp[n].n_desc & 0xffff,
			    stab(symp[n].n_type & 0xff),
			    symp[n].n_un.n_name);
			continue;
		}
		switch (c&0x1e		) {
		case 0x0		:
			c = 'u';
			if (symp[n].n_value)
				c = 'c';
			break;
		case 0x2		:
			c = 'a';
			break;
		case 0x4		:
			c = 't';
			break;
		case 0x6		:
			c = 'd';
			break;
		case 0x8		:
			c = 'b';
			break;
		case 0x1f		:
			c = 'f';
			break;
		}
		if (uflg && c!='u')
			continue;
		if (oflg) {
			if (archive)
				printf("%s:", *xargv);
			printf("%s:", archive ? archdr.ar_name : *xargv);
		}
		if (symp[n].n_type&01		)
			c = toupper(c);
		if (!uflg) {
			if (c=='u' || c=='U')
				printf("        ");
			else
				printf("%08x", symp[n].n_value);
			printf(" %c ", c);
		}
		printf("%s\n", symp[n].n_un.n_name);
l1:		;
	}
}
compare(p1, p2)
struct nlist *p1, *p2;
{
	if (nflg) {
		if (p1->n_value > p2->n_value)
			return(rflg);
		if (p1->n_value < p2->n_value)
			return(-rflg);
	}
	return (rflg * strcmp(p1->n_un.n_name, p2->n_un.n_name));
}
nextel(af)
struct _iobuf *af;
{
	register char *cp;
	register r;
	long arsize;
	fseek(af, off, 0);
	r = fread((char *)&archdr, 1, sizeof(struct ar_hdr), af);
	if (r != sizeof(struct ar_hdr))
		return(0);
	for (cp = archdr.ar_name; cp < &archdr.ar_name[sizeof(archdr.ar_name)]; cp++)
		if (*cp == ' ')
			*cp = '\0';
	arsize = atol(archdr.ar_size);
	if (arsize & 1)
		++arsize;
	off = ftell(af) + arsize;	
	return(1);
}
error(n, s)
char *s;
{
	fprintf((&_iob[2]), "nm: %s:", *xargv);
	if (archive) {
		fprintf((&_iob[2]), "(%s)", archdr.ar_name);
		fprintf((&_iob[2]), ": ");
	} else
		fprintf((&_iob[2]), " ");
	fprintf((&_iob[2]), "%s\n", s);
	if (n)
		exit(2);
	errs = 1;
}
struct	stabnames {
	int	st_value;
	char	*st_name;
} stabnames[] ={
	0x20		, "GSYM",
	0x22		, "FNAME",
	0x24		, "FUN",
	0x26		, "STSYM",
	0x28		, "LCSYM",
	0x40		, "RSYM",
	0x44		, "SLINE",
	0x60		, "SSYM",
	0x64		, "SO",
	0x80		, "LSYM",
	0x84		, "SOL",
	0xa0		, "PSYM",
	0xa4		, "ENTRY",
	0xc0		, "LBRAC",
	0xe0		, "RBRAC",
	0xe2		, "BCOMM",
	0xe4		, "ECOMM",
	0xe8		, "ECOML",
	0xfe		, "LENG",
	0x30		, "PC",
	0, 0
};
char *
stab(val)
{
	register struct stabnames *sp;
	static char prbuf[32];
	for (sp = stabnames; sp->st_name; sp++)
		if (sp->st_value == val)
			return (sp->st_name);
	sprintf(prbuf, "%02x", val);
	return (prbuf);
}

2.i             599578963   170   4     100664  1545      `
foo(t1)
{	register int i;
	char j;
	enum {x} b;
	int t3;
	register *ar1;
	t3 = *(ar1++ + i) %= t1;
	t3 = *ar1++ *= t1;
	j = (int) foo >> 12;
	t3 = *ar1++ &= t1;
	t3 = *ar1++ <<= t1;
	t3 = *ar1++ >>= t1;
	f((short)b);
}
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[120];
a() {
	register *x;
	((int)(*((&_iob[1]))->_ptr++=(*x++ >> 8)));
}
int g[1];
b()
{	int i, j;
	register *a;
	i = *a++ >>= j;
	g[i] >>= 1;
}
struct  vstr    {
	unsigned int	v_type:6;
	unsigned int	v_amt:10;
};
struct	xx {
	struct	vstr	v[10];
} x;
maina()
{	int i;
	x.v[i].v_type = 1;
	a(x.v[i].v_type);
}
struct foo { short a, b; } x3; int c ; char w;

mainb() { sub((w=0, x3)); }
typedef struct Hinge
{
	unsigned fa:8, fb:8, ea:4, eb:4, reverse:1;
} Hinge;
Hinge hinges[10];
int nhinges;

mainc()
{	hinges[nhinges].fa = ggg();
}
short a3;
zx()
{	register int *b;
	register short *c;
	if(a3 & *b++);
	if(*b++ & a3);
	if(*++b & *c++);
	if(*c++ & *++b);
}
a33()
{	int i;
	int c;
	i = (c >>= 1);
}
int **noderepr();
lenitem()
{
	register n;
	return a(noderepr(n)[n/2]);
}
typedef struct {
	int x, y;
} coord;

struct thing {
	coord t_pos;
	int x;
};
rndmove(who)
struct thing *who;
{	static coord ret;
	ret = who->t_pos;
}
typedef struct {int x,y;} point;
point pt[10], lastpt, map();
axx()
{	int i;
	pt[i] = lastpt = map();
}
struct a{int x,y;};
maind()
{	static struct a b, c, *x, *y;
	b = c;
	*x = *y = c;
}
struct {
     int  d;
     int  x;
} s, *sp;

mainx() {
	int x;  float f;

     sp->x = x + f * x;
}

3.i             556379109   170   4     100664  5343      `
extern double fabs(), floor(), ceil(), fmod();
extern double frexp(), ldexp(), modf();
extern double sqrt(), hypot(), atof(), strtod();
extern double sin(), cos(), tan(), asin(), acos(), atan(), atan2();
extern double exp(), log(), log10(), pow();
extern double sinh(), cosh(), tanh();
extern double gamma();
extern double j0(), j1(), jn(), y0(), y1(), yn();
extern double frand();
extern double erf(), erfc();
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[120];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
struct _iobuf	*popen();
long	ftell();
char	*fgets();
typedef double real;
realfft ( log2n, x, y, sign )
int     sign ;
real   log2n, x[], y[] ;       
{
	static  int     prevn   =  0 ;
	static  double  *cost, *sint ;
	int     s[13], u[13] ;
	int     j1, j2, j3, j4, jt, n, m4 ;
	int     a, b, c, d, e, f, g, h, i, j, k, l, m ;
	double  arg, c1, c2, c3, s1, s2, s3, tpim4 ;
	double  r1, r2, r3, r4, r5, r6, r7, r8 ;
	real   *w, *z, t ;
	w = &x[0] ;
	z = &x[1] ;
	n = pow(2.,log2n -1.) + 0.2 ;  
	
	if ( n / 4  !=  prevn )     {
		if ( prevn != 0 )  {
			free ((char *)cost ) ;
			free ((char *)sint ) ;
		}
		prevn = n / 4 ;
		
		if ((( cost = (double *)calloc((unsigned)prevn,sizeof(*cost)))
				== (double *)0 ) ||
		    (( sint = (double *)calloc((unsigned)prevn,sizeof(*sint)))
				== (double *)0 )   ) {
			fprintf((&_iob[2]), " alloc error in realfft\n");
			exit(1);
		}
		tpim4 =   6.283185307179586476925287 / ( 2 * n ) ;
		for ( j = 1 ; j < prevn ; j++ )   {
			arg = tpim4 * j ;
			cost[j] = cos ( arg ) ;
			sint[j] = sin ( arg ) ;
		}
		cost[0] = 1. ;
		sint[0] = 0. ;
        }       
	if (log2n > 2.1 )  {
		for (m = n/4; m >= 1; m /= 4)    {
			m4 = 4 * m ;
			e = n / m4 ;
			for (j = 0; j < m; j++ ) {
				f = e * j ;
				c1 = cost[f] * cost[f] * 2. - 1. ;
				s1 = cost[f] * sint[f] * 2.      ;
				c2 = c1 * c1 * 2. - 1. ;     
				s2 = c1 * s1 * 2.      ;     
				c3 = c2 * c1 - s2 * s1 ;     
				s3 = c2 * s1 + s2 * c1 ;     
				for (i = m4; i <= n; i += m4)  {
					j1 = (i + j - m4) * 2 ;
					a  = m  * 2  ;
					j2 = j1 + a  ;
					j3 = j2 + a  ;
					j4 = j3 + a  ;
					r1 = w[j1] + w[j3] ;
					r2 = w[j1] - w[j3] ;
					r3 = z[j1] + z[j3] ;
					r4 = z[j1] - z[j3] ;
					r5 = w[j2] + w[j4] ;
					r6 = w[j2] - w[j4] ;
					r7 = z[j2] + z[j4] ;
					r8 = z[j2] - z[j4] ;
					w[j1] = r1 + r5 ;
					z[j1] = r3 + r7 ;
					if (arg != 0. )  {
					      w[j3] = (r2+r8)*c1 + (r4-r6)*s1 ;
					      z[j3] = (r4-r6)*c1 - (r2+r8)*s1 ;
					      w[j2] = (r1-r5)*c2 + (r3-r7)*s2 ;
					      z[j2] = (r3-r7)*c2 - (r1-r5)*s2 ;
					      w[j4] = (r2-r8)*c3 + (r4+r6)*s3 ;
					      z[j4] = (r4+r6)*c3 - (r2-r8)*s3 ;
					}
					else  {
						w[j3] = r2+r8 ;
						z[j3] = r4-r6 ;
						w[j2] = r1-r5 ;
						z[j2] = r3-r7 ;
						w[j4] = r2-r8 ;
						z[j4] = r4+r6 ;
					}
				}
			}
		}
	}
	
	if (((int)(log2n+.2)-1) % 2)  {
		m = n * 2 ;
		for (j=2, i = 0; i < m ; i += 4, j += 4 )   {
			r1 = w[i]+w[j] ;
			r2 = w[i]-w[j] ;
			r3 = z[i]+z[j] ;
			r4 = z[i]-z[j] ;
			w[i] = r1 ;
			z[i] = r3 ;
			w[j] = r2 ;
			z[j] = r4 ;
		}
	}
	
	s[12] = n     ;
	u[12] = n * 2 ;
	for (j = 11; j > 0; --j)   {
		s[j] = (s[j+1] > 2) ? s[j+1] / 2 : 2 ;
		u[j] = s[j+1]  ;
	}
	u[0] = s[1] ;
	jt = -2 ;
	for (a = 0; a < u[0];  a +=  2  )
	 for (b = a; b < u[1];  b += s[1])
	  for (c = b; c < u[2];  c += s[2])
	   for (d = c; d < u[3];  d += s[3])
	    for (e = d; e < u[4];  e += s[4])
	     for (f = e; f < u[5];  f += s[5])
	      for (g = f; g < u[6];  g += s[6])
	       for (h = g; h < u[7];  h += s[7])
		for (i = h; i < u[8];  i += s[8])
		 for (j = i; j < u[9];  j += s[9])
		  for (k = j; k < u[10]; k += s[10])
		   for (l = k; l < u[11]; l += s[11])
		    for (m = l; m < u[12]; m += s[12])  {
				jt += 2 ;
				if ( jt > m)  {
					t     = w[jt] ;
					w[jt] = w[m]  ;
					w[m]  = t     ;
					t     = z[jt] ;
					z[jt] = z[m]  ;
					z[m]  = t     ;
				}
			}
	
	n *= 2    ;
	tpim4 = w[0] - z[0] ;
	x[0]  = w[0] + z[0] ;
	y[0] = 0. ;
	m = n / 8 ;
	for (l=n/2-1, i=n-2, j=2, g=n/4-1, f=n/2-2, e=n/2+2, d=n/4+1, k=1;
		k < m  ;
		--l, i -= 2, j += 2, --g, f -= 2, e += 2, d++, k++ ) {
		
		r1 = z[j] + z[i] ;
		r2 = w[i] - w[j] ;
		r3 = cost[ k ] ;
		r4 = sint[ k ] ;
		r5 = r3 * r2 - r4 * r1 ;
		y[k] = .5 * ((z[j] - z[i]) + r5) ;
		y[l] = .5 * ((z[i] - z[j]) + r5) ;
		r5 = r3 * r1 + r4 * r2 ;
		r6 = w[j] + w[i] ;
		x[k] = .5 * (r6 + r5) ;
		x[i] = .5 * (r6 - r5) ; 
		
		r1 = z[f] + z[e] ;
		r2 = w[e] - w[f] ;
		r5 = r4 * r2 - r3 * r1 ;
		y[g] = .5 * ((z[f] - z[e]) + r5) ;
		y[d] = .5 * ((z[e] - z[f]) + r5) ;
		r5 = r4 * r1 + r3 * r2 ;
		r6 = w[f] + w[e] ;
		x[f] = .5 * (r6 + r5) ; 
		x[e] = .5 * (r6 - r5) ; 
	}
	
	r1 = ( z[j] + z[i] ) *   0.70710678118654752440 ;
	r2 = ( w[i] - w[j] ) *   0.70710678118654752440 ;
	r5 = r2 - r1 ;
	y[k] = .5 * ((z[j] - z[i]) + r5) ;
	y[l] = .5 * ((z[i] - z[j]) + r5) ;
	r5 = r1 + r2 ;
	r6 = w[j] + w[i] ;
	x[k] = .5 * (r6 + r5) ;
	x[i] = .5 * (r6 - r5) ; 
	
	m = n / 2 ;
	for (i=n/4+2, l=n/8+1; l< m ; i += 2, l++)
		x[l] = x[i] ;
	
	y[n/4] = -z[n/2] ;
	x[n/2] = tpim4   ;
	
	if ( sign <= 0 ) {      
		r1 = 1. / (double) n ;
		r2 = - r1 ;
		m = n / 2 ;
		for (i=0; i<m ; i++)  {
			x[i] *= r1 ;
			y[i] *= r2 ;
		}
		x[n/2] *= r1 ;
        }
        return ;
}

4.i             599579035   170   4     100664  10506     `
extern	struct	_iobuf {
	int	_cnt;
	char	*_ptr;
	char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
typedef struct Triple{
	float	x;
	float	y;
	float	z;
}Triple;
typedef Triple Color;
typedef struct Point {
	int type;
	long stamp;		
	double x;
	double y;
	double z;
} Point;
typedef struct Plane {
	int type;
	long stamp;
	double A;
	double B;
	double C;
	double D;
} Plane;
typedef struct Conic {
	int type;
	long stamp;
	double A;
	double B;
	double C;
	double D;
	double E;
	double F;
	double G;
	double H;
	double I;
	double J;
} Conic;
typedef struct Transform {
	double A, B, C, D;
	double E, F, G, H;
	double I, J, K, L;
} Transform;
typedef struct Tpair {
	int type;
	long stamp;
	Transform t;
	Transform tinv;
} Tpair;
typedef struct Ctree {
	int type;
	int (*test)();
	struct Ctree *car;
	struct Ctree *cdr;
} Ctree;
typedef struct Surface {
	int type;
	short flags;
	Triple n;	
	short nfacet;
	struct{
		float m;
		float frac;
	}facet[5		];
	Triple *Dtab;
	Color speccolor;
	Color diffcolor;
	Color ambcolor;
	Color clearcolor;
} Surface;
typedef struct Object {
	int type;
	union {
		Plane *plane;
		Conic *conic;
	} surface;
	Conic *cover;
	Point *center;
	struct List *references;
	Ctree *ctree;
	Tpair *tpair;
	Surface *srf;
	float minrange1, minrange2;
	float Q1, R1, S1, T1;
	float Q2, R2, S2, T2;
	int (*fun)();
} Object;
typedef struct View {
	int type;
	Tpair *tpair;
	int style;
	Color lightcolor;
	Point *viewpoint;
	Point *ul_corner, *ll_corner, *lr_corner;	
	Plane *screen;
	struct List *bin[32		][32		];	
} View;
typedef struct List {
	int type;
	union {
		Point *point;
		Object *object;
		View *view;
		struct List *list;
	} car;
	struct List *cdr;
} List;
typedef struct Symbol{
	char	*name;
	short	type;
	union{
		double 	val;
		List	*obj;
		Tpair	*tpair;
		Triple	*triple;
		Surface	*srf;
	}u;
	struct Symbol *next;
}Symbol;
extern double	range1;
extern double	range2;
extern long	transform_stamp;
extern Color	black;
extern Color	fillcolor;
extern Color	white;
extern List	*scene;
extern Point	testpoint;
extern Object	*pobject;
extern Point	dirnums;
extern Transform tnull;
extern View	*camera;
extern List	*lightsource;
extern char	*progname;
char		*emalloc();
double		Pow();
double		setvalue();
double		value();
double		fsqrt();
Color		*create_color();
Color		light();
Ctree		*and();
Ctree		*create_ctree();
Ctree		*inside_list();
Ctree		*outside_list();
List		*cons_list();
Object		*adddefn();
Object		*boolean();
Object		*copy();
Object		*inside();
Object		*outside();
Object		*setobjvalue();
Object		*unit_cone();
Object		*unit_cube();
Object		*unit_disc();
Object		*unit_cylinder();
Object		*unit_hyperboloid();
Object		*unit_paraboloid();
Object		*unit_paracylinder();
Object		*unit_saddle();
Object		*unit_sphere();
Object		*unit_square();
Point		intersect();
Point		min_range();
Point		trans_point();
Surface		*create_surface();
Symbol		*install();
Symbol		*lookup();
Tpair		*create_tpair();
Tpair		*mulmat();
Tpair		*matvalue();
Tpair		*setmatvalue();
Transform	trans_product();
Triple		*trivalue();
Triple		*settrivalue();
Triple		*create_triple();
View		*create_view();
long transform_stamp = 1;
extern double sin(), cos();
Transform tnull = {1.0, 0.0, 0.0, 0.0,
		   0.0, 1.0, 0.0, 0.0,
		   0.0, 0.0, 1.0, 0.0,};
Transform
trans_product(t1, t2)
register Transform *t1, *t2;
{
	Transform t3;
	t3.A = t1->A * t2->A + t1->B * t2->E + t1->C * t2->I;
	t3.B = t1->A * t2->B + t1->B * t2->F + t1->C * t2->J;
	t3.C = t1->A * t2->C + t1->B * t2->G + t1->C * t2->K;
	t3.D = t1->A * t2->D + t1->B * t2->H + t1->C * t2->L + t1->D;
	t3.E = t1->E * t2->A + t1->F * t2->E + t1->G * t2->I;
	t3.F = t1->E * t2->B + t1->F * t2->F + t1->G * t2->J;
	t3.G = t1->E * t2->C + t1->F * t2->G + t1->G * t2->K;
	t3.H = t1->E * t2->D + t1->F * t2->H + t1->G * t2->L + t1->H;
	t3.I = t1->I * t2->A + t1->J * t2->E + t1->K * t2->I;
	t3.J = t1->I * t2->B + t1->J * t2->F + t1->K * t2->J;
	t3.K = t1->I * t2->C + t1->J * t2->G + t1->K * t2->K;
	t3.L = t1->I * t2->D + t1->J * t2->H + t1->K * t2->L + t1->L;
	return t3;
}
Conic
trans_conic(t, c)
register Transform *t;
register Conic *c;
{
	Conic nc;
	nc.type = 3;
	nc.A =	(c->A*t->A*t->A + c->B*t->E*t->E + c->C*t->I*t->I) +
		(c->D*t->A*t->E + c->E*t->E*t->I + c->F*t->A*t->I);
	nc.B =	(c->A*t->B*t->B + c->B*t->F*t->F + c->C*t->J*t->J) +
		(c->D*t->B*t->F + c->E*t->F*t->J + c->F*t->B*t->J);
	nc.C =	(c->A*t->C*t->C + c->B*t->G*t->G + c->C*t->K*t->K) +
		(c->D*t->C*t->G + c->E*t->G*t->K + c->F*t->C*t->K);
	nc.D =	(c->A*t->A*t->B + c->B*t->E*t->F + c->C*t->I*t->J)*2.0 +
		c->D*(t->A*t->F + t->B*t->E) +
		c->E*(t->E*t->J + t->F*t->I) +
		c->F*(t->A*t->J + t->B*t->I);
	nc.E =	(c->A*t->B*t->C + c->B*t->F*t->G + c->C*t->J*t->K)*2.0 +
		c->D*(t->B*t->G + t->C*t->F) +
		c->E*(t->F*t->K + t->G*t->J) +
		c->F*(t->B*t->K + t->C*t->J);
	nc.F =	(c->A*t->A*t->C + c->B*t->E*t->G + c->C*t->I*t->K)*2.0 +
		c->D*(t->A*t->G + t->E*t->C) +
		c->E*(t->E*t->K + t->G*t->I) +
		c->F*(t->A*t->K + t->C*t->I);
	nc.G =	(c->A*t->A*t->D + c->B*t->E*t->H + c->C*t->I*t->L)*2.0 +
		c->D*(t->A*t->H + t->D*t->E) +
		c->E*(t->E*t->L + t->H*t->I) +
		c->F*(t->A*t->L + t->D*t->I) +
		c->G*t->A + c->H*t->E + c->I*t->I;
	nc.H =	(c->A*t->B*t->D + c->B*t->F*t->H + c->C*t->J*t->L)*2.0 +
		c->D*(t->B*t->H + t->D*t->F) +
		c->E*(t->F*t->L + t->H*t->J) +
		c->F*(t->B*t->L + t->D*t->J) +
		c->G*t->B + c->H*t->F + c->I*t->J;
	nc.I =	(c->A*t->C*t->D + c->B*t->G*t->H + c->C*t->K*t->L)*2.0 +
		c->D*(t->C*t->H + t->D*t->G) +
		c->E*(t->G*t->L + t->H*t->K) +
		c->F*(t->C*t->L + t->D*t->K) +
		c->G*t->C + c->H*t->G + c->I*t->K;
	nc.J =	(c->A*t->D*t->D + c->B*t->H*t->H + c->C*t->L*t->L) +
		(c->D*t->D*t->H + c->E*t->H*t->L + c->F*t->D*t->L) +
		c->G*t->D + c->H*t->H + c->I*t->L +
		c->J;
	return nc;
}
Plane
trans_plane(t, p)
register Transform *t;
register Plane *p;
{
	Plane np;
	np.type = 2;
	np.A = p->A*t->A + p->B*t->E + p->C*t->I;
	np.B = p->A*t->B + p->B*t->F + p->C*t->J;
	np.C = p->A*t->C + p->B*t->G + p->C*t->K;
	np.D = p->A*t->D + p->B*t->H + p->C*t->L + p->D;
	return np;
}
Point
trans_point(t, p)
register Transform *t;
register Point *p;
{
	Point np;
	np.type = 1;
	np.x = t->A*p->x + t->B*p->y + t->C*p->z + t->D;
	np.y = t->E*p->x + t->F*p->y + t->G*p->z + t->H;
	np.z = t->I*p->x + t->J*p->y + t->K*p->z + t->L;
	return np;
}
do_transform(tp, list)
Tpair *tp;
register List *list;
{
	if (!list)
		return;
	switch (list->type) {
	case 1:
		if (((Point *)list)->stamp == tp->stamp)
			return;
		*((Point *)list) = trans_point(&tp->t, ((Point *)list));
		((Point *)list)->stamp = tp->stamp;
		return;
	case 3:
		if (((Conic *)list)->stamp == tp->stamp)
			return;
		*((Conic *)list) = trans_conic(&tp->tinv, ((Conic *)list));
		((Conic *)list)->stamp = tp->stamp;
		return;
	case 2:
		if (((Plane *)list)->stamp == tp->stamp)
			return;
		*((Plane *)list) = trans_plane(&tp->tinv, ((Plane *)list));
		((Plane *)list)->stamp = tp->stamp;
		return;
	case 5:
		do_transform(tp, list->car.list);
		do_transform(tp, list->cdr);
		return;
	case 7:
		do_transform(tp, ((Ctree *)list)->car);
		do_transform(tp, ((Ctree *)list)->cdr);
		return;
	case 4:
		do_transform(tp, ((View *)list)->viewpoint);
		do_transform(tp, ((View *)list)->ul_corner);
		do_transform(tp, ((View *)list)->ll_corner);
		do_transform(tp, ((View *)list)->lr_corner);
		do_transform(tp, ((View *)list)->screen);
		do_transform(tp, ((View *)list)->tpair);
		return;
	case 6:
		do_transform(tp, ((Object *)list)->surface);
		do_transform(tp, ((Object *)list)->cover);
		do_transform(tp, ((Object *)list)->references);
		do_transform(tp, ((Object *)list)->ctree);
		do_transform(tp, ((Object *)list)->tpair);
		do_transform(tp, ((Object *)list)->center);
		return;
	case 8:
		if (((Tpair *)list)->stamp == tp->stamp)
			return;
		((Tpair *)list)->t = trans_product(&tp->t, &((Tpair *)list)->t);
		((Tpair *)list)->tinv = trans_product(&((Tpair *)list)->tinv, &tp->tinv);
		((Tpair *)list)->stamp = tp->stamp;
	}
	return;
}
translate(x, y, z, list)
double x, y, z;
List *list;
{
	Tpair tp;
	tp.stamp = transform_stamp++;
	tp.type = 8;
	tp.t = tnull;
	tp.t.A = 1.0;
	tp.t.F = 1.0;
	tp.t.K = 1.0;
	tp.t.D = x;
	tp.t.H = y;
	tp.t.L = z;
	tp.tinv = tp.t;
	tp.tinv.D = -x;
	tp.tinv.H = -y;
	tp.tinv.L = -z;
	do_transform(&tp, list);
}
stretch(x, y, z, list)
double x, y, z;
List *list;
{
	Tpair tp;
	tp.stamp = transform_stamp++;
	tp.type = 8;
	tp.t = tnull;
	tp.t.A = x;
	tp.t.F = y;
	tp.t.K = z;
	tp.tinv = tnull;
	tp.tinv.A = 1.0/x;
	tp.tinv.F = 1.0/y;
	tp.tinv.K = 1.0/z;
	do_transform(&tp, list);
}
rotateX(theta, list)
double theta;
List *list;
{
	Tpair tp;
	tp.stamp = transform_stamp++;
	tp.type = 8;
	theta = theta * 0.0174532925199432957692	;
	tp.t = tnull;
	tp.t.A = 1.0;
	tp.t.F = cos(theta);
	tp.t.G = -sin(theta);
	tp.t.J = -tp.t.G;
	tp.t.K = tp.t.F;
	tp.tinv = tp.t;
	tp.tinv.G = -tp.tinv.G;
	tp.tinv.J = -tp.tinv.J;
	do_transform(&tp, list);
}
rotateY(theta, list)
double theta;
List *list;
{
	Tpair tp;


	tp.stamp = transform_stamp++;
	tp.type = 8;
	theta = theta * 0.0174532925199432957692	;
	tp.t = tnull;
	tp.t.F = 1.0;
	tp.t.A = cos(theta);
	tp.t.C = -sin(theta);
	tp.t.I = -tp.t.C;
	tp.t.K = tp.t.A;
	tp.tinv = tp.t;
	tp.tinv.C = -tp.tinv.C;
	tp.tinv.I = -tp.tinv.I;
	do_transform(&tp, list);
}
rotateZ(theta, list)
double theta;
List *list;
{
	Tpair tp;


	tp.stamp = transform_stamp++;
	tp.type = 8;
	theta = theta * 0.0174532925199432957692	;
	tp.t = tnull;
	tp.t.K = 1.0;
	tp.t.A = cos(theta);
	tp.t.B = -sin(theta);
	tp.t.E = -tp.t.B;
	tp.t.F = tp.t.A;
	tp.tinv = tp.t;
	tp.tinv.B = -tp.tinv.B;
	tp.tinv.E = -tp.tinv.E;
	do_transform(&tp, list);
}
Conic
tangent_cone(p, c)
register Point *p;
register Conic *c;
{
	Conic e;
	double f4, fx, fy, fz, fw;
	
	f4 = (p->x*(c->A*p->x + c->D*p->y + c->F*p->z + c->G) +
	      p->y*(c->B*p->y + c->E*p->z + c->H) +
	      p->z*(c->C*p->z + c->I) + c->J) * 4.0;
	e.A = f4*c->A;
	e.B = f4*c->B;
	e.C = f4*c->C;
	e.D = f4*c->D;
	e.E = f4*c->E;
	e.F = f4*c->F;
	e.G = f4*c->G;
	e.H = f4*c->H;
	e.I = f4*c->I;
	e.J = f4*c->J;
	
	fx = 2.0*c->A*p->x + c->D*p->y + c->F*p->z + c->G;
	fy = 2.0*c->B*p->y + c->D*p->x + c->E*p->z + c->H;
	fz = 2.0*c->C*p->z + c->E*p->y + c->F*p->x + c->I;
	fw = 2.0*c->J	   + c->G*p->x + c->H*p->y + c->I*p->z;
	
	e.A -= fx*fx;
	e.B -= fy*fy;
	e.C -= fz*fz;
	e.J -= fw*fw;
	e.D -= 2.0*fx*fy;
	e.E -= 2.0*fy*fz;
	e.F -= 2.0*fz*fx;
	e.G -= 2.0*fx*fw;
	e.H -= 2.0*fy*fw;
	e.I -= 2.0*fz*fw;
	return e;
}
5.i             556379109   170   4     100664  568       `
struct S { int i; int j; int k; }
main()
{	struct S *s;
	register struct S *r;
	struct S g(), *f();
	*(f(s)) = g(r, 1, 2 );
}

char x; int u;
foo()
{
	if(x & u) ;
	if(u & x) ;
}
struct xx{int a, b;};
xxf()
{	struct xx *x, *y;
	*x = *y;
}
usx()
{	unsigned int ui;
	register int *p;
	*p++ /= ui;
}
typedef struct { short i, j, k; } B;
B B1;
sfsf(a, b)
B a, b;
{
	a.i = b.i;
}
	
strucpass()
{
	f(B1, B1);
}
struct sv { int sz; int v; };
struct sv *ctor()
{	register struct sv *this;
	int X;
	this = ((X? printf() : a()),this);
}

enum {aa=10000, bb=1000};
int xx[aa/bb];
6.i             599579119   170   4     100664  9011      `
/* local.c */
extern	struct	_iobuf {
	int	_cnt;
	char	*_ptr;
	char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
	char		*hash();
	char		*savestr();
	char		*tstr();
	extern int	tstrused;
	extern char	*tstrbuf[];
	extern char	**curtstr;
extern int nerrors;  
typedef union ndu NODE;
typedef unsigned int TWORD;
typedef long CONSZ;  
	
	
extern int dope[];  
extern char *opst[];  
	
union ndu {
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		NODE *left;
		NODE *right;
	}in;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		CONSZ lval;
		int rval;
	}tn;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int label;  
		int lop;  
	}bn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int stsize;  
		short stalign;  
		short argsize;  
	}stn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
	}fn;	
	
	struct {
		
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
		double dval;
	}fpn;	
};
	
extern char *scnames();
typedef long OFFSZ;
struct symtab {
	char *sname;
	TWORD stype;  
	char sclass;  
	char slevel;  
	char sflags;  
	int offset;  
	short dimoff; 
	short sizoff; 
	short suse;  
	struct symtab *scopelink;	
};
struct sw {
	CONSZ sval;
	int slab;
};
extern struct sw swtab[];
extern struct sw *swp;
extern int swx;
extern int ftnno;
extern int blevel;
extern int instruct, stwart;
extern int lineno, nerrors;
typedef union {
	int intval;
	NODE * nodep;
} YYSTYPE;
extern YYSTYPE yylval;
extern CONSZ lastcon;
extern CONSZ ccast();
extern double dcon;
extern char ftitle[];
extern struct symtab stab[];
extern int curftn;
extern int strftn;
extern char *locnames[];
extern int curloc;
extern int curclass;
extern int curdim;
extern int dimtab[];
extern int paramstk[];
extern int paramno;
extern int argstk[];
extern int argsoff[];
extern TWORD argty[];
extern int argno;
extern int autooff, argoff, strucoff;
extern int regvar;
extern int nextrvar;
extern int brkflag;
extern char yytext[];
extern int strflg;
extern OFFSZ inoff;
extern int reached;
extern int idname;
extern NODE node[];
extern NODE *lastfree;
extern int cflag, hflag, pflag;
extern int brklab;
extern int contlab;
extern int flostat;
extern int retlab;
extern int retstat;
extern int asavbc[], *psavbc;
	
extern NODE
	*aadjust(),
	*bcon(),
	*bdty(),
	*block(),
	*bpsize(),
	*buildtree(),
	*clocal(),
	*conval(),
	*convert(),
	*dclstruct(),
	*doszof(),
	*getstr(),
	*makety(),
	*mkty(),
	*oconvert(),
	*offcon(),
	*optim(),
	*pconvert(),
	*ptmatch(),
	*pvconvert(),
	*rstruct(),
	*sconvert(),
	*strargs(),
	*stref(),
	*talloc(),
	*tymatch(),
	*tymerge(),
	*unconvert(),
	*xicolon();
OFFSZ	tsize(),
	psize();
TWORD	types(),
	ctype();
char *exname(), *exdcon();
int minrvar = 11;
int wloop_level = 1	;
int floop_level = 1	;
int maxboff;
int maxtemp;
extern int gdebug;
main( argc, argv ) char *argv[];
{
	extern int proflag;  


	int r;
	r = mainp1( argc, argv );
	return( r );
}
beg_file()
{
	
	register char *p, *s;
	char *tempnam();
			
	p = ftitle + strlen( ftitle ) - 2;
	s = p - 14;	
	while ( p > s && *p != '"' && *p != '/' )
		--p;
	regvar = minrvar;
	if (gdebug)
		dbline();
}
NODE *
treecpy(p)		
	register NODE *p; 
{
	
	register NODE *q;
	q = talloc();
	*q = *p;
	switch ( (dope[q->in.op]&016))
	{
	case 010:
		q->in.right = treecpy(p->in.right);
	case 04:
		q->in.left = treecpy(p->in.left);
	}
	return (q);
}
NODE *
clocal(p) NODE *p;
{
	register NODE *l,*ll,*temp;
	if( p->in.op == (2+ 11) )
	{	
		
		l = p->in.left;
		if( l->in.op == 6 )
		{
			ll = l->in.left;
			if( ll->in.op != 11 && ll->in.op != 2+ 14 )
			{
				if( (l->in.right)->in.op == 11 )
				{
					temp = l->in.right;
					l->in.right = l->in.left;
					l->in.left = temp;
				}
			}
		}
	}
	return(p);
}
cisreg( t ) TWORD t;
{ 
	if( t==4 || t==14 ||  ((t&(03<<5 ))== 040) || t==2 || t==12
		   || t==3 || t==13 )
	{
		if( regvar >= 6 )
		{
			nextrvar = regvar--;
			if( regvar < minrvar ) minrvar = regvar;
			return(1);
		}
	}
	return(0);
}
opbigsz( op )
{
	
	switch( op )
	{
	default:
		return( 32 );
	case 6:
	case 8:
	case 17:
	case 14:
	case 19:
	case 77:
	case 2+ 8:
		return( 8 );
	}
}
branch(n)			
int n;
{
	if (!reached)			
		return;
	dbline();
	genubr(n);
}
	
static int tablelabel;
struct sw heapsw[250 ];	
	
	
genswitch(p,n) register struct sw *p;
{
	
	register i;
	register CONSZ j, range;
	register dlab, swlab;
	range = p[n].sval-p[1].sval;
	if(  ( range>0 &&  range<=(3* n ) &&  n >=4) )
	{	
		swlab = getlab();
		dlab = ((p->slab >= 0) ? p->slab : getlab());
		dswbegin( n, p[1].sval, range, swlab, dlab );
		for( i=1,j=p[1].sval; i<=n; j++)
		{
			if( j == p[i].sval )
			{
				dswcase( p[i].slab );
				j = p[i++].sval;
			}
			else
			{
				dswcase( dlab );
			}
		}
		
		locctr( 0 );
		if( p->slab >= 0 ) genubr( dlab );
		else deflab( dlab );
		return;
	}
	if(  (n>8) )
	{	
		heapsw[0].slab = dlab = (p->slab >= 0 ? p->slab : getlab());
		makeheap(p, n, 1);	
		walkheap(1, n);		
		if( p->slab >= 0 )
			genubr( dlab );
		else
			deflab( dlab );
		return;
	}
	
	for( i=1; i<=n; ++i ) sswtest( p[i].sval, p[i].slab );
	if( p->slab>=0 ) genubr( p->slab );
	}
makeheap(p, m, n)
register struct sw *p;
{
	register int q;
	q = select(m);
	heapsw[n] = p[q];
	if( q>1 ) makeheap(p, q-1, 2*n);
	if( q<m ) makeheap(p+q, m-q, 2*n+1);
}
select(m) {
	register int l,i,k;
	for(i=1; ; i*=2)
		if( (i-1) > m ) break;
	l = ((k = i/2 - 1) + 1)/2;
	return( l + (m-k < l ? m-k : l));
}
walkheap(start, limit)
{
	int label;
	if( start > limit ) return;
	sswtest( heapsw[start].sval, heapsw[start].slab );
	if( (2*start) > limit ) {
		genubr( heapsw[0].slab );
		return;
	}
	if( (2*start+1) <= limit ) {
		label = getlab();
		hswelse( label );
	} else
		hswelse( heapsw[0].slab );
	walkheap( 2*start, limit);
	if( (2*start+1) <= limit ) {
		deflab( label );
		walkheap( 2*start+1, limit);
	}
}
dswbegin( numb, first, range, labl, dlab )
CONSZ first, range;
int numb, labl, dlab;
{
	printf("	casel	r0,$%ld,$%ld\n", first, range );
	printf("L%d:\n", labl );
	tablelabel = labl;
}
dswcase( l )
int l;
{
	printf("	.word	L%d-L%d\n", l, tablelabel );
}
sswtest( val, lab )
CONSZ val;
int lab;
{
	printf( "	cmpl	r0,$%ld\n	jeql	L%d\n", val, lab );
}
hswelse( lab )
int lab;
{
	printf("	jgtr	L%d\n", lab );
}
OFFSZ inoff;		
static inwd;		
static long word;	
zecode( n )
int n;
{
	
	if (n <= 0) return;
	printf( "	.space	%d\n", 4*n );
	inoff += n*32;
}
vfdzero( n ){ 
	
	sz_incode( (CONSZ)0, n );
	}
incode (p, sz)
NODE *p;
{
	sz_incode(p->tn.lval, sz);
}
sz_incode( val, sz )
CONSZ val;
{
	
	
	
	if((sz+inwd) > 32) cerror("incode: field > long");
	
	word |= ((unsigned)(val<<(32-sz))) >> (32-sz-inwd);
	inwd += sz;
	inoff += sz;
	
	if( inwd == 32 )
	{
		genlong( word );
		word = inwd = 0;
	}
}
fincode( d, sz )
double d;
int sz;
{
	
	
	
	union { float f; double d; int i[2]; } cheat;
	if (sz == 64)
	{
		cheat.d = d;
		printf("\t.long\t0x%x,0x%x\t# %.20e\n", cheat.i[0], cheat.i[1],
		    cheat.d);
	}
	else
	{
		cheat.f = d;
		printf("\t.long\t0x%x\t# %.20e\n", cheat.i[0], cheat.f);
	}
	inoff += sz;
}
int ftlab1, ftlab2;
int proflag;
int ent_mask[] = {
	0,0,0,0,0, 0xfc0, 0xf80, 0xf00, 0xe00, 0xc00, 0x800, 0};
efcode()
{
	
	long spoff;	
	genret( strftn, strftn, retlab );
	printf( "	.set	L.R%d,0x%x\n", ftnno, ent_mask[minrvar] );
	spoff = maxboff;
	if( spoff >=  ((0 )/8) ) spoff -=  ((0 )/8);
	spoff += maxtemp;
	spoff /= 8;
	deflab( ftlab1 );
	if( spoff!=0 )
		if( spoff < 64 )
			printf( "	subl2	$%ld,sp\n", spoff );
		else
			printf( "	movab	-%ld(sp),sp\n", spoff);
	genubr( ftlab2 );
	regvar = minrvar = 11;
	if (gdebug)
		dbfunend(getlab());
}
bfcode( a, n )
int a[], n;
{
	
	register i;
	
	printf( "	.word	L.R%d\n", ftnno);
	genubr( ftlab1 = getlab() );
	deflab( ftlab2 = getlab() );
	retlab = getlab();
	if( proflag )
	{	
		i = getlab();
		printf("	movab	L%d,r0\n", i);
		printf("	jsb 	mcount\n");
		printf("	.data\n");
		printf("	.align	2\n");
		printf("L%d:	.long	0\n", i);
		printf("	.text\n");
	}
	if (gdebug)
	{
		dbfunbeg(&stab[curftn]);
		dbnargs(n);
		for (i = 0; i < n; ++i)
			dbfunarg(&stab[a[i]]);
	}
}
defnam( psym )
register struct symtab *psym;
{
	
	
	
	if (psym->sclass == 5)
		printf( "	.globl	%s\n", exname(psym->sname) );
	printf("%s:\n", exname(psym->sname));
}
commdec(id)		
int id;
{
	register struct symtab *psym;
	OFFSZ n;
	psym = &stab[id];
	psym->sflags |= 0200;
	n = tsize(psym->stype, psym->dimoff, psym->sizoff) / 8;
	if (psym->sclass == 3)
		if (psym->slevel)
			printf("	.lcomm	L%d,%ld\n", psym->offset, n);
		else	
			printf("	.lcomm	%s,%ld\n", exname(psym->sname), n);
	else if (psym->sclass == 2)
		printf("	.comm	%s,%ld\n", exname(psym->sname), n);
	else
		cerror("Non-static/external in common");
}

7.i             556379110   170   4     100664  7917      `
/* local2.c */
extern	struct	_iobuf {
	int	_cnt;
	char	*_ptr;
	char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
	char		*hash();
	char		*savestr();
	char		*tstr();
	extern int	tstrused;
	extern char	*tstrbuf[];
	extern char	**curtstr;
extern int nerrors;  
typedef union ndu NODE;
typedef unsigned int TWORD;
typedef long CONSZ;  
	
	
extern int dope[];  
extern char *opst[];  
	
union ndu {
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		NODE *left;
		NODE *right;
	}in;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		CONSZ lval;
		int rval;
	}tn;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int label;  
		int lop;  
	}bn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int stsize;  
		short stalign;  
		short argsize;  
	}stn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
	}fn;	
	
	struct {
		
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
		double dval;
	}fpn;	
};
	
	
		
	
	
	
 
	
extern int busy[];
extern NODE node[];
typedef struct shape SHAPE;
	
extern struct shape {
	int	op;	
	SHAPE	*sl;	
	SHAPE	*sr;
	int	sh;	
	int	sc;	
} shapes[];
extern SHAPE	*pshape[];
typedef struct optab OPTAB;
struct optab {
	int	op;	
	int	tyop;	
	OPTAB	*nextop;
	SHAPE	**lshape;	
	int	ltype;		
	SHAPE	**rshape;	
	int	rtype;
	int	needs;
	int	rewrite;
	char	*cstring;
	int	cost;
	int	lcount;		
	int	rcount;		
	int	stinline;	
};
extern OPTAB
	*match(),
	*ophead[],
	table[];
extern NODE resc[];
extern int tmpoff;
extern int maxboff;
extern int maxtemp;
extern int maxarg;
extern int ftnno;
extern int sideff;
extern NODE
	*talloc(),
	*ind2type(),
	*tcopy(),
	*getadr(),
	*getlr();
extern CONSZ rdin();
extern char *rnames[];
extern int lineno;
extern char ftitle[];
extern int fldshf, fldsz;
extern int lflag, udebug, e2debug, odebug, rdebug, radebug, sdebug;
extern int fast;  
	
	
	
	
typedef struct inst INST;
struct inst {
	NODE	*p;
	OPTAB	*q;
	int	goal;
};
extern INST inst[300];
extern nins;
	
	
typedef SHAPE	*SHTABLE[2][20];
extern SHTABLE	sha;
eobl2()			
{
}
char *
exname( ix )
char *ix;
{
	
	static char text[100];
	if( ix == 0 ) cerror("no name in exname");
	sprintf( text, "_%s", ix );
	return( text );
}
lineid( l, fn )
int l;
char *fn;
{
	extern int gdebug;
	
	printf( "#	line %d, file %s\n", l, fn );
}
deflab( n )
int n;
{
	printf( "L%d:\n", n );
}
genubr( n )
int n;
{
	
	printf( "	jbr	L%d\n", n );
}
genret( s, l, n )
int s, l, n;
{
	
	
	deflab(n);
	if( s ) printf( "	movab	L%d,r0\n", l );
	dbfunret();
	printf( "	ret\n" );
}
defalign(n)
int n;
{
	
	if( n % 8 ) cerror( "funny alignment: %d", n );
	else n /= 8;
	if( n == 1 ) return;
	else if( n==2 ) n=1;
	else if( n==4 ) n=2;
	else cerror( "funny alignment: %d", n );
	printf( "	.align	%d\n", n );
}
char *locnames[] = {
	
	"	.text\n",
	"	.data\n",
	"	.data\n",
	"	.data	2\n",
	"	.data	1\n",
	};
bycode( t, i )
int t, i;
{
	
	i &= 07;
	if( t < 0 )
	{ 
		if( i != 0 ) printf("\n");
	}
	else
	{ 
		if( i == 0 ) printf( "\n	.byte	" );
		else printf(",");
		printf("0x%x", t);
	}
}
genshort( s )
short s;
{
	
	printf( "	.short	%d\n", (short) s );
}
genlong( l )
long l;
{
	
	printf( "	.long	0x%lx\n", l );
}
char *
rnames[]= {  
	"r0", "r1",
	"r2", "r3", "r4",
	"r5", "r6", "r7", "r8", "r9", "r10", "r11",
	"ap", "fp", "sp", "pc" 
	};
zzzcode( p, ppc, q )
NODE *p; char **ppc; OPTAB *q;
{
	register c;
	switch( c= *++(*ppc) )
	{
	case 'I':
		cbgen( p->bn.lop, p->bn.label, c );
		return;
	case 'k':	
		printf("$%ld", ~p->in.right->tn.lval);
		return;
	case 'c':
		
		printf( "$%d", p->stn.argsize/32);
		return;
	case 'U':	
		printf("$%d", 32 - p->in.right->tn.lval );
		return;
	case 'T':	
		printf("$%d", p->stn.stsize/8);
		break;
	case 'M':	
		staradr( p->in.right );
		break;
	case 'S':  
		{
			register NODE *l, *r;
			register size;
			if( p->in.op == 98 )
			{
				l = p->in.left;
				r = p->in.right;
			}
			else if( p->in.op == 99 )
			{  
				r = p->in.left;
			}
			else cerror( "STASG bad" );
			size = p->stn.stsize/8;
			if( size <= 0 || size > 65535 )
				cerror("structure size <0=0 or >65535");
			switch(size)
			{
			case 1:
				printf("	movb	");
				break;
			case 2:
				printf("	movw	");
				break;
			case 4:
				printf("	movl	");
				break;
			case 8:
				printf("	movq	");
				break;
			default:
				printf("	movc3	$%d,", size);
				break;
			}
			staradr( r );
			printf(",");
			if( p->in.op == 99 ) printf( "(sp)" );
			else staradr( l );
			printf("\n");
		}
		break;
	default:
		cerror( "illegal zzzcode" );
	}
}
staradr( p )
NODE *p;
{
	NODE *pp;
	pp = talloc();
	pp->in.op = (2+ 11);
	pp->in.left = p;
	upput( pp );
	pp->in.op = 97;
}
conput( p )
register NODE *p;
{
	switch( p->in.op )
	{
	case 4:
		acon( p );
		return;
	case 94:
		printf( "%s", rnames[p->tn.rval] );
		return;
	default:
		cerror( "illegal conput" );
	}
}
insput( p )
NODE *p;
{
	cerror( "insput" );
}
upput( p )
NODE *p;
{
	register NODE *r, *l, *pp;
	register o;
	pp = ( (2+ 11) == p->in.op ) ? p->in.left : p ;
	o = pp->in.op;
	if( o==2 || o==(2+ 11) || o==95 || o==116 || o==117 )
	{
		printf( "*" );
		adrput(pp);
		return;
	}
	if( o==4 )
	{
		acon( pp );
		sideff = 0;
		return;
	}
	if( o == 6 )
	{
		r = pp->in.right;
		l = pp->in.left;
		if( l->in.op == 94 && r->in.op == 4 )
		{
			acon( r );
			pp = pp->in.left;
		}
		else
		{
			
			
			if( l->in.op == 2+ 14 )
			{ 
				adrput( l->in.left );
				l = r;
			}
			else
			{
				p->in.left = r;
				adrput( p );
				p->in.left = pp;  
			}
			if( l->in.op == 64 ) l = l->in.left;
			if( l->in.op != 94 ) cerror("illegal address");
			printf( "[%s]", rnames[l->tn.rval] );
			return;
		}
	}
	else if( o == 8 )
	{
		r = pp->in.right;
		if( r->tn.op != 4 || r->tn.name ) cerror("illegal address");
		r->tn.lval = -r->tn.lval;
		acon( r );
		r->tn.lval = -r->tn.lval;
		pp = pp->in.left;
	}
	else if( o == 1+ 8 )
	{
		r = pp->in.right;
		if( r->tn.op != 4 ) cerror("illegal address");
		r = pp->in.left;
		if( r->tn.op != 94 ) cerror("illegal address");
		
		printf( "-(%s)", rnames[r->tn.rval] );
		sideff = 1;  
		return;
	}
	else if( o == 78 )
	{
		r = pp->in.right;
		if( r->tn.op != 4 ) cerror("illegal address");
		r = pp->in.left;
		if( r->tn.op != 94 ) cerror("illegal address");
		if( sideff ) printf( "(%s)+", rnames[r->tn.rval] );
		else printf( "(%s)", rnames[r->tn.rval] );
		return;
	}
	if( pp->tn.op != 94 ) cerror("illegal address");
	printf( "(%s)", rnames[pp->tn.rval] );
	return;
}
adrput( p )
register NODE *p;
{
	
	register o;
	while( (o=p->in.op) == 103 || o==104 )
	{
		p = p->in.left;
		o = p->in.op;
	}
	switch( o )
	{
	case 2:
		acon( p );
		sideff = 0;
		return;
	case 4:
		
		printf( "$" );
		acon( p );
		sideff = 0;
		return;
	case 94:
		printf( "%s", rnames[p->tn.rval] );
		sideff = 0;
		return;
	case (2+ 11):
		upput( p );
		return;
	case 95:
		sideff = 0;
		printf( "%ld(fp)", p->tn.lval - maxboff );
		return;
	case 116:
		sideff = 0;
		printf( "%ld(fp)", p->tn.lval );
		return;
	case 117:
		sideff = 0;
		printf( "%ld(ap)", p->tn.lval );
		return;
	default:
		cerror( "illegal address" );
		return;
	}
}
acon(p)
NODE *p;
{ 
	if( p->tn.name == 0 )
	{	
		printf( "%ld", p->tn.lval);
	}
	else if( p->tn.lval == 0 )
	{	
		printf( "%s", p->tn.name );
	}
	else
	{				
		printf( "%s+%ld", p->tn.name, p->tn.lval );
	}
}
char *
ccbranches[] = {
	"	jeql	L%d\n",
	"	jneq	L%d\n",
	"	jleq	L%d\n",
	"	jlss	L%d\n",
	"	jgeq	L%d\n",
	"	jgtr	L%d\n",
	"	jlequ	L%d\n",
	"	jlssu	L%d\n",
	"	jgequ	L%d\n",
	"	jgtru	L%d\n",
	};
cbgen( o, lab, mode )
int o, lab, mode;
{ 
	if( !o ) printf( "	jbr	L%d\n", lab );
	else	if( o > 89 ) cerror( "bad conditional branch: %s", opst[o] );
	else printf( ccbranches[o-80], lab );
}
special()
{
	cerror("reached special");
}

8.i             556379111   170   4     100664  22245     `
/* gencode.c */
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
	char		*hash();
	char		*savestr();
	char		*tstr();
	extern int	tstrused;
	extern char	*tstrbuf[];
	extern char	**curtstr;
extern int nerrors;  
typedef union ndu NODE;
typedef unsigned int TWORD;
typedef long CONSZ;  
extern int dope[];  
extern char *opst[];  
union ndu {
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		NODE *left;
		NODE *right;
	}in;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		CONSZ lval;
		int rval;
	}tn;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int label;  
		int lop;  
	}bn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int stsize;  
		short stalign;  
		short argsize;  
	}stn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
	}fn;	
	
	struct {
		
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
		double dval;
	}fpn;	
};
extern int busy[];
extern NODE node[];
typedef struct shape SHAPE;
	
extern struct shape {
	int	op;	
	SHAPE	*sl;	
	SHAPE	*sr;
	int	sh;	
	int	sc;	
} shapes[];
extern SHAPE	*pshape[];
typedef struct optab OPTAB;
struct optab {
	int	op;	
	int	tyop;	
	OPTAB	*nextop;
	SHAPE	**lshape;	
	int	ltype;		
	SHAPE	**rshape;	
	int	rtype;
	int	needs;
	int	rewrite;
	char	*cstring;
	int	cost;
	int	lcount;		
	int	rcount;		
	int	stinline;	
};
extern OPTAB
	*match(),
	*ophead[],
	table[];
extern NODE resc[];
extern int tmpoff;
extern int maxboff;
extern int maxtemp;
extern int maxarg;
extern int ftnno;
extern int sideff;
extern NODE
	*talloc(),
	*ind2type(),
	*tcopy(),
	*getadr(),
	*getlr();
extern CONSZ rdin();
extern char *rnames[];
extern int lineno;
extern char ftitle[];
extern int fldshf, fldsz;
extern int lflag, udebug, e2debug, odebug, rdebug, radebug, sdebug;
extern int fast;  
typedef struct inst INST;
struct inst {
	NODE	*p;
	OPTAB	*q;
	int	goal;
};
extern INST inst[300];
extern nins;
typedef SHAPE	*SHTABLE[2][20];
extern SHTABLE	sha;
typedef struct {
	unsigned char ans;
	unsigned char regmask;
	unsigned short flag;
} ret;
ret doit(), allocreg(), reg0(), indir(), tostack();
char *genjmp();
char bufs[128][64];
char *buf;
char prbuf[10240];
char *prptr;
NODE *copytree(), *gimmenode();
extern int ntree;
typedef int jmp_buf[10];
jmp_buf back;
int acnt;
gencode(p)
NODE *p;
{	NODE *q;
	if(setjmp(back)) {
		pr("#\treg\t%d\n", ++acnt);
		if(acnt > 20) {
			prtree(q);
			outpr();
			return;
		}
	}
	else
		q = copytree(p);
	buf = bufs[1];
	prptr = prbuf;
	(void) doit(q, 0, 0, 0x3f);
	acnt = ntree = 0;
	outpr();
}
ret
doit(p, flag, dest, regmask)
NODE *p;
ret dest;
{	ret s, t, x;
	char *pp;
	NODE snode, *q;
	int i, j;
	switch(p->in.op) {
	default:
		pr("#\tweird??? %d\n", p->in.op);
		return(dest);
	case 1+ 14:
		flag |= 256;
		flag &= ~1;
	case 14:
		
		t = doit(p->in.left, 2, 0, regmask);
		regmask &= ~t.regmask;
		s = doit(p->in.right, 2, 0, regmask);
		if(s.flag & 1024) {
			totemp(p, 0);
			longjmp(back, 1);
		}
		regmask &= ~s.regmask;
		if(flag & 1) {
			pr("#\tbit%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[t.ans]);
			dest.ans = 0;
			dest.flag = 1;
			dest.regmask = 0;
			return(dest);
		}
		if(flag & 256)
			dest = x = t;
		if(dest.ans == 0)
			if(s.flag & 16)
				dest = x = s;
			else if(t.flag & 16)
				dest = x = t;
			else
				dest = x = allocreg(p, regmask);
		else
			x = allocreg(p, regmask);
		if(p->in.right->in.op == 4) {
			x = tostack();	
			sprintf(	bufs[x.ans], "$%d", -p->in.right->tn.lval - 1);
		}
		else
			pr("#\tmcom%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[x.ans]);
		if(strcmp(	bufs[t.ans], 	bufs[dest.ans]) == 0)
			pr("#\tbic%c2\t%s,%s\n", childtype(p), 	bufs[x.ans], 	bufs[dest.ans]);
		else
			pr("#\tbic%c3\t%s,%s,%s\n", childtype(p), 	bufs[x.ans],
					bufs[t.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 70:
call:
		funargs(p->in.right, regmask);
		i = p->stn.argsize/32;
called:
		s = doit(p->in.left, 2|8, 0, regmask & ~3);
		pp = 	bufs[s.ans];
aftercall:
		if(regmask != 0x3f) {
			s.flag = 1024;
			return(s);
		}
		x = reg0(p, regmask);
		pr("#\tcalls\t$%d,%s\n", i, pp);
		if(p->in.op == 100 || p->in.op == 2+ 100 || (flag & 8)) {
			strcat(	bufs[x.ans], ")");
			strshift(	bufs[x.ans], 1);
				bufs[x.ans][0] = '(';
		}
		if(dest.ans == 0)
			if(flag & 256)
				dest = doit(p->in.left->in.op == 104?
					p->in.left->in.left:
					p->in.left, 0, 0, regmask & ~x.regmask);
			else
				return(x);
movexdest:	
		if(strcmp(	bufs[x.ans], 	bufs[dest.ans]) == 0)
			return(x);
		if(flag & 4)
			pr("#\tpush%c\t%s\n", type(p), 	bufs[x.ans]);
		else
			pr("#\tmov%c\t%s,%s\n", type(p), 	bufs[x.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 111:
		s = doit(p->in.left, 2, 0, regmask);
		regmask &= ~s.regmask;
		t = doit(p->in.right, 2, 0, regmask);
		if(t.flag & 1024) {
			totemp(p, 0);
			longjmp(back, 1);
		}
		pr("#\tcmp%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[t.ans]);
		dest.ans = dest.regmask = 0;
		dest.flag = 1;
		return(dest);
	case 59:	
		if(p->in.left->in.op == 108) {
			if(dest.ans == 0) {
				dest = allocreg(p, regmask);
			}
			(void) doit(p->in.left, 2, dest, regmask);
		}
		else
			(void) doit(p->in.left, 0, 0, regmask);
		s = doit(p->in.right, 2, dest, regmask);
		if(flag & 8) {
			dest.ans = 0;
			i = (s.flag & (128|512|16));
			j = s.regmask;
			buf = 	bufs[s.ans];
			goto convbuf;
		}
		return(s);
	case 77:
		s = doit(p->in.left, 2, 0, regmask);
		if(dest.ans == 0)
			if(s.flag & 16)
				dest = s;
			else
				dest = allocreg(p, regmask & ~s.regmask);
		pr("#\tmcom%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 104:
		if(p->in.left->in.op == 58 && p->in.left->in.left->in.op == (2+ 11)) {
			if(dest.ans == 0) {
				dest = allocreg(p, regmask);
				s = doit(p->in.left, 2, dest, regmask);
			}
			else {
				x = allocreg(p, regmask);
				s = doit(p->in.left, 2, x, regmask & ~x.regmask);
			}
		}
		else
			s = doit(p->in.left, 2, 0, regmask);
		regmask &= ~s.regmask;
		if(childtype(p) == type(p))
			return(s);
		if(dest.ans == 0)
			if(s.flag & 16)
				dest = s;
			else
				dest = allocreg(p, regmask);
		if(isunsigned(p->in.left) && incrsize(p) > incrsize(p->in.left)
			&& type(p) != 'f' && type(p) != 'd')
			pp = "movz";	
		else
			pp = "cvt";
		pr("#\t%s%c%c\t%s,%s\n", pp, childtype(p), type(p), 	bufs[s.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 79:
		i = -1;
		pp = "sub";
incrop:
		if(p->in.right->in.op != 4)
			fflush((&_iob[1])), cerror("codegen! incrop not with ICON");
		s = doit(p->in.left, 0, 0, regmask);
		t = doit(p->in.right, 0, 0, 0);
		if(flag & 2) {
			if(dest.ans == 0)
				dest = allocreg(p, regmask & ~s.regmask);
			pr("#\tmov%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[dest.ans]);
			if(t.flag & 64) {
				if(i == 1)
					pp = "inc";
				else
					pp = "dec";
				pr("#\t%s%c\t%s\n", pp, childtype(p), 	bufs[s.ans]);
			}
			else
				pr("#\t%s%c2\t%s,%s\n", pp, childtype(p),
						bufs[t.ans], 	bufs[s.ans]);
			if(flag & 8) {
				s = dest;
				goto inreg;
			}
			dest.flag &= ~1;
			return(dest);
		}
		if(t.flag & 64) {
			if(i == 1)
				pp = "inc";
			else
				pp = "dec";
			pr("#\t%s%c\t%s\n", pp, childtype(p), 	bufs[s.ans]);
		}
		else
			pr("#\t%s%c2\t%s,%s\n", pp, childtype(p), 	bufs[t.ans], 	bufs[s.ans]);
		if(dest.ans) {
			x = s;
			goto movexdest;
		}
		s.flag |= 1;
		return(s);
	case 1+ 60:
		flag |= 256;
	case 60:
		
		if(!isunsigned(p->in.left)) {
			if(p->in.left->in.op == 104 && type(p) == childtype(p->in.left)) {
				p->in.left = p->in.left->in.left;
			}
			if(p->in.right->in.op == 104 && type(p) == childtype(p->in.right)) {
				p->in.right = p->in.right->in.left;
			}
			pp = "div";
			goto binop;
		}
		pp = "udiv";
unsdiv:
		if(incrsize(p->in.right) != 4) {
			snode.in.op = 104;
			snode.in.left = p->in.right;
			snode.in.type = 	01000;
			s = doit(&snode, 2|4, tostack(), regmask);
		}
		else
			s = doit(p->in.right, 4, tostack(), regmask);
		regmask &= ~s.regmask;
		if(incrsize(p->in.left) != 4) {		
			snode.in.op = 104;
			snode.in.left = p->in.left;
			snode.in.type = 	01000;
			t = doit(&snode, 2|4, tostack(), regmask);
		}
		else
			t = doit(p->in.left, 4, tostack(), regmask);
		if(t.flag & 1024) {
			totemp(p, 1);
			longjmp(back, 1);
		}
		i = 2;
		goto aftercall;
	case 1+ 19:
		flag |= 256;
	case 19:
		pp = "xor";
binop:
		t = doit(p->in.left, 2, 0, regmask);
		regmask &= ~t.regmask;
		s = doit(p->in.right, 2, 0, regmask);
		if(s.flag & 1024) {
			totemp(p, 0);
			longjmp(back, 1);
		}
		regmask &= ~s.regmask;
		if(type(p) != childtype(p)) {
			x = allocreg(p, regmask);
			pr("#\t%s%c3\t%s,%s,%s\n", pp, childtype(p), 	bufs[s.ans],
					bufs[t.ans], 	bufs[x.ans]);
			if(dest.ans == 0)
				dest = x;
			pr("#\tcvt%c%c\t%s,%s\n", childtype(p), type(p),
					bufs[x.ans], 	bufs[dest.ans]);
			dest.flag |= 1;
			return(dest);
		}	
		if(dest.ans == 0)	
			if((t.flag & 16) || (flag & 256)) {
twoop:
				dest = t;
				if(*pp == 'a' && (s.flag & 64))
					pr("#\tinc%c\t%s\n", childtype(p), 	bufs[t.ans]);
				else if(*pp == 's' && (s.flag & 64))
					pr("#\tdec%c\t%s\n", childtype(p), 	bufs[t.ans]);
				else
					pr("#\t%s%c2\t%s,%s\n", pp, childtype(p),
							bufs[s.ans], 	bufs[t.ans]);
				if(flag & 8)
					goto binopaddr;
				dest.flag |= 1;
				return(dest);
			}
			else if(s.flag & 16)
				dest = s;
			else
				dest = allocreg(p, regmask);
		if((*pp == 'a' || *pp == 'm' || *pp == 'x' || *pp == 'b')
			&& strcmp(	bufs[s.ans], 	bufs[dest.ans]) == 0) {
			dest = s;
			s = t;
			t = dest;
			goto twoop;
		}
		pr("#\t%s%c3\t%s,%s,%s\n", pp, childtype(p), 	bufs[s.ans], 	bufs[t.ans], 	bufs[dest.ans]);
binopaddr:
		if(flag & 8) {
			if(dest.flag & 128) {
				strcat(	bufs[dest.ans], ")");
				strshift(	bufs[dest.ans], 1);
					bufs[dest.ans][0] = '(';
				return(dest);
			}
			if(dest.flag & 512) {
				strshift(	bufs[dest.ans], 1);
					bufs[dest.ans][0] = '*';
				dest.flag &= ~512;
				return(dest);
			}
			dest.flag = 1024;	
			return(dest);
		}
		dest.flag |= 1;
		return(dest);	
	case 103:
		
		s = doit(p->in.left, 0, 0, regmask);
		if(dest.ans == 0)
			dest = allocreg(p, regmask & ~s.regmask);
		pr("#\text%sv\t$%d,$%d,%s,%s\n", isunsigned(p->in.left)? "z": "",
			p->tn.rval/64, p->tn.rval%64, 	bufs[s.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 110:
		s = doit(p->in.left, 1|2, 0, regmask);
		pp = genjmp(p->bn.lop);
		if(s.flag & 1)
			pr("#\t%s\tL%d\n", pp, p->bn.label);
		else
			pr("#\ttst%c\t%s\n#\t%s\tL%d\n", childtype(p), 	bufs[s.ans],
				pp, p->bn.label);
		s.flag |= 1;
		return(s);
	case 108:
		s = doit(p->in.left, flag, dest, regmask);
		pr("#L%d:\n", p->bn.label);
		return(s);
	case 112:
		(void) doit(p->in.left, 0, dest, regmask);
		pr("#\tjbr\tL%d\n", p->bn.label);
		s.ans = s.regmask = s.flag = 0;
		return(s);
	case 4:
		if(p->tn.name)
			if(p->tn.lval)
				sprintf(buf, "%s+%d", p->tn.name, p->tn.lval);
			else
				sprintf(buf, "%s", p->tn.name);
		else
			sprintf(buf, "%d", p->tn.lval);
		if(!(flag & 8)) {
			strshift(buf, 1);;
			buf[0] = '$';
		}
		i = 0;
		if(p->tn.name == 0)
			if(p->tn.lval == 0)
				i = 32;
			else if(p->tn.lval == 1)
				i = 64;
		j = 0;
convbuf:	
		if(dest.ans == 0) {
			if(p->in.op == 4 || !(flag & 8)) {
				 s.ans = (buf - bufs[0])/64; buf += 64; s.flag =  i; s.regmask =  j; return(s);
			}
			if(i & 512) {
				strshift(buf, 1);
				buf[0] = '*';
				 s.ans = (buf - bufs[0])/64; buf += 64; s.flag =  i & ~512; s.regmask =  j; return(s);
			}
			if(i & 128) {
				strcat(buf, ")");
				strshift(buf, 1);
				buf[0] = '(';
				 s.ans = (buf - bufs[0])/64; buf += 64; s.flag =  i; s.regmask =  j; return(s);
			}
			pp = buf;
			buf += 64;
			s = allocreg(p, regmask);
			pr("#\tmov%c\t%s,%s\n", type(p), pp, 	bufs[s.ans]);
			flag &= ~8;
			goto inreg;
		}
		if(flag & 4)
			if(p->in.type != 040)
				pr("#\tpushl\t%s\n", buf);
			else
				pr("#\tmovd\t%s,%s\n", buf, 	bufs[dest.ans]);
		else if(i & 32)
			pr("#\tclr%c\t%s\n", type(p), 	bufs[dest.ans]);
		else	
			pr("#\tmov%c\t%s,%s\n", type(p), buf, 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 78:
		i = 1;
		pp = "add";
		goto incrop;
	case 113:	
		s = doit(p->in.left, 8, 0, 0);
		pr("#\t.long\t%s\n", 	bufs[s.ans]);
		return(dest);
	case 1+ 64:
		flag |= 256;
	case 64:
		s = doit(p->in.left, 2, 0, regmask);
		regmask &= ~s.flag;
		t = doit(p->in.right, 2, 0, regmask);
		if(t.flag & 1024) {
			totemp(p, 0);
			longjmp(back, 1);
		}
		regmask &= ~t.regmask;
		if(dest.ans == 0)
			if((s.flag & 16) || (flag & 256))
				dest = s;
			else
				dest = allocreg(p, regmask);
		pr("#\tashl\t%s,%s,%s\n", 	bufs[t.ans], 	bufs[s.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 1+ 8:
		if(p->in.right->in.op == 4) {
			i = -1;
			pp = "sub";
			flag &= ~2;
			goto incrop;
		}
		flag |= 256;
	case 8:
		pp = "sub";
		goto binop;
	case 1+ 62:
		flag |= 256;
		if(p->in.left->in.op == 104 && !isunsigned(p)) {
			snode = *p;
			snode.in.left = p->in.left->in.left;
			p = &snode;
		}
	case 62:
		if(isunsigned(p)) {
			pp = "urem";
			goto unsdiv;
		}
		s = doit(p->in.left, 2, 0, regmask);
		regmask &= ~s.regmask;
		t = doit(p->in.right, 2, 0, regmask);
		regmask &= ~t.regmask;
		x = allocreg(p, regmask);
		pr("#\tdiv%c3\t%s,%s,%s\n", childtype(p), 	bufs[t.ans], 	bufs[s.ans], 	bufs[x.ans]);
		pr("#\tmul%c2\t%s,%s\n", childtype(p), 	bufs[t.ans], 	bufs[x.ans]);
		pr("#\tsub%c3\t%s,%s,%s\n", childtype(p), 	bufs[x.ans], 	bufs[s.ans], 	bufs[x.ans]);
		if(dest.ans)
			goto movexdest;
		if(flag & 256) {
			dest = s;
			goto movexdest;
		}
		x.flag |= 1;
		return(x);
	case 1+ 11:
		flag |= 256;
	case 11:
		pp = "mul";
		goto binop;
	case 2:	
		if(p->tn.lval)
			sprintf(buf, "%s+%d", p->tn.name, p->tn.lval);
		else if(p->tn.name)
			sprintf(buf, "%s", p->tn.name);
		else
			sprintf(buf, "0");
		j = 0;
		i = 512;
		goto convbuf;
	case 1+ 17:
		flag |= 256;
	case 17:
		pp = "bis";
		goto binop;
	case 1+ 6:
		if(p->in.right->in.op == 4) {
			i = 1;
			pp = "add";
			flag &= ~2;
			goto incrop;
		}
		flag |= 256;
	case 6:
		pp = "add";
		goto binop;
	case 94:
		sprintf(buf, "r%d", p->tn.rval);
		j = 0;
		i = 128;
		goto convbuf;
	case 118: case 119:
		x = reg0(p, 3);
		x.regmask = 0;
		if(dest.ans)
			goto movexdest;
		return(x);
	case 120:
		return(reg0(p, regmask));
	case 1+ 66:
		flag |= 256;
	case 66:
		s = doit(p->in.left, 2, 0, regmask);
		regmask &= ~s.regmask;
		if(dest.ans == 0)
			if((flag & 256) || (s.flag & 16))
				dest = s;
			else
				dest = allocreg(p, regmask);
		dest.flag |= 1;
		regmask &= ~dest.regmask;
		if(p->in.right->in.op == 4 && (i = p->in.right->tn.lval) >= 0) {
			pr("#\textv\t$%d,$%d,%s,%s\n", i, 32 - i, 	bufs[s.ans], 	bufs[dest.ans]);
			return(dest);
		}
		t = doit(p->in.right, 2, 0, regmask);
		regmask &= ~t.regmask;
		x = allocreg(p, regmask);
		pr("#\tmnegl\t%s,%s\n", 	bufs[t.ans], 	bufs[x.ans]);
		pr("#\tashl\t%s,%s,%s\n", 	bufs[x.ans], 	bufs[s.ans], 	bufs[dest.ans]);
		return(dest);
	case (2+ 11):
		switch(p->in.left->in.op) {
		case 116:
		case 117:
		case 2:
			s = doit(p->in.left, 2, 0, regmask);
			sprintf(buf, "*%s", 	bufs[s.ans]);
			j = i = 0;
			goto convbuf;
		case 94:
			s = doit(p->in.left, 2, 0, regmask);
inreg:
			if(s.flag & 128) {
				sprintf(buf, "(%s)", 	bufs[s.ans]);
				j = 0;
				i = 512;
				goto convbuf;
			}
			else if(s.flag & 512) {
				sprintf(buf, "*%s", 	bufs[s.ans]);
				j = 0;
				i = 0;
				goto convbuf;
			}
			else {
				s.flag = 1024;
				return(s);
			}
		}
		q = p->in.left;
		if(q->in.op == 78
			&& q->in.right->in.op == 4 && q->in.left->in.op == 94
			&& incrsize(p) == (int) q->in.right->tn.lval) {
			s = doit(q->in.left, 2, 0, regmask);
			sprintf(buf, "(%s)+", 	bufs[s.ans]);
			i = 0;
			j = s.regmask;
			goto convbuf;
		}
		if(q->in.op == 6 && q->in.left->in.op == 64
			&& q->in.left->in.right->in.op == 4
			&& shiftsize(p) == (int) q->in.left->in.right->tn.lval) {
			s = doit(q->in.left->in.left, 2, 0, regmask);
			regmask &= ~s.regmask;
			if(!(s.flag & 128)) {
				x = allocreg(p, regmask);
				pr("#\tmov%c\t%s,%s\n", childtype(q), 	bufs[s.ans], 	bufs[x.ans]);
				regmask |= s.regmask;
				regmask &= ~x.regmask;
				s = x;
			}
			t = doit(q->in.right, 8, 0, regmask);
			sprintf(buf, "%s[%s]", 	bufs[t.ans], 	bufs[s.ans]);
			i = 0;
			j = s.regmask;
			goto convbuf;
		}
		if(q->in.op == 6
			&& (q->in.right->in.op == 4 || q->in.right->in.op == 2)) {
			s = doit(q->in.left, 2, 0, regmask);
			regmask &= ~s.regmask;
			if(!(s.flag & 128)) {
				x = allocreg(p, regmask);
				pr("#\tmov%c\t%s,%s\n", childtype(q), 	bufs[s.ans], 	bufs[x.ans]);
				regmask |= s.regmask;
				regmask &= ~x.regmask;
				s = x;
			}
			t = doit(q->in.right, 8, 0, regmask);
			sprintf(buf, "%s(%s)", 	bufs[t.ans], 	bufs[s.ans]);
			i = 512;
			j = s.regmask;
			goto convbuf;
		}
		if(q->in.op == 8 && q->in.right->in.op == 4) {
			s = doit(q->in.left, 2, 0, regmask);
			regmask &= ~s.regmask;
			if(!(s.flag & 128)) {
				x = allocreg(p, regmask);
				pr("#\tmov%c\t%s,%s\n", childtype(q), 	bufs[s.ans], 	bufs[x.ans]);
				regmask |= s.regmask;
				regmask &= ~x.regmask;
				s = x;
				if(!(s.flag & 128)) {
					s.flag = 1024;
					return(s);
				}
			}
			sprintf(buf, "%d(%s)", -q->in.right->tn.lval, 	bufs[s.ans]);
			i = 512;
			j = s.regmask;
			goto convbuf;
		}
		if(q->in.op == 1+ 8
			&& q->in.right->in.op == 4 && q->in.left->in.op == 94
			&& incrsize(p) == (int) q->in.right->tn.lval) {
			s = doit(q->in.left, 2, 0, regmask);
			sprintf(buf, "-(%s)", 	bufs[s.ans]);
			i = 0;
			j = s.regmask;
			goto convbuf;
		}
		if(q->in.op == 6 && q->in.left->in.op == 94
			&& q->in.right->in.op == 94) {
			sprintf(buf, "(r%d)[r%d]", q->in.right->tn.rval,
				q->in.left->tn.rval);
			i = 0;
			j = 0;
			goto convbuf;
		}
		s = doit(p->in.left, 2, 0, regmask);
		if(s.flag & 1024)
			return(s);
		regmask &= ~s.regmask;
		if(s.flag & 512) {
			sprintf(buf, "*%s", 	bufs[s.ans]);
			i = 0;
			j = s.regmask;
			goto convbuf;
		}
		if(!(s.flag & 128)) {
			x = allocreg(p, regmask);
			pr("#\tmov%c\t%s,%s\n", childtype(q), 	bufs[s.ans], 	bufs[x.ans]);
			regmask |= s.regmask;
			regmask &= ~x.regmask;
			s = x;
		}
		if(!(s.flag & 128)) {
			s.flag = 1024;
			return(s);
		}
		sprintf(buf, "(%s)", 	bufs[s.ans]);
		i = 0;
		j = s.regmask;
		goto convbuf;
	case 98:
		if(p->stn.stsize/8 == 4) {
			i = 'l';
stasg:
			s = doit(p->in.right, 2|8, 0, regmask);
			regmask &= ~s.regmask;
			t = doit(p->in.left, 2|8, 0, regmask);
			pr("#\tmov%c\t%s,%s\n", i, 	bufs[s.ans], 	bufs[t.ans]);
			s.regmask = s.flag = 0;
			return(s);
		}
		else if(p->stn.stsize/8 == 8) {
			i = 'q';
			goto stasg;
		}
		if(regmask != 0x3f) {
			s.flag = 1024;
			return(s);
		}
		s = doit(p->in.right, 2|8, 0, regmask);
		regmask &= ~s.regmask;
		t = doit(p->in.left, 2|8, 0, regmask);
		pr("#\tmovc3\t$%d,%s,%s\n", p->stn.stsize/8, 	bufs[s.ans], 	bufs[t.ans]);
		s.regmask = s.flag = 0;
		return(s);
	case 100:
		goto call;
	case 116:
		sprintf(buf, "%d(fp)", p->tn.lval);
		j = 0;
		i = 512;
		goto convbuf;
	case 117:
		sprintf(buf, "%d(ap)", p->tn.lval);
		j = 0;
		i = 512;
		goto convbuf;
	case 2+ 14:
		s = doit(p->in.left, 0, 0, regmask);
		regmask &= ~s.regmask;
		if(dest.ans == 0) {
			dest = allocreg(p, regmask);
		}
		if(flag & 4)
			pr("#\tpushal\t%s\n", 	bufs[s.ans]);
		else {
			pr("#\tmova%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[dest.ans]);
		}
		if(flag & 8) {
			if(dest.flag & 128) {
				strcat(	bufs[dest.ans], ")");
				strshift(	bufs[dest.ans], 1);
					bufs[dest.ans][0] = '(';
			}
			else {
				strshift(	bufs[dest.ans], 1);
					bufs[dest.ans][0] = '*';
			}
		}
		return(dest);
	case 2+ 70:
		i = 0;
		goto called;
	case 2+ 8:
		s = doit(p->in.left, 2, 0, regmask);
		if(dest.ans == 0)
			if(s.flag & 16)
				dest = s;
			else
				dest = allocreg(p, regmask & ~s.regmask);
		pr("#\tmneg%c\t%s,%s\n", childtype(p), 	bufs[s.ans], 	bufs[dest.ans]);
		dest.flag |= 1;
		return(dest);
	case 2+ 100:
		i = 0;
		goto called;
	case 58:
		if(p->in.left->in.op == 120 && dest.ans) {
			s = doit(p->in.right, 2, dest, regmask);
			return(s);
		}
		if(p->in.left->in.op == 103) {
			s = doit(p->in.left->in.left, 0, 0, regmask);
			regmask &= ~s.regmask;
			if(p->in.right->in.op == 58) {
				x = allocreg(p->in.right, regmask);
				t = doit(p->in.right, 2, x, regmask & ~x.regmask);
			}
			else
				t = doit(p->in.right, 2, 0, regmask);
			if(t.flag & 1024) {
				totemp(p->in.left, 0);
				longjmp(back, 1);
			}
			pr("#\tinsv\t%s,$%d,$%d,%s\n", 	bufs[t.ans], p->in.left->tn.rval/64,
				p->in.left->tn.rval % 64, 	bufs[s.ans]);
			t.flag |= 1;
			return(t);
		}
		if(dest.ans && p->in.left->in.op == (2+ 11)) {
			if(dest.flag & 16)
				x = dest;
			else
				x = allocreg(p, regmask);
			s = doit(p->in.right, 2, x, regmask);
			regmask &= ~s.regmask;
assignit:
			t = doit(p->in.left, 0, 0, regmask);
			pr("#\tmov%c\t%s,%s\n", type(p), 	bufs[x.ans], 	bufs[t.ans]);
			if(strcmp(	bufs[x.ans], 	bufs[dest.ans]) == 0) {
				dest.flag |= 1;
				return(dest);
			}
			goto movexdest;
		}
		if(p->in.right->in.op == 119)
			t = doit(p->in.left, 0, 0, regmask & ~3);
		else
			t = doit(p->in.left, 0, 0, regmask);
		regmask &= ~t.regmask;
		s = doit(p->in.right, 2, t, regmask);
		if(s.flag & 1024) {
		
			if(dest.ans) {
				regmask |= t.regmask;
				s = doit(p->in.right, 2, t, regmask);
				if(s.flag & 1024)
					return(s);
			}
			asgwrite(p);
			longjmp(back, 1);
		}
		if(dest.ans) {
			x = s;
			goto movexdest;
		}
		else if(flag & 8) {
			i = (s.flag & (128|512|16));
			j = s.regmask;
			buf = 	bufs[s.ans];
			goto convbuf;
		}
		s.flag |= 1;
		return(s);
	}
}
char *
genjmp(n)
{
	switch(n) {
	default:
		return("jweird");
	case 80:
		return("jeql");
	case 81:
		return("jneq");
	case 85:
		return("jgtr");
	case 84:
		return("jgeq");
	case 83:
		return("jlss");
	case 82:
		return("jleq");
	case 89:
		return("jgtru");
	case 88:
		return("jgequ");
	case 87:
		return("jlssu");
	case 86:
		return("jlequ");
	}
}

9.i             599579201   170   4     100664  19616     `
/* vmmem.c */
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	int	daddr_t;
typedef	char *	caddr_t;
typedef	u_short ino_t;
typedef	int	swblk_t;
typedef	int	size_t;
typedef	int	time_t;
typedef	int	label_t[14];
typedef	short	dev_t;
typedef	int	off_t;
typedef long	portid_t;
typedef struct	fd_set { int fds_bits[1]; } fd_set;
int	hz;			
int	timezone;		
int	dstflag;		
char	canonb[256		];	
extern char	version[];		
int	lbolt;			
time_t	time;			
time_t	bootime;		
long	trannum;		
int	hand;			
int	nblkdev;
int	nchrdev;
int	nstream;		
int	nswdev;			
int	mpid;			
char	runin;			
char	runout;			
int	runrun;			
char	kmapwnt;		
char	curpri;			
int	maxmem;			
int	physmem;		
int	nswap;			
int	updlock;		
daddr_t	rablock;		
extern	int intstack[];		
dev_t	rootdev;		
dev_t	dumpdev;		
long	dumplo;			
dev_t	swapdev;		
dev_t	argdev;			
dev_t	pipedev;		
extern	int icode[];		
extern	int szicode;		
dev_t	getmdev();
daddr_t	bmap();
caddr_t	calloc();
unsigned max();
unsigned min();
int	memall();
int	uchar(), schar();
int	vmemall();
char	*wmemall();
swblk_t	vtod();
extern struct sysent
{
	int	sy_narg;		
	int	(*sy_call)();		
} sysent[];
extern char	vmmap[];		
int	umbabeg,umbaend;	
int	noproc;			
extern	int catcher[256];
char	*panicstr;
int	wantin;
int	boothowto;		
struct pte
{
unsigned int	pg_pfnum:21,		
		:2,
		pg_vreadm:1,		
		pg_swapm:1,		
		pg_fod:1,		
		pg_m:1,			
		pg_prot:4,		
		pg_v:1;			
};
struct hpte
{
unsigned int	pg_pfnum:21,
		:2,
		pg_high:9;		
};
struct fpte
{
unsigned int	pg_blkno:20,		
		pg_fileno:5,		
		pg_fod:1,		
		:1,
		pg_prot:4,
		pg_v:1;
};
struct	pte *vtopte();
extern	struct pte Sysmap[];
extern	struct pte Usrptmap[];
extern	struct pte usrpt[];
extern	struct pte Swapmap[];
extern	struct pte Forkmap[];
extern	struct pte Xswapmap[];
extern	struct pte Xswap2map[];
extern	struct pte Pushmap[];
extern	struct pte Vfmap[];
extern	struct pte mmap[];
extern	struct pte msgbufmap[];
extern	struct pte camap[];
extern	struct pte Nexmap[][16];
extern	struct pte Prusrmap[];
struct cmap
{
unsigned int 	c_next:13,	
		c_prev:13,	
		c_lock:1,	
		c_want:1,	
		c_page:16,	
		c_hlink:13,	
		c_intrans:1,	
		c_free:1,	
		c_gone:1,	
		c_type:2,	
		c_blkno:20,	
		c_ndx:10,	
		c_mdev:6;	
};
struct	cmap *cmap;
struct	cmap *ecmap;
int	ncmap;
struct	cmap *mfind();
int	firstfree, maxfree;
int	ecmx;			
short	cmhash[512		];
struct	direct
{
	ino_t	d_ino;
	char	d_name[14		];
};
struct pcb
{
	int	pcb_ksp; 	
	int	pcb_esp; 	
	int	pcb_ssp; 	
	int	pcb_usp; 	
	int	pcb_r0; 
	int	pcb_r1; 
	int	pcb_r2; 
	int	pcb_r3; 
	int	pcb_r4; 
	int	pcb_r5; 
	int	pcb_r6; 
	int	pcb_r7; 
	int	pcb_r8; 
	int	pcb_r9; 
	int	pcb_r10; 
	int	pcb_r11; 
	int	pcb_r12; 
	int	pcb_r13; 
	int	pcb_pc; 	
	int	pcb_psl; 	
	struct  pte *pcb_p0br; 	
	int	pcb_p0lr; 	
	struct  pte *pcb_p1br; 	
	int	pcb_p1lr; 	
	int	pcb_szpt; 	
	int	pcb_cmap2;
	int	*pcb_sswap;
	int	pcb_sigc[3];
};
struct	dmap
{
	swblk_t	dm_size;	
	swblk_t	dm_alloc;	
	swblk_t	dm_map[		32	];	
};
struct	dmap zdmap;
struct	dblock
{
	swblk_t	db_base;	
	swblk_t	db_size;	
};
struct vtimes {
	int	vm_utime;		
	int	vm_stime;		
	
	unsigned vm_idsrss;		
	unsigned vm_ixrss;		
	int	vm_maxrss;		
	int	vm_majflt;		
	int	vm_minflt;		
	int	vm_nswap;		
	int	vm_inblk;		
	int	vm_oublk;		
};
struct vtimes zvms;		
 
 
struct	user
{
	struct	pcb u_pcb;
	int	u_arg[5];		
	label_t	u_qsav;			
	char	u_segflg;		
	char	u_error;		
	short	u_uid;			
	short	u_gid;			
	short	u_ruid;			
	short	u_rgid;			
	struct	proc *u_procp;		
	int	*u_ap;			
	union {				
		struct	{
			int	R_val1;
			int	R_val2;
		} u_rv;
		off_t	r_off;
		time_t	r_time;
	} u_r;
	caddr_t	u_base;			
	unsigned int u_count;		
	off_t	u_offset;		
	struct	inode *u_cdir;		
	struct	inode *u_rdir;		
	char	u_dbuf[14		];		
	caddr_t	u_dirp;			
	struct	direct u_dent;		
	struct	inode *u_pdir;		
	struct	file *u_ofile[20		];	
	char	u_pofile[20		];	
	label_t u_ssav;			
	int	(*u_signal[32])();	
	int	u_code;			
	int	*u_ar0;			
	struct uprof {			
		short	*pr_base;	
		unsigned pr_size;	
		unsigned pr_off;	
		unsigned pr_scale;	
	} u_prof;
	char	u_eosys;		
	char	u_sep;			
	dev_t	u_ttydev;		
	ino_t	u_ttyino;
	union {
	   struct {			
		int	Ux_mag;		
		unsigned Ux_tsize;	
		unsigned Ux_dsize;	
		unsigned Ux_bsize;	
		unsigned Ux_ssize;	
		unsigned Ux_entloc;	
		unsigned Ux_unused;
		unsigned Ux_relflg;
	   } Ux_A;
	   char ux_shell[32];	
	} u_exdata;
	char	u_comm[14		];
	time_t	u_start;
	char	u_acflag;
	short	u_fpflag;		
	short	u_cmask;		
	size_t	u_tsize;		
	size_t	u_dsize;		
	size_t	u_ssize;		
	struct	vtimes u_vm;		
	struct	vtimes u_cvm;		
	struct	dmap u_dmap;		
	struct	dmap u_smap;		
	struct	dmap u_cdmap, u_csmap;	
	time_t	u_outime;		
	size_t	u_odsize, u_ossize;	
	size_t	u_vrpages[20		];	
	int	u_limit[8];		
	int	u_stack[1];
					
};
extern	struct user u;
extern	struct user swaputl;
extern	struct user forkutl;
extern	struct user xswaputl;
extern	struct user xswap2utl;
extern	struct user pushutl;
extern	struct user vfutl;
extern	struct user prusrutl;
struct	proc
{
	struct	proc *p_link;	
	struct	proc *p_rlink;	
	struct	pte *p_addr;	
	char	p_usrpri;	
	char	p_pri;		
	char	p_cpu;		
	char	p_stat;
	char	p_time;		
	char	p_nice;		
	char	p_slptime;	
	char	p_cursig;
	long	p_sig;		
	long	p_siga0;	
	long	p_siga1;	
	int	p_flag;
	short	p_uid;		
	short	p_pgrp;		
	short	p_pid;		
	short	p_ppid;		
	short	p_poip;		
	short	p_szpt;		
	size_t	p_tsize;	
	size_t	p_dsize;	
	size_t	p_ssize;	
	size_t 	p_rssize; 	
	size_t	p_maxrss;	
	size_t	p_swrss;	
	swblk_t	p_swaddr;	
	caddr_t p_wchan;	
	struct	text *p_textp;	
	u_short	p_clktim;	
	u_short	p_tsleep;	
	struct	pte *p_p0br;	
	struct	proc *p_xlink;	
	short	p_cpticks;	
	float	p_pctcpu;	
	short	p_ndx;		
	short	p_idhash;	
	struct	proc *p_pptr;	
	struct	inode *p_trace;	
};
short	pidhash[	63];
struct	proc *pfind();
struct	proc *proc, *procNPROC;	
int	nproc;
struct	prochd {
	struct	proc *ph_link;	
	struct	proc *ph_rlink;
} qs[32		];
int	whichqs;		
struct	xproc
{
	struct	proc *xp_link;
	struct	proc *xp_rlink;
	struct	pte *xp_addr;
	char	xp_usrpri;
	char	xp_pri;		
	char	xp_cpu;		
	char	xp_stat;
	char	xp_time;	
	char	xp_nice;	
	char	xp_slptime;
	char	p_cursig;
	int	xp_sig;		
	int	xp_siga0;
	int	xp_siga1;
	int	xp_flag;
	short	xp_uid;		
	short	xp_pgrp;	
	short	xp_pid;		
	short	xp_ppid;	
	short	xp_xstat;	
	struct	vtimes xp_vm;
};
struct text
{
	swblk_t	x_daddr[12		];	
	swblk_t	x_ptdaddr;	
	size_t	x_size;		
	struct proc *x_caddr;	
	struct inode *x_iptr;	
	short	x_rssize;
	short	x_swrss;
	char	x_count;	
	char	x_ccount;	
	char	x_flag;		
	char	x_slptime;
	short	x_poip;		
};
struct	text *text, *textNTEXT;
int	ntext;
					
					
int	klseql;
int	klsdist;
int	klin;
int	kltxt;
int	klout;
struct vmmeter
{
	unsigned v_swtch;	
	unsigned v_trap;	
	unsigned v_syscall;	
	unsigned v_intr;	
	unsigned v_pdma;	
	unsigned v_pswpin;	
	unsigned v_pswpout;	
	unsigned v_pgin;	
	unsigned v_pgout;	
	unsigned v_pgpgin;	
	unsigned v_pgpgout;	
	unsigned v_intrans;	
	unsigned v_pgrec;	
	unsigned v_xsfrec;	
	unsigned v_xifrec;	
	unsigned v_exfod;	
	unsigned v_zfod;	
	unsigned v_vrfod;	
	unsigned v_nexfod;	
	unsigned v_nzfod;	
	unsigned v_nvrfod;	
	unsigned v_pgfrec;	
	unsigned v_faults;	
	unsigned v_scan;	
	unsigned v_rev;		
	unsigned v_seqfree;	
	unsigned v_dfree;	
	unsigned v_swpin;	
	unsigned v_swpout;	
};
struct	vmmeter cnt, rate, sum;
struct vmtotal
{
	short	t_rq;		
	short	t_dw;		
	short	t_pw;		
	short	t_sl;		
	short	t_sw;		
	int	t_vm;		
	int	t_avm;		
	short	t_rm;		
	short	t_arm;		
	int	t_vmtxt;	
	int	t_avmtxt;	
	short	t_rmtxt;	
	short	t_armtxt;	
	short	t_free;		
};
struct	vmtotal total;
int	freemem;		
int	avefree;		
int	avefree30;		
int	deficit;		
int	nscan;			
int	multprog;		
int	desscan;		
int	maxpgio;		
int	maxslp;			
int	lotsfree;		
int	minfree;		
int	desfree;		
int	saferss;		
struct	forkstat
{
	int	cntfork;
	int	cntvfork;
	int	sizfork;
	int	sizvfork;
};
struct	forkstat forkstat;
struct	swptstat
{
	int	pteasy;		
	int	ptexpand;	
	int	ptshrink;	
	int	ptpack;		
};
struct	swptstat swptstat;
struct	file
{
	short	f_flag;
	short	f_count;		
	struct inode *f_inode;		
	off_t	f_offset;		
};
struct	file *file, *fileNFILE;	
int	nfile;
struct	file *getf();
struct	file *falloc();
struct	inode
{
	short	i_flag;
	u_char	i_count;	
	char	i_fstyp;	
	dev_t	i_dev;		
	long	i_number;	
	unsigned short i_mode;
	short	i_nlink;	
	short	i_uid;		
	short	i_gid;		
	off_t	i_size;		
	struct	stdata *i_sptr;	
	union {
		struct {
			daddr_t	I_addr[13];	
			daddr_t	I_lastr;	
		} i_f;
		struct {
			daddr_t	I_rdev;		
			long	I_key;		
		} i_d;
		struct {
			long I_tag;
			struct inode *I_cip;	
		} i_a;		
		struct {
			struct proc *I_proc;	
			int	    I_sigmask;	
		} i_p;
	} i_un;
	short	i_hlink;	
};
struct	inode *inode, *inodeNINODE;
int	ninode;
struct	inode *rootdir;		
struct	inode *ialloc();
struct	inode *ifind();
struct	inode *iget();
struct	inode *owner();
struct	inode *maknode();
struct	inode *namei();
struct argnamei {	
	short flag;	
	ino_t ino;	
	dev_t idev;
	short mode;	
};
struct nx {	
	struct inode *dp;
	char *cp;
	struct buf *nbp;
	int nlink;
};
struct bufhd
{
	long	b_flags;		
	struct	buf *b_forw, *b_back;	
};
struct buf
{
	long	b_flags;		
	struct	buf *b_forw, *b_back;	
	struct	buf *av_forw, *av_back;	
	long	b_bcount;		
	short	b_error;		
	dev_t	b_dev;			
	union {
	    caddr_t b_addr;		
	    int	*b_words;		
	    struct filsys *b_filsys;	
	    struct dinode *b_dino;	
	    daddr_t *b_daddr;		
	} b_un;
	daddr_t	b_blkno;		
	long	b_resid;		
	struct  proc *b_proc;		
};
struct	buf *buf;		
char	*buffers;
int	nbuf;
struct	buf *swbuf;		
int	nswbuf;
short	*swsize;
int	*swpf;
struct	buf bfreelist[	3		];	
struct	buf bswlist;		
struct	buf *bclnlist;		
struct	buf *alloc();
struct	buf *baddr();
struct	buf *getblk();
struct	buf *geteblk();
struct	buf *bread();
struct	buf *breada();
unsigned minphys();
struct	mount	
{
	dev_t	m_dev;		
	struct	buf *m_bufp;	
	struct	inode *m_inodp;	
	struct	inode *m_idev;	
	int	m_fstyp;	
};
struct	mount mount[62		];
					
struct map {
	struct	mapent *m_limit;	
	char	*m_name;		
};
struct mapent
{
	int	m_size;		
	int	m_addr;		
};
struct	map *swapmap;
int	nswapmap;
struct	map *argmap;
struct	map *kernelmap;
vmemall(pte, size, p, type)
	register struct pte *pte;
	int size;
	struct proc *p;
{
	register int m;
	if (size <= 0 || size > maxmem)
		panic("vmemall size");
	while (size > 0) {
		if (freemem < desfree)
			wakeup((caddr_t)&proc[2]);	
		while (freemem == 0)
			sleep((caddr_t)&freemem, 0+2);
		m = imin(size, freemem);
		(void) memall(pte, m, p, type);
		size -= m;
		pte += m;
	}
	if (freemem < desfree)
		wakeup((caddr_t)&proc[2]);		
	
	return (1);
}
vmemfree(pte, count)
	register struct pte *pte;
	register int count;
{
	register struct cmap *c;
	register struct pte *spte;
	register int j;
	int size, pcnt, fileno;
	if (count % 2)
		panic("vmemfree");
	for (size = 0, pcnt = 0; count > 0; pte += 2, count -= 2) {
		if (pte->pg_fod == 0 && pte->pg_pfnum) {
			c = &cmap[	((((pte->pg_pfnum)-firstfree) / 2) + 1)];
			pcnt += 2;
			if (c->c_lock && c->c_type != 	0		) {
				for (j = 0; j < 2; j++)
					*(int *)(pte+j) &= (	0x78000000|0x00800000);
				c->c_gone = 1;
				goto free;
			}
			if (c->c_free) {
				pcnt -= 2;
				for (j = 0; j < 2; j++)
					*(int *)(pte+j) &= (	0x78000000|0x00800000);
				if (c->c_type == 	1		)
					distpte(&text[c->c_ndx], (int)c->c_page, pte);
				c->c_gone = 1;
				goto free;
			}
			if (size == 0)
				spte = pte;
			size += 2;
			continue;
		}
		if (pte->pg_fod) {
			fileno = ((struct fpte *)pte)->pg_fileno;
			if (fileno < 20		)
				if ((u.u_vrpages[fileno] -= 2) <= 0)
					if (u.u_vrpages[fileno] < 0)
						panic("vmemfree vrpages");
			for (j = 0; j < 2; j++)
				*(int *)(pte+j) &= (	0x78000000|0x00800000);
		}
free:
		if (size) {
			memfree(spte, size, 1);
			size = 0;
		}
	}
	if (size)
		memfree(spte, size, 1);
	return (pcnt);
}
munlink(pf)
	unsigned pf;
{
	register int next, prev;
	next = cmap[	((((pf)-firstfree) / 2) + 1)].c_next;
	prev = cmap[	((((pf)-firstfree) / 2) + 1)].c_prev;
	cmap[prev].c_next = next;
	cmap[next].c_prev = prev;
	cmap[	((((pf)-firstfree) / 2) + 1)].c_free = 0;
	if (freemem < minfree)
		wakeup((caddr_t)&proc[2]);	
	freemem -= 2;
}
memall(pte, size, p, type)
	register struct pte *pte;
	int size;
	struct proc *p;
{
	register struct cmap *c;
	register struct pte *rpte;
	register struct proc *rp;
	int i, j, next, curpos;
	unsigned pf;
	struct cmap *c1, *c2;
	if (size % 2)
		panic("memall");
	if (size > freemem)
		return (0);
	;
	for (i = size; i > 0; i -= 2) {
		curpos = cmap[0].c_next;
		c = &cmap[curpos];
		if (c->c_free == 0)
			panic("dup mem alloc");
		if (	((((curpos)-1) * 2) + firstfree) > maxfree)
			panic("bad mem alloc");
		if (c->c_gone == 0 && c->c_type != 	0		) {
			if (c->c_type == 	1		)
				rp = text[c->c_ndx].x_caddr;
			else
				rp = &proc[c->c_ndx];
			while (rp->p_flag & 0x00004000	)
				rp = rp->p_xlink;
			switch (c->c_type) {
			case 	1		:
				rpte = 		((rp)->p_p0br + ( c->c_page));
				break;
			case 	2		:
				rpte = 		((rp)->p_p0br + (rp)->p_tsize + ( c->c_page));
				break;
			case 	3		:
				rpte =  	(((rp)->p_p0br + (rp)->p_szpt*	(	512/(sizeof (struct pte))) - 8		 - 1) - ( c->c_page));
				break;
			}
				(rpte)[1]. pg_pfnum = (rpte)[0]. pg_pfnum = 0;
			if (c->c_type == 	1		)
				distpte(&text[c->c_ndx], (int)c->c_page, rpte);
		}
		switch (type) {
		case 	0		:
			c->c_ndx = p->p_ndx;
			break;
		case 	1		:
			c->c_page = 	((int)( ptetov(p, pte)));
			c->c_ndx = p->p_textp - &text[0];
			break;
		case 	2		:
			c->c_page = 	((int)(( ptetov(p, pte)) - (p)->p_tsize));
			c->c_ndx = p->p_ndx;
			break;
		case 	3		:
			c->c_page = 	((int)(		(((unsigned)((0x80000000-8		*	512))) >> 	9		) - 1 - ( ptetov(p, pte))));
			c->c_ndx = p->p_ndx;
			break;
		}
		if (c->c_blkno) {
			
			j = 	((c->c_blkno)&(512		-1));
			c1 = &cmap[cmhash[j]];
			if (c1 == c)
				cmhash[j] = c1->c_hlink;
			else {
				for (;;) {
					if (c1 == ecmap)
						panic("memall ecmap");
					c2 = c1;
					c1 = &cmap[c2->c_hlink];
					if (c1 == c)
						break;
				}
				c2->c_hlink = c1->c_hlink;
			}
			if (mfind(c->c_mdev == 15		 ?
			      swapdev : mount[c->c_mdev].m_dev,
			      (daddr_t)c->c_blkno))
				panic("memall mfind");
			c1->c_mdev = 0;
			c1->c_blkno = 0;
			c1->c_hlink = 0;
		}
		pf = 	((((curpos)-1) * 2) + firstfree);
		for (j = 0; j < 2; j++)
			*(int *)pte++ = pf++;
		c->c_free = 0;
		c->c_gone = 0;
		if (c->c_intrans || c->c_want)
			panic("memall intrans|want");
		c->c_lock = 1;
		c->c_type = type;
		freemem -= 2;
		next = c->c_next;
		cmap[0].c_next = next;
		cmap[next].c_prev = 0;
	}
	return (size);
}
memfree(pte, size, detach)
	register struct pte *pte;
	register int size;
{
	register int i, j, prev, next;
	register struct cmap *c;
	
	if (size % 2)
		panic("memfree");
	if (freemem < 2 * (32/2))
		wakeup((caddr_t)&freemem);
	while (size > 0) {
		size -= 2;
		i = pte->pg_pfnum;
		if (i < firstfree || i > maxfree)
			panic("bad mem free");
		i = 	((((i)-firstfree) / 2) + 1);
		c = &cmap[i];
		if (c->c_free)
			panic("dup mem free");
		if (detach && c->c_type != 	0		) {
			for (j = 0; j < 2; j++)
				*(int *)(pte+j) &= (	0x78000000|0x00800000);
			c->c_gone = 1;
		}
		if (detach && c->c_blkno == 0) {
			next = cmap[0].c_next;
			cmap[next].c_prev = i;
			c->c_prev = 0;
			c->c_next = next;
			cmap[0].c_next = i;
		} else {
			prev = cmap[0].c_prev;
			cmap[prev].c_next = i;
			c->c_next = 0;
			c->c_prev = prev;
			cmap[0].c_prev = i;
		}
		c->c_free = 1;
		freemem += 2;
		pte += 2;
	}
}
caddr_t
wmemall(pmemall, n)
	int (*pmemall)(), n;
{
	int npg;
	caddr_t va;
	register int a;
	npg = 	((((unsigned)(n)+511)>>9));
	a = rmalloc(kernelmap, npg);
	if (a == 0)
		return (0);
	if ((*pmemall)(&Usrptmap[a], npg, &proc[0], 	0		) == 0) {
		rmfree(kernelmap, npg, a);
		return (0);
	}
	va = (caddr_t) 	(usrpt + (a) * 	(	512/(sizeof (struct pte))));
	vmaccess(&Usrptmap[a], va, npg);
	return (va);
}
wmemfree(va, n)
	caddr_t va;
	int n;
{
	register int a;
	int npg;
	a = 	((((struct pte *) va) - usrpt) / 	(	512/(sizeof (struct pte))));
	npg = 	((((unsigned)(n)+511)>>9));
	(void) memfree(&Usrptmap[a], npg, 0);
	rmfree(kernelmap, npg, a);
}
mhash(c, dev, bn)
	register struct cmap *c;
	dev_t dev;
	daddr_t bn;
{
	register int i = 	((bn)&(512		-1));
	c->c_hlink = cmhash[i];
	cmhash[i] = c - cmap;
	c->c_blkno = bn;
	i = getfsx(dev);
	if (i == -1)
		panic("mhash");
	c->c_mdev = i;
}
munhash(dev, bn)
	dev_t dev;
	daddr_t bn;
{
	register int i = 	((bn)&(512		-1));
	register struct cmap *c1, *c2;
	c1 = &cmap[cmhash[i]];
	if (c1 == ecmap)
		panic("munhash");
	if (c1->c_blkno == bn && getfsx(dev) == c1->c_mdev)
		cmhash[i] = c1->c_hlink;
	else {
		for (;;) {
			c2 = c1;
			c1 = &cmap[c2->c_hlink];
			if (c1 == ecmap)
				panic("munhash");
			if (c1->c_blkno == bn && getfsx(dev) == c1->c_mdev)
				break;
		}
		c2->c_hlink = c1->c_hlink;
	}
	if (mfind(dev, bn))
		panic("munhash mfind");
	c1->c_mdev = 0;
	c1->c_blkno = 0;
	c1->c_hlink = 0;
}
struct cmap *
mfind(dev, bn)
	dev_t dev;
	daddr_t bn;
{
	register struct cmap *c1 = &cmap[cmhash[	((bn)&(512		-1))]];
	while (c1 != ecmap) {
		if (c1->c_blkno == bn && c1->c_mdev == getfsx(dev))
			return (c1);
		c1 = &cmap[c1->c_hlink];
	}
	return ((struct cmap *)0);
}
mpurge(mdev)
	int mdev;
{
	register struct cmap *c1, *c2;
	register int i;
	for (i = 0; i < 512		; i++) {
more:
		c1 = &cmap[cmhash[i]];
		if (c1 == ecmap)
			continue;
		if (c1->c_mdev == mdev)
			cmhash[i] = c1->c_hlink;
		else {
			for (;;) {
				c2 = c1;
				c1 = &cmap[c1->c_hlink];
				if (c1 == ecmap)
					goto cont;
				if (c1->c_mdev == mdev)
					break;
			}
			c2->c_hlink = c1->c_hlink;
		}
		c1->c_mdev = 0;
		c1->c_blkno = 0;
		c1->c_hlink = 0;
		goto more;
cont:
		;
	}
}
meminit(first, last)
	int first, last;
{
	register int i;
	register struct cmap *c;
	firstfree = 	(((first) + (2-1)) &~ (2-1));
	maxfree = 	(((last - (2 - 1)) + (2-1)) &~ (2-1));
	freemem = maxfree - firstfree;
	ecmx = ecmap - cmap;
	if (ecmx < freemem / 2)
		freemem = ecmx * 2;
	for (i = 1; i <= freemem / 2; i++) {
		cmap[i-1].c_next = i;
		c = &cmap[i];
		c->c_prev = i-1;
		c->c_free = 1;
		c->c_gone = 1;
		c->c_type = 	0		;
		c->c_mdev = 0;
		c->c_blkno = 0;
	}
	cmap[freemem / 2].c_next = 0;
	for (i = 0; i < 512		; i++)
		cmhash[i] = ecmx;
	cmap[0].c_prev = freemem / 2;
	cmap[0].c_type = 	0		;
	avefree = freemem;
	hand = 0;
}
mwait(pf)
	unsigned pf;
{
	mlock(pf);
	munlock(pf);
}
mlock(pf)
	unsigned pf;
{
	register struct cmap *c = &cmap[	((((pf)-firstfree) / 2) + 1)];
	while (c->c_lock) {
		c->c_want = 1;
		sleep((caddr_t)c, 0+1);
	}
	c->c_lock = 1;
}
munlock(pf)
	unsigned pf;
{
	register struct cmap *c = &cmap[	((((pf)-firstfree) / 2) + 1)];
	if (c->c_lock == 0)
		panic("dup page unlock");
	if (c->c_want)
		wakeup((caddr_t)c);
	c->c_lock = 0;
	c->c_want = 0;
}
vslock(base, count)
	caddr_t base;
{
	register unsigned v;
	register int npf;
	register struct pte *pte;
	u.u_procp->p_flag |= 0x00000200	;
	v = 		(((unsigned)(base)) >> 	9		);
	pte = vtopte(u.u_procp, v);
	npf = 	((((unsigned)(count + ((int)base & 	(2*	512-1)	))+511)>>9));
	while (npf > 0) {
		if (pte->pg_v) 
			mlock(pte->pg_pfnum);
		else
			if (fubyte((caddr_t)	((v)<<9)) < 0)
				panic("vslock");
		pte += 2;
		v += 2;
		npf -= 2;
	}
	u.u_procp->p_flag &= ~0x00000200	;
}
vsunlock(base, count, rw)
	caddr_t base;
{
	register struct pte *pte;
	register int npf;
	pte = vtopte(u.u_procp, 		(((unsigned)(base)) >> 	9		));
	npf = 	((((unsigned)(count + ((int)base & 	(2*	512-1)	))+511)>>9));
	while (npf > 0) {
		munlock(pte->pg_pfnum);
		if (rw == 	0x000001	)	
			pte->pg_m = 1;
		pte += 2;
		npf -= 2;
	}
}
A.i             599579236   170   4     100664  152       `
double a();
main()
{
	double x;
	x = a(x);
	x = a();
}
double *df(), sin(), x;
char *cf(), c;
xxx()
{
	*df() = *cf() = x;
/*	*df() = *cf() = sin();*/
}
B.i             599579312   170   4     100664  2278      `
struct{
	struct{
		struct{
			struct{
				long _selection;
				long _state;
			}_S;
		}_CK;
		struct{
			struct{
				long _selection;
				long _state;
			}_S;
		}_D;
		struct{
			long _q;
			long _qn;
			struct{
				long _q;
				long _qn;
				struct{
					long _selection;
					struct{
						struct{
							struct{
								long _selection;
								long _state;
							}_OM;
						}_G;
					}_GT[2];
				}_MX;
				struct{
					struct{
						struct{
							struct{
								long _selection;
								long _state;
							}_OM;
						}_G;
					}_IG;
				}_IN[2];
			}_R[2];
		}_FF;
		struct{
			long _q;
			long _qn;
			struct{
				long _state;
			}_B[2];
		}_ff;
		struct{
			long _state;
		}_TASK;
		struct{
			long _selection;
			long _state;
		}_INIT;
		struct{
			struct{
				long _state;
			}_K;
			struct{
				long _state;
			}_STEP;
		}_SETUP;
		struct{
			long _selection;
			struct{
				long _selection;
				long _state;
			}_G[2];
			struct{
				struct{
					long _state;
				}_K;
				struct{
					long _state;
				}_STEP;
			}_R;
		}_PROP;
		struct{
			long _selection;
			struct{
				long _selection;
				long _state;
			}_G[2];
		}_MINT;
	}_TEST;
}_;

crank(){

						struct local{
							int a,b,e,g,j,s,n,p,r,l,L;
							long _state[3];
							char q[3];
						};
						register struct local *S;
S->_state[S->n]=((_._TEST._CK._S._selection!=1)?0:(_._TEST._D._S._selection!=mod(_._TEST._SETUP._STEP._state,2))?_._TEST._D._S._selection:0?_._TEST._FF._R[0]._IN[0]._IG._G._OM._selection:(((_._TEST._SETUP._STEP._state<=1)&&(_._TEST._FF._R[0]._MX._GT[0]._G._OM._selection==mod(_._TEST._SETUP._STEP._state,2))&&(_._TEST._FF._R[0]._MX._GT[0]._G._OM._selection==_._TEST._FF._R[0]._MX._GT[0]._G._OM._state))||((2<=_._TEST._SETUP._STEP._state)&&(_._TEST._SETUP._STEP._state<=3)&&(_._TEST._FF._R[0]._IN[0]._IG._G._OM._selection==mod((_._TEST._SETUP._STEP._state+1),2))&&(_._TEST._FF._R[0]._IN[0]._IG._G._OM._selection==_._TEST._FF._R[0]._IN[0]._IG._G._OM._state))||((4<=_._TEST._SETUP._STEP._state)&&(_._TEST._SETUP._STEP._state<=5)&&(_._TEST._FF._R[0]._IN[1]._IG._G._OM._selection==mod(_._TEST._SETUP._STEP._state,2))&&(_._TEST._FF._R[0]._IN[1]._IG._G._OM._selection==_._TEST._FF._R[0]._IN[1]._IG._G._OM._state)))?(_._TEST._SETUP._STEP._state+2):_._TEST._SETUP._STEP._state);
}
C.i             576173776   170   4     100664  257       `
double d, df(), xf(); int i, j, k, l;
f()
{
	d = (i ? i*df(j) : 0.0) + (k ? k*xf(l) : 0.0);
	d = 1/d;
}


xx(a, b) register double a; register float b;
{	register double c; register float d;
	register double e; register float f;
	a=b; a=c; a=d; a=e; a=f;
}

D.i             556379112   170   4     100664  117       `
x(a)
char *a;
{	unsigned u();
	int i;
	a[i] = u() / 2;
}
xx()
{
	int i; char *p;
	while((i-- > 0) && (*p++ > 12));
}

E.i             587240744   170   4     100664  119       `
main()
{	int i, j;
	if((i = j++) == 0)
		a();
	else
		b();
}

int d[12];
x()
{	register int a, b, c;
	a = b << d[c];
}

F.i             599579416   170   4     100664  143       `
struct a {int a;} a, b, c;
struct a xx();
main()
{	int i;
	foo1((a, a = xx()));
	foo2((a, a));
	foo3(a);
	foo4(i *= 2,i *= 3);
	foo5(&xx());
}

G.i             556379112   170   4     100664  262       `
int i; unsigned int ui;
main()
{
	if(ui++ < 0) a(); else b();
	if((i -= (unsigned )1) < 0) a(); else b();
	ui /= (unsigned)12;
	i /= (unsigned)12;
	ui /= 12;
	i /= 12;
	ui %= (unsigned)12;
	i %= (unsigned)12;
	ui %= 12;
	i %= 12;
	ui -= 1;
	i -= (unsigned) 1;
}
H.i             556379112   170   4     100664  88        `
main()
{	register mask, xmask;
	int i = 0;
	mask = 0x80 >> i;
	xmask = 0x100080 >> i;
}
I.i             556379112   170   4     100664  133       `
typedef union {
	int *i;
	char *c;
} anything;
main()
{
	register anything src,dest;
	*dest.i++ = *src.i++;
	*dest.c++ = *src.c++;
}

J.i             556379113   170   4     100664  85        `
struct a {int x, y;} *r, *s;
main()
{	int x, *f(), y;
	x = *f() = y;
	*r++ = *s++;
}

K.i             556379113   170   4     100664  117       `
main()
{	register struct { int a:3, b:3;} *x;
	register int i;
	(*(--x)).b = 12;
	(*(--x)).b += 1;
	x[i++].b += 1;
}

L.i             599585509   170   4     100664  107       `
struct S { char c[2]; };
struct S f( s, i )
struct S s; {}
main()
{	struct S a;
	(void) f( f(a, 0), 1 );
}

M.i             556379113   170   4     100664  121       `
struct S { unsigned char m, n;} Z;
int i;
struct S f( s )
struct S s;
{
	return f( i ? f(s) : Z );	/* movaw r0,r0 ! */
}

N.i             599585589   170   4     100664  109       `
struct S { char c[2]; };

struct S f();
main()
{
	static struct S X[4];
	register int i;
	(void) f(X[i]);
}


O.i             556379113   170   4     100664  155       `
main(){
	double sin(), x=sin(sin(0.));
}
long o[10];
foo12(){
	register char *p;
	int h;
	*p++=o[h]>>8;
}
foo(a,n)
double *a;
int n;
{
	(a--)[n] = 1.23;
}

P.i             599585612   170   4     100664  464       `
typedef struct { int x, y;} Point;
extern Point map(), a, b, c;
main ()
{	register Point *pt, *ppt;
	Point x, y, z;
	x = y = z;
	*pt++ = map (*ppt++);
	a = b = c;
	(void) map(a = b = c);
	if((a = x = map()).y)
		;
	if((b = a = map()).y)
		;
}
struct a {long p, q; char s;};
struct a f();
x0x()
{	struct a v, x, y;
	if((v=f()).s);
	v = x = y;
	return(f().s);
}
a22(){
	double d;
	int i, j;
	short x, y;
	x = x/y;
	x /= y;
	i /= d;
	j = i / d;
	j = i * d; i *= d;
}
Q.i             556379113   170   4     100664  78        `
a()
{	register char *m;
	register int i;
	*(int *)(m + i) = 12;
	m[i] = 12;
}
R.i             588864160   170   4     100664  127       `
main(){
	float a;
	double b, c;
	a+=b+c;
	a = b;
}
x()
{	int *x;	
	int a, b, c, d;
	f(((a? (b = 1): (c = 2)), (d ? 3 : 4)));
}

S.i             556379114   170   4     100664  20880     `
extern	struct	_iobuf {
	int	_cnt;
	char	*_ptr;
	char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
  struct _Point {
	int	x;
	int	y;
};
struct _Rectangle {
	  struct _Point	ll;
	  struct _Point	ur;
};
  struct _Object {
	  struct _Object	*link;
};
  struct _Pool {
	  struct _Object	*freelist;
	  struct _Object	*arealist;
	int	objsize;
};
  struct _Vpool {
	  struct _Object	*next;
	  struct _Object	*arealist;
	int	left;
	int	quantum;
};
	  struct _SEQFILE {
		int	hidden;
	};
extern char *myname;
extern int nullstring;
extern char *stringtab;
extern char *execname();
extern struct _iobuf *chkfopen();
extern   struct _Pool *newpool();
extern   struct _Vpool *newvpool();
extern char *maketemp();
extern char *permspace();
extern   struct _SEQFILE *seqopen();
extern char *strchr();
extern char *strrchr();
extern char debug;
	struct _Bsim_hd {
	int	magic;
	int	vdd;
	int	vss;
	int	offtrans;	
	int	offcap;		
	int	ntrans;		
	int	maxnode;	
	int	offarrays;	
	int	ngroups;	
	int	nnodes;		
	int	nsws;		
	int	nargs;		
	int	nops;
	int	nctrls;
	char	clean;		
};
	struct _Bsim_tr {
	char	type;		
	char	selfgate;
	int	group;
	int	numb;
	float	length;
	float	width;
	int	src;
	int	drn;
	int	gate;
};
union  _Objgroup {
	struct {
		char	type;
		char	powstr;
		short	nnodes;
		int	nodeoffset;
		int	domoffset;
		int	vssoffset;
		int	vddoffset;
	} gen;
	struct {
		char	type;
		int	opoffset;
		int	argoffset;
		int	nodeoffset;
	} pol;
	struct {
		char	type;
		int	inoffset;
		int	outoffset;
		int	nodeoffset;
	} inv;
};
struct _Objnode {
	int	orignum;
	int	size;
	int	ctrloffset;
	int	swoffset;
	char	selfgate;
};
	struct _Objsw {
	char	flags;
	char	str;
	short	relnode;
	int	gate;
};
struct _Objctrl {
	int	group;
	int	gate;
};
extern 	struct _Bsim_tr *firsttrans ();
extern 	struct _Bsim_tr *nexttrans ();
union  _Group {
	struct {
		union  _Group	*qlink;
		struct _Node	*nodelist;
		char	type;
		char	powstr;
		short	nnodes;
		char	*domtab;
		struct _Sw	*vsslist;
		struct _Sw	*vddlist;
	} gen;
	struct {
		union  _Group	*qlink;
		struct _Node	*nodelist;
		char	type;
		char	*oplist;
		struct _Node	**arglist;
	} pol;
	struct {
		union  _Group	*qlink;
		struct _Node	*nodelist;
		char	type;
		struct _Node	*input;
		struct _Node	*output;
	} inv;
};
struct _Delay {
	struct _Delay	*forw;
	struct _Delay	*back;
	union  _Group	**ctrllist;
	struct _Node	*node;
	char	delta[3];
	int	when;
} ;
struct _Node {
	char	val;
	char	nextval;
	char	flags;
	char	size;
	int	orignum;
	union	{
		union  _Group	**ctrllist;
		struct _Delay	*delay;
	} 	u;
	struct _Sw	*swlist;
};
struct _Sw {
	char	flags;
	char	str;
	short	relnode;
	struct _Node	*gate;
};
struct _Tnode {
	struct _Tnode	*forw;
	struct _Tnode	*back;
	char	str0;
	char	str1;
	char	xstr0;
	char	xstr1;
	char	val;
	struct _Sw	*swlist;
};
extern char nottab [];
extern char *nettoname();
extern char valstring[];
extern char dqueue;
extern char devalgen;
extern char ddelay;
extern struct _Node *findnode();
extern struct _Node *nettonode();
extern union  _Group *nodetogroup();
extern union  _Group **getctrllist();
extern char debug;
extern   struct _SEQFILE *objfile;
extern 	struct _Bsim_hd header;
extern union  _Group *group;
extern union  _Group **ctrl;
extern struct _Node *node;
extern struct _Sw *sw;
extern struct _Node **arg;
extern char *op;
extern struct _Tnode *tnode;
extern struct _Tnode *list;
extern union  _Group endofq;
extern union  _Group *firstonq;
extern union  _Group *lastonq;
static struct _Node *firstnode, *lastnode;
static struct _Tnode *pasttnode;
static struct _Tnode *toplist;
static char anyxs;
static char *tnodename (this)
register struct _Tnode *this;
{
	register int n;
	switch (n = this - tnode) {
	case 0:
		return "vss";
	case 1:
		return "vdd";
	default:
		return nettoname (firstnode[n-2].orignum);
	}
}
prop_on (domtab)
register char *domtab;
{
	register struct _Tnode *this, *that, *newl;
	register struct _Sw *s;
	struct _Tnode *l;
	char v;
	for (l = toplist; l > &list[0]; l--) {
		if (devalgen)
			printf ("prop_on level %d\n", l-list);
		for (this = l->forw; this != l; this = this->forw) {
			if (this->str0 == l->str0) {
				if ( (domtab[this->str1] >= ( this->str0)))
					continue;
				if (this->str1 == this->str0) {
												{											if (devalgen)										printf ("\tonprop from %s, myval_%d\n", tnodename(this), 2);	s = this->swlist;								if (s != 0) {									for (;;) {										switch (s->gate->val) {								default:										fatal ("bad val");							case 2:											anyxs = 1;									break;									case 0:											if ( ! (s->flags & 0x02)) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;									goto  labx;								case 1:											if (s->flags & 0x02) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;					 labx:				if (2 != 1) {										{					(v) = ( this->str0);			if (( this->str0) > ( s->str))				(v) = ( s->str);	};						if (v > that->str0) {									that->str0 = v;									if (v > that->str1) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										if (2 != 0) {										{					(v) = ( this->str1);			if (( this->str1) > ( s->str))				(v) = ( s->str);	};						if (v > that->str1) {									that->str1 = v;									if (v > that->str0) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										break;									}										if (s->flags & 	0x04)									break;									s++;									}									}									};
					continue;
				} else {
												{											if (devalgen)										printf ("\tonprop from %s, myval_%d\n", tnodename(this), 0);	s = this->swlist;								if (s != 0) {									for (;;) {										switch (s->gate->val) {								default:										fatal ("bad val");							case 2:											anyxs = 1;									break;									case 0:											if ( ! (s->flags & 0x02)) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;									goto  lab0;								case 1:											if (s->flags & 0x02) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;					 lab0:				if (0 != 1) {										{					(v) = ( this->str0);			if (( this->str0) > ( s->str))				(v) = ( s->str);	};						if (v > that->str0) {									that->str0 = v;									if (v > that->str1) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										if (0 != 0) {										{					(v) = ( this->str1);			if (( this->str1) > ( s->str))				(v) = ( s->str);	};						if (v > that->str1) {									that->str1 = v;									if (v > that->str0) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										break;									}										if (s->flags & 	0x04)									break;									s++;									}									}									};
					if ( (domtab[this->str0] >= ( this->str1)))
						continue;
					if (this->str0 < this->str1)
						continue;
					newl = &list[this->str1];
				}
			} else {
				if ( (domtab[this->str0] >= ( this->str1)))
					continue;
											{											if (devalgen)										printf ("\tonprop from %s, myval_%d\n", tnodename(this), 1);	s = this->swlist;								if (s != 0) {									for (;;) {										switch (s->gate->val) {								default:										fatal ("bad val");							case 2:											anyxs = 1;									break;									case 0:											if ( ! (s->flags & 0x02)) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;									goto  lab1;								case 1:											if (s->flags & 0x02) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;					 lab1:				if (1 != 1) {										{					(v) = ( this->str0);			if (( this->str0) > ( s->str))				(v) = ( s->str);	};						if (v > that->str0) {									that->str0 = v;									if (v > that->str1) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										if (1 != 0) {										{					(v) = ( this->str1);			if (( this->str1) > ( s->str))				(v) = ( s->str);	};						if (v > that->str1) {									that->str1 = v;									if (v > that->str0) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										break;									}										if (s->flags & 	0x04)									break;									s++;									}									}									};
				if ( (domtab[this->str1] >= ( this->str0)))
					continue;
				if (this->str1 < this->str0)
					continue;
				newl = &list[this->str0];
			}
			that = this->forw;
							{							(this)->forw->back = (this)->back;		(this)->back->forw = (this)->forw;	};
						{				 		(this)->back = ( newl)->back;		( newl)->back = (this);			(this)->forw = ( newl);			(this)->back->forw = (this);	};
			this = that->back;
		}
	}
}
prop_xon (domtab)
register char *domtab;
{
	register struct _Tnode *this, *that, *newl;
	register struct _Sw *s;
	struct _Tnode *l;
	char v;
	for (l = toplist; l > &list[0]; l--) {
		if (devalgen)
			printf ("prop_xon level %d\n", l-list);
		for (this = l->forw; this != l; this = this->forw) {
			if (this->xstr0 == l->str0) {
				if ( (domtab[this->xstr1] >= ( this->xstr0)))
					continue;
				if (this->xstr1 == this->xstr0) {
												{											if (devalgen)										printf ("\txonprop from %s, myval_%d\n", tnodename(this), 2);	s = this->swlist;								if (s != 0) {									for (;;) {										switch (s->gate->val) {								default:										fatal ("bad val");							case 0:											if ( ! (s->flags & 0x02)) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;									goto  labx;								case 2:											that = &tnode[s->relnode];							if (s->flags & 0x02) {								if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;								} else {										if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;								}										goto  labx;								case 1:											if (s->flags & 0x02) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;					 labx:				if (2 != 1) {										{					(v) = ( this->xstr0);			if (( this->xstr0) > ( s->str))				(v) = ( s->str);	};						if (v > that->xstr0) {									that->xstr0 = v;								if (v > that->xstr1) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										if (2 != 0) {										{					(v) = ( this->xstr1);			if (( this->xstr1) > ( s->str))				(v) = ( s->str);	};						if (v > that->xstr1) {									that->xstr1 = v;								if (v > that->xstr0) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										break;									}										if (s->flags & 	0x04)									break;									s++;									}									}									};
					continue;
				} else {
												{											if (devalgen)										printf ("\txonprop from %s, myval_%d\n", tnodename(this), 0);	s = this->swlist;								if (s != 0) {									for (;;) {										switch (s->gate->val) {								default:										fatal ("bad val");							case 0:											if ( ! (s->flags & 0x02)) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;									goto  lab0;								case 2:											that = &tnode[s->relnode];							if (s->flags & 0x02) {								if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;								} else {										if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;								}										goto  lab0;								case 1:											if (s->flags & 0x02) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;					 lab0:				if (0 != 1) {										{					(v) = ( this->xstr0);			if (( this->xstr0) > ( s->str))				(v) = ( s->str);	};						if (v > that->xstr0) {									that->xstr0 = v;								if (v > that->xstr1) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										if (0 != 0) {										{					(v) = ( this->xstr1);			if (( this->xstr1) > ( s->str))				(v) = ( s->str);	};						if (v > that->xstr1) {									that->xstr1 = v;								if (v > that->xstr0) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										break;									}										if (s->flags & 	0x04)									break;									s++;									}									}									};
					if ( (domtab[this->xstr0] >= ( this->xstr1)))
						continue;
					if (this->xstr0 < this->xstr1)
						continue;
					newl = &list[this->xstr1];
				}
			} else {
				if ( (domtab[this->xstr0] >= ( this->xstr1)))
					continue;
											{											if (devalgen)										printf ("\txonprop from %s, myval_%d\n", tnodename(this), 1);	s = this->swlist;								if (s != 0) {									for (;;) {										switch (s->gate->val) {								default:										fatal ("bad val");							case 0:											if ( ! (s->flags & 0x02)) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;									goto  lab1;								case 2:											that = &tnode[s->relnode];							if (s->flags & 0x02) {								if (s->flags & 0x08 &&							    this->val == 0 && that->val == 0)							break;								} else {										if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;								}										goto  lab1;								case 1:											if (s->flags & 0x02) break;						that = &tnode[s->relnode];							if (s->flags & 0x08 &&							    this->val == 1 && that->val == 1)							break;					 lab1:				if (1 != 1) {										{					(v) = ( this->xstr0);			if (( this->xstr0) > ( s->str))				(v) = ( s->str);	};						if (v > that->xstr0) {									that->xstr0 = v;								if (v > that->xstr1) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										if (1 != 0) {										{					(v) = ( this->xstr1);			if (( this->xstr1) > ( s->str))				(v) = ( s->str);	};						if (v > that->xstr1) {									that->xstr1 = v;								if (v > that->xstr0) {													{							(that)->forw->back = (that)->back;		(that)->back->forw = (that)->forw;	};									newl = &list[v];											{				 		(that)->back = ( newl)->back;		( newl)->back = (that);			(that)->forw = ( newl);			(that)->back->forw = (that);	};							}									}									}										break;									}										if (s->flags & 	0x04)									break;									s++;									}									}									};
				if ( (domtab[this->xstr1] >= ( this->xstr0)))
					continue;
				if (this->xstr1 < this->xstr0)
					continue;
				newl = &list[this->xstr0];
			}
			that = this->forw;
							{							(this)->forw->back = (this)->back;		(this)->back->forw = (this)->forw;	};
						{				 		(this)->back = ( newl)->back;		( newl)->back = (this);			(this)->forw = ( newl);			(this)->back->forw = (this);	};
			this = that->back;
		}
	}
}
dumpstr (s, domtab)
char *s;
char *domtab;
{
	register struct _Tnode *this;
	puts (s);
	for (this = &tnode[2]; this < pasttnode; this++)
		printf ("\ttnode[%d] %s str0=%d>%d str1=%d>%d\n",
			this-tnode, nettoname(firstnode[this-tnode-2].orignum),
			this->str0, domtab[this->str0],
			this->str1, domtab[this->str1]
		);
}
dumpxstr (s, domtab)
char *s;
char *domtab;
{
	register struct _Tnode *this;
	puts (s);
	for (this = &tnode[2]; this < pasttnode; this++) {
		printf ("\ttnode[%d] %s ",
			this-tnode, nettoname(firstnode[this-tnode-2].orignum)
		);
		printf ("str0=%d str1=%d xstr0=%d xstr1=%d\n",
			this->str0, domtab[this->str0],
			this->str1, domtab[this->str1],
			this->xstr0, domtab[this->xstr0],
			this->xstr1, domtab[this->xstr1]
		);
	}
}
evalgen (g)
register union  _Group *g;
{
	register struct _Node *n;
	register struct _Tnode *this, *l;
	register char *domtab;
	char v;
	if (devalgen)
		printf ("evalgen group %d\n", g - group);
	domtab = g->gen.domtab;
	firstnode = g->gen.nodelist;
	lastnode = &firstnode[g->gen.nnodes - 3];
	tnode[0].str0 = tnode[1].str1 = g->gen.powstr;
	tnode[0].str1 = tnode[0].str1 = 0;
	toplist = &list[g->gen.powstr];
	v = 0;
	for (l = &list[0]; l <= toplist; l++) {
		l->forw = l->back = l;
		l->str0 = v++;
	}
	tnode[0].swlist = g->gen.vsslist;
	tnode[1].swlist = g->gen.vddlist;
				{				 		(&tnode[0])->back = ( toplist)->back;		( toplist)->back = (&tnode[0]);			(&tnode[0])->forw = ( toplist);			(&tnode[0])->back->forw = (&tnode[0]);	};
				{				 		(&tnode[1])->back = ( toplist)->back;		( toplist)->back = (&tnode[1]);			(&tnode[1])->forw = ( toplist);			(&tnode[1])->back->forw = (&tnode[1]);	};
	
	this = &tnode[2];
	for (n = firstnode; n <= lastnode; this++, n++) {
		this->swlist = n->swlist;
		this->val = n->val;
		v = n->size;
		if (n->flags & 0x08)
			v = g->gen.powstr;
		switch (n->val) {
		case 0:
			this->str0 = v;
			this->str1 = 0;
			break;
		case 1:
			this->str0 = 0;
			this->str1 = v;
			break;
		case 2:
			this->str0 = v;
			this->str1 = v;
			break;
		}
		l = &list[v];
					{				 		(this)->back = ( l)->back;		( l)->back = (this);			(this)->forw = ( l);			(this)->back->forw = (this);	};
	}
	pasttnode = this;
	
	anyxs = 0;
	if (devalgen)
		dumpstr ("before prop over 1's", domtab);
	prop_on (domtab);
	if (devalgen)
		dumpstr ("after prop over 1's", domtab);
	
	if (! anyxs) {
		this = &tnode[2];
		for (n = firstnode; n <= lastnode; n++, this++) {
			if ( (domtab[this->str0] >= ( this->str1))) {
				if (n->nextval != 0)
					assign (n, 0, 1);
			} else if ( (domtab[this->str1] >= ( this->str0))) {
				if (n->nextval != 1)
					assign (n, 1, 1);
			} else {
				if (n->nextval != 2)
					assign (n, 2, 1);
			}
		}
		return;
	}
	
	for (l = &list[0]; l <= toplist; l++)
		l->forw = l->back = l;
	for (this = tnode; this < pasttnode; this++) {
		this->xstr0 = this->str0;
		this->xstr1 = this->str1;
		if (this->xstr0 > this->xstr1)
			l = &list[this->xstr0];
		else
			l = &list[this->xstr1];
					{				 		(this)->back = ( l)->back;		( l)->back = (this);			(this)->forw = ( l);			(this)->back->forw = (this);	};
	}
	prop_xon (domtab);
	if (devalgen)
		dumpxstr ("after prop over X's", domtab);
	
	this = &tnode[2];
	for (n = firstnode; n <= lastnode; n++, this++) {
		if ( (domtab[this->str0] >= ( this->str1)) &&  (domtab[this->str0] >= ( this->xstr1))) {
			if (n->nextval != 0)
				assign (n, 0, 1);
		} else if ( (domtab[this->str1] >= ( this->str0)) &&  (domtab[this->str1] >= ( this->xstr0))) {
			if (n->nextval != 1)
				assign (n, 1, 1);
		} else {
			if (n->nextval != 2)
				assign (n, 2, 1);
		}
	}
}
T.i             599585674   170   4     100664  2786      `
int x;  float f;
struct {
     int  d;
     int  x;
} s, *sp;

main() {
     sp->x = x + f * x;
}
extern	struct	_iobuf {
	int	_cnt;
	char	*_ptr;
	char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
  struct _Point {
	int	x;
	int	y;
};
struct _Rectangle {
	  struct _Point	ll;
	  struct _Point	ur;
};
  struct _Object {
	  struct _Object	*link;
};
  struct _Pool {
	  struct _Object	*freelist;
	  struct _Object	*arealist;
	int	objsize;
};
  struct _Vpool {
	  struct _Object	*next;
	  struct _Object	*arealist;
	int	left;
	int	quantum;
};
	  struct _SEQFILE {
		int	hidden;
	};
extern char *myname;
extern int nullstring;
extern char *stringtab;
extern char *execname();
extern struct _iobuf *chkfopen();
extern   struct _Pool *newpool();
extern   struct _Vpool *newvpool();
extern char *maketemp();
extern char *permspace();
extern   struct _SEQFILE *seqopen();
extern char *nettoname();
extern char *strchr();
extern char *strrchr();
extern char debug;
typedef struct {
	float	x;
	float	y;
} FPT;
typedef struct {
	FPT	ll;
	FPT	ur;
} FRECT;
  struct _Traphd {
	int magicnumb;
	int nrows, ncols;
	int xdelta, ydelta;	
	struct _Rectangle bb;		
	struct _Rectangle rbb ;		
	char empty;
};
struct _Trapezoid {
	int net;
	int xmin, xmax, lby, lty, rby, rty;
};
struct _Traplabel {
	int net;
	int x, y;
	char label[4*sizeof(int)];
};
extern char intrflag;
extern   struct _Point center;
extern struct _Rectangle iuwind;
extern double supiu;
extern char debug;
extern short netcolor;
extern char debug;
int iuplu = 	1000;
short nlayers = 40;
short color [40];
char *layername [40];
char *colorfile;
char *fullname [40];
static   struct _Traphd *header;
static int **index;
static int identify (i, p)
  struct _Point p;
{
	register   struct _Traphd *h;
	register struct _iobuf *f;
	int col, row, pos, addr, stop;
	float w, x, slope;
	struct _Trapezoid t;
	h = &header[i];
	col = 	(((p.x) - ( h)->rbb.ll.x) / ( h)->xdelta);
	row = 	(((p.y) - ( h)->rbb.ll.y) / ( h)->ydelta);
	if (col < 0 || col >= h->ncols) return -1;
	if (row < 0 || row >= h->nrows) return -1;
	pos = col * h->nrows + row;
	addr = index[i][pos];
	stop = index[i][pos + 1];
	if (addr >= stop) return -1;
	f = (struct _iobuf *) forceopen(i);
	fseek (f, addr, 0);
	while (addr < stop) {
		if (intrflag) return -1;
		chkfread (&t, sizeof(struct _Trapezoid), 1, f);
		addr += sizeof(struct _Trapezoid);
		if (p.x < t.xmin || t.xmax < p.x) continue;
		x = p.x - t.xmin;
		w = t.xmax - t.xmin;
		
		  slope = (t.rby - t.lby) / w;
		  if (p.y < t.lby + x*slope) continue;
		
		  slope = (t.rty - t.lty) / w;
		  if (p.y > t.lty + x*slope) continue;
		
		return t.net;
	}
	return -1;
}
m()
{	register unsigned char a, b;
	a/=b;
}
U.i             599585711   170   4     100664  140       `
a()
{	register int c;
	register int *p, *q;
	while((*p++ = *q++));
	while((*p++ = *q++) == '\n');
	c = -(*p++ = *q++);
	c = -(p[c]=q[c]);
}
V.i             599585746   170   4     100664  99        `
struct x {
	int a,b;
};
ptmatch()
{
	register struct x *p;
	if( psize(p->b) != psize(p->b) )
		;
}

W.i             556379114   170   4     100664  205       `
unsigned long fds_bits[32];
int md;
clearit(){
	fds_bits[md/(unsigned)32] = ~(1<<(md%(unsigned)32));
}
int x[32], i;
a()
{
	x[f()] = ~(1 << f());
}
b()
{	register int *d, m;
	int r;
	*d = r&m | (~r)&*d;
}

X.i             556379115   170   4     100664  125       `
float x();
a()
{	float u;
	double v;
	u = x();
	v = x();
}
b()
{	int i, j[2], k[2];
	if(0 == (i? f(): g()))
		;
	b(i?j:k);
}

Y.i             558342812   170   4     100664  126       `
float a(); double i;
main()
{	i = a(a());
}
b() {
	unsigned c;
	if(!(unsigned char)++c)
		;
}
c()
{	short d;
	if(d > 0)
		;
}
Z.i             556379115   170   4     100664  404       `
struct text {
    int fd; 
    char file;
    short cnt,extra;
    unsigned char *pnt;
    unsigned char buf[1];
};
int blankline(tex)
struct text *tex;
{
    int c, i, n, found;
    n = found + ((i)?*tex->pnt++:get());
    for (;;) {
       c= (tex->cnt>0?tex->pnt[0]:peek(0,tex));
       if (c == ' ' || c == '\n' || c == '\t')  ((0<tex->cnt--)?*tex->pnt++:get(tex));
       else return(1);
       }
}
a.i             600039326   170   4     100664  21656     `
/* machdep.c */
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	int	daddr_t;
typedef	char *	caddr_t;
typedef	u_short ino_t;
typedef	int	swblk_t;
typedef	int	size_t;
typedef	int	time_t;
typedef	int	label_t[14];
typedef	short	dev_t;
typedef	int	off_t;
typedef long	portid_t;
typedef struct	fd_set { int fds_bits[1]; } fd_set;
int	hz;			
int	timezone;		
int	dstflag;		
char	canonb[256		];	
extern char	version[];		
int	lbolt;			
time_t	time;			
time_t	bootime;		
long	trannum;		
int	hand;			
int	nblkdev;
int	nchrdev;
int	nstream;		
int	nswdev;			
int	mpid;			
char	runin;			
char	runout;			
int	runrun;			
char	kmapwnt;		
char	curpri;			
int	maxmem;			
int	physmem;		
int	nswap;			
int	updlock;		
daddr_t	rablock;		
extern	int intstack[];		
dev_t	rootdev;		
dev_t	dumpdev;		
long	dumplo;			
dev_t	swapdev;		
dev_t	argdev;			
dev_t	pipedev;		
extern	int icode[];		
extern	int szicode;		
dev_t	getmdev();
daddr_t	bmap();
caddr_t	calloc();
unsigned max();
unsigned min();
int	memall();
int	uchar(), schar();
int	vmemall();
char	*wmemall();
swblk_t	vtod();
extern struct sysent
{
	int	sy_narg;		
	int	(*sy_call)();		
} sysent[];
extern char	vmmap[];		
int	umbabeg,umbaend;	
int	noproc;			
extern	int catcher[256];
char	*panicstr;
int	wantin;
int	boothowto;		
struct	direct
{
	ino_t	d_ino;
	char	d_name[14		];
};
struct pcb
{
	int	pcb_ksp; 	
	int	pcb_esp; 	
	int	pcb_ssp; 	
	int	pcb_usp; 	
	int	pcb_r0; 
	int	pcb_r1; 
	int	pcb_r2; 
	int	pcb_r3; 
	int	pcb_r4; 
	int	pcb_r5; 
	int	pcb_r6; 
	int	pcb_r7; 
	int	pcb_r8; 
	int	pcb_r9; 
	int	pcb_r10; 
	int	pcb_r11; 
	int	pcb_r12; 
	int	pcb_r13; 
	int	pcb_pc; 	
	int	pcb_psl; 	
	struct  pte *pcb_p0br; 	
	int	pcb_p0lr; 	
	struct  pte *pcb_p1br; 	
	int	pcb_p1lr; 	
	int	pcb_szpt; 	
	int	pcb_cmap2;
	int	*pcb_sswap;
	int	pcb_sigc[3];
};
struct	dmap
{
	swblk_t	dm_size;	
	swblk_t	dm_alloc;	
	swblk_t	dm_map[		32	];	
};
struct	dmap zdmap;
struct	dblock
{
	swblk_t	db_base;	
	swblk_t	db_size;	
};
struct vtimes {
	int	vm_utime;		
	int	vm_stime;		
	
	unsigned vm_idsrss;		
	unsigned vm_ixrss;		
	int	vm_maxrss;		
	int	vm_majflt;		
	int	vm_minflt;		
	int	vm_nswap;		
	int	vm_inblk;		
	int	vm_oublk;		
};
struct vtimes zvms;		
 
 
struct	user
{
	struct	pcb u_pcb;
	int	u_arg[5];		
	label_t	u_qsav;			
	char	u_segflg;		
	char	u_error;		
	short	u_uid;			
	short	u_gid;			
	short	u_ruid;			
	short	u_rgid;			
	struct	proc *u_procp;		
	int	*u_ap;			
	union {				
		struct	{
			int	R_val1;
			int	R_val2;
		} u_rv;
		off_t	r_off;
		time_t	r_time;
	} u_r;
	caddr_t	u_base;			
	unsigned int u_count;		
	off_t	u_offset;		
	struct	inode *u_cdir;		
	struct	inode *u_rdir;		
	char	u_dbuf[14		];		
	caddr_t	u_dirp;			
	struct	direct u_dent;		
	struct	inode *u_pdir;		
	struct	file *u_ofile[20		];	
	char	u_pofile[20		];	
	label_t u_ssav;			
	int	(*u_signal[32])();	
	int	u_code;			
	int	*u_ar0;			
	struct uprof {			
		short	*pr_base;	
		unsigned pr_size;	
		unsigned pr_off;	
		unsigned pr_scale;	
	} u_prof;
	char	u_eosys;		
	char	u_sep;			
	dev_t	u_ttydev;		
	ino_t	u_ttyino;
	union {
	   struct {			
		int	Ux_mag;		
		unsigned Ux_tsize;	
		unsigned Ux_dsize;	
		unsigned Ux_bsize;	
		unsigned Ux_ssize;	
		unsigned Ux_entloc;	
		unsigned Ux_unused;
		unsigned Ux_relflg;
	   } Ux_A;
	   char ux_shell[32];	
	} u_exdata;
	char	u_comm[14		];
	time_t	u_start;
	char	u_acflag;
	short	u_fpflag;		
	short	u_cmask;		
	size_t	u_tsize;		
	size_t	u_dsize;		
	size_t	u_ssize;		
	struct	vtimes u_vm;		
	struct	vtimes u_cvm;		
	struct	dmap u_dmap;		
	struct	dmap u_smap;		
	struct	dmap u_cdmap, u_csmap;	
	time_t	u_outime;		
	size_t	u_odsize, u_ossize;	
	size_t	u_vrpages[20		];	
	int	u_limit[8];		
	int	u_stack[1];
					
};
extern	struct user u;
extern	struct user swaputl;
extern	struct user forkutl;
extern	struct user xswaputl;
extern	struct user xswap2utl;
extern	struct user pushutl;
extern	struct user vfutl;
extern	struct user prusrutl;
struct map {
	struct	mapent *m_limit;	
	char	*m_name;		
};
struct mapent
{
	int	m_size;		
	int	m_addr;		
};
struct	map *swapmap;
int	nswapmap;
struct	map *argmap;
struct	map *kernelmap;
	
struct pte
{
unsigned int	pg_pfnum:21,		
		:2,
		pg_vreadm:1,		
		pg_swapm:1,		
		pg_fod:1,		
		pg_m:1,			
		pg_prot:4,		
		pg_v:1;			
};
struct hpte
{
unsigned int	pg_pfnum:21,
		:2,
		pg_high:9;		
};
struct fpte
{
unsigned int	pg_blkno:20,		
		pg_fileno:5,		
		pg_fod:1,		
		:1,
		pg_prot:4,
		pg_v:1;
};
struct	pte *vtopte();
extern	struct pte Sysmap[];
extern	struct pte Usrptmap[];
extern	struct pte usrpt[];
extern	struct pte Swapmap[];
extern	struct pte Forkmap[];
extern	struct pte Xswapmap[];
extern	struct pte Xswap2map[];
extern	struct pte Pushmap[];
extern	struct pte Vfmap[];
extern	struct pte mmap[];
extern	struct pte msgbufmap[];
extern	struct pte camap[];
extern	struct pte Nexmap[][16];
extern	struct pte Prusrmap[];
					
					
int	klseql;
int	klsdist;
int	klin;
int	kltxt;
int	klout;
struct vmmeter
{
	unsigned v_swtch;	
	unsigned v_trap;	
	unsigned v_syscall;	
	unsigned v_intr;	
	unsigned v_pdma;	
	unsigned v_pswpin;	
	unsigned v_pswpout;	
	unsigned v_pgin;	
	unsigned v_pgout;	
	unsigned v_pgpgin;	
	unsigned v_pgpgout;	
	unsigned v_intrans;	
	unsigned v_pgrec;	
	unsigned v_xsfrec;	
	unsigned v_xifrec;	
	unsigned v_exfod;	
	unsigned v_zfod;	
	unsigned v_vrfod;	
	unsigned v_nexfod;	
	unsigned v_nzfod;	
	unsigned v_nvrfod;	
	unsigned v_pgfrec;	
	unsigned v_faults;	
	unsigned v_scan;	
	unsigned v_rev;		
	unsigned v_seqfree;	
	unsigned v_dfree;	
	unsigned v_swpin;	
	unsigned v_swpout;	
};
struct	vmmeter cnt, rate, sum;
struct vmtotal
{
	short	t_rq;		
	short	t_dw;		
	short	t_pw;		
	short	t_sl;		
	short	t_sw;		
	int	t_vm;		
	int	t_avm;		
	short	t_rm;		
	short	t_arm;		
	int	t_vmtxt;	
	int	t_avmtxt;	
	short	t_rmtxt;	
	short	t_armtxt;	
	short	t_free;		
};
struct	vmtotal total;
int	freemem;		
int	avefree;		
int	avefree30;		
int	deficit;		
int	nscan;			
int	multprog;		
int	desscan;		
int	maxpgio;		
int	maxslp;			
int	lotsfree;		
int	minfree;		
int	desfree;		
int	saferss;		
struct	forkstat
{
	int	cntfork;
	int	cntvfork;
	int	sizfork;
	int	sizvfork;
};
struct	forkstat forkstat;
struct	swptstat
{
	int	pteasy;		
	int	ptexpand;	
	int	ptshrink;	
	int	ptpack;		
};
struct	swptstat swptstat;
struct	proc
{
	struct	proc *p_link;	
	struct	proc *p_rlink;	
	struct	pte *p_addr;	
	char	p_usrpri;	
	char	p_pri;		
	char	p_cpu;		
	char	p_stat;
	char	p_time;		
	char	p_nice;		
	char	p_slptime;	
	char	p_cursig;
	long	p_sig;		
	long	p_siga0;	
	long	p_siga1;	
	int	p_flag;
	short	p_uid;		
	short	p_pgrp;		
	short	p_pid;		
	short	p_ppid;		
	short	p_poip;		
	short	p_szpt;		
	size_t	p_tsize;	
	size_t	p_dsize;	
	size_t	p_ssize;	
	size_t 	p_rssize; 	
	size_t	p_maxrss;	
	size_t	p_swrss;	
	swblk_t	p_swaddr;	
	caddr_t p_wchan;	
	struct	text *p_textp;	
	u_short	p_clktim;	
	u_short	p_tsleep;	
	struct	pte *p_p0br;	
	struct	proc *p_xlink;	
	short	p_cpticks;	
	float	p_pctcpu;	
	short	p_ndx;		
	short	p_idhash;	
	struct	proc *p_pptr;	
	struct	inode *p_trace;	
};
short	pidhash[	63];
struct	proc *pfind();
struct	proc *proc, *procNPROC;	
int	nproc;
struct	prochd {
	struct	proc *ph_link;	
	struct	proc *ph_rlink;
} qs[32		];
int	whichqs;		
struct	xproc
{
	struct	proc *xp_link;
	struct	proc *xp_rlink;
	struct	pte *xp_addr;
	char	xp_usrpri;
	char	xp_pri;		
	char	xp_cpu;		
	char	xp_stat;
	char	xp_time;	
	char	xp_nice;	
	char	xp_slptime;
	char	p_cursig;
	int	xp_sig;		
	int	xp_siga0;
	int	xp_siga1;
	int	xp_flag;
	short	xp_uid;		
	short	xp_pgrp;	
	short	xp_pid;		
	short	xp_ppid;	
	short	xp_xstat;	
	struct	vtimes xp_vm;
};
struct bufhd
{
	long	b_flags;		
	struct	buf *b_forw, *b_back;	
};
struct buf
{
	long	b_flags;		
	struct	buf *b_forw, *b_back;	
	struct	buf *av_forw, *av_back;	
	long	b_bcount;		
	short	b_error;		
	dev_t	b_dev;			
	union {
	    caddr_t b_addr;		
	    int	*b_words;		
	    struct filsys *b_filsys;	
	    struct dinode *b_dino;	
	    daddr_t *b_daddr;		
	} b_un;
	daddr_t	b_blkno;		
	long	b_resid;		
	struct  proc *b_proc;		
};
struct	buf *buf;		
char	*buffers;
int	nbuf;
struct	buf *swbuf;		
int	nswbuf;
short	*swsize;
int	*swpf;
struct	buf bfreelist[	3		];	
struct	buf bswlist;		
struct	buf *bclnlist;		
struct	buf *alloc();
struct	buf *baddr();
struct	buf *getblk();
struct	buf *geteblk();
struct	buf *bread();
struct	buf *breada();
unsigned minphys();
struct	uba_hd {
	struct	uba_regs *uh_uba;	
	struct	uba_regs *uh_physuba;	
	int	(**uh_vec)();		
	struct	uba_device *uh_actf;	
	struct	uba_device *uh_actl;	
	short	uh_mrwant;		
	short	uh_bdpwant;		
	int	uh_bdpfree;		
	int	uh_hangcnt;		
	int	uh_zvcnt;		
	int	uh_errcnt;		
	int	uh_lastiv;		
	short	uh_users;		
	short	uh_xclu;		
	struct	map *uh_map;		
};
struct uba_ctlr {
	struct	uba_driver *um_driver;
	short	um_ctlr;	
	short	um_ubanum;	
	short	um_alive;	
	int	(**um_intr)();	
	caddr_t	um_addr;	
	struct	uba_hd *um_hd;
	int	um_cmd;		
	int	um_ubinfo;	
	struct	buf um_tab;	
};
struct uba_device {
	struct	uba_driver *ui_driver;
	short	ui_unit;	
	short	ui_ctlr;	
	short	ui_ubanum;	
	short	ui_slave;	
	int	(**ui_intr)();	
	caddr_t	ui_addr;	
	short	ui_dk;		
	int	ui_flags;	
	short	ui_alive;	
	short	ui_type;	
	caddr_t	ui_physaddr;	
	struct	uba_device *ui_forw;
	struct	uba_ctlr *ui_mi;
	struct	uba_hd *ui_hd;
};
struct uba_driver {
	int	(*ud_probe)();		
	int	(*ud_slave)();		
	int	(*ud_attach)();		
	int	(*ud_dgo)();		
	u_short	*ud_addr;		
	char	*ud_dname;		
	struct	uba_device **ud_dinfo;	
	char	*ud_mname;		
	struct	uba_ctlr **ud_minfo;	
	short	ud_xclu;		
};
int	numuba;					
extern struct	uba_hd uba_hd[];
extern	struct	uba_ctlr ubminit[];
extern	struct	uba_device ubdinit[];
extern	struct pte UMEMmap[][16];	
extern	char umem[][16*	512];		
extern	int (*UNIvec[])();			
struct uba_regs
{
	int	uba_cnfgr;		
	int	uba_cr;			
	int	uba_sr;			
	int	uba_dcr;		
	int	uba_fmer;		
	int	uba_fubar;		
	int	pad1[2];
	int	uba_brsvr[4];
	int	uba_brrvr[4];		
	int	uba_dpr[16];		
	int	pad2[480];
	struct	pte uba_map[496];	
	int	pad3[16];		
};
 
 
struct bdevsw
{
	int	(*d_open)();
	int	(*d_close)();
	int	(*d_strategy)();
	int	(*d_dump)();
	int	d_flags;
};
extern struct	bdevsw bdevsw[];
extern struct cdevsw
{
	int	(*d_open)();
	int	(*d_close)();
	int	(*d_read)();
	int	(*d_write)();
	int	(*d_ioctl)();
	int	(*d_reset)();
	struct	streamtab *qinfo;
};
extern struct cdevsw cdevsw[];
struct fstypsw {
	int		(*t_put)();
	struct inode	*(*t_get)();
	int		(*t_free)();
	int		(*t_updat)();
	int		(*t_read)();
	int		(*t_write)();
	int		(*t_trunc)();
	int		(*t_stat)();
	int		(*t_nami)();
	int		(*t_mount)();
	int		(*t_ioctl)();
};
extern struct fstypsw fstypsw[];
extern nfstyp;
extern	struct streamtab {
	struct	qinit	*rdinit;
	struct	qinit	*wrinit;
} *streamtab[];
struct swdevt
{
	dev_t	sw_dev;
	int	sw_freed;
};
extern struct	swdevt swdevt[];
struct	mcr {
	int	mc_reg[3];
};
int	nmcr;
struct	mcr *mcraddr[	1];
union cpusid {
	int	cpusid;
	struct cpuany {
		u_int	:24,
			cp_type:8;
	} cpuany;
	struct cpu780 {
		u_int	cp_sno:12,		
			cp_plant:3,		
			cp_eco:9,		
			cp_type:8;		
	} cpu780;
	struct cpu750 {
		u_int	cp_hrev:8,		
			cp_urev:8,		
			:8,
			cp_type:8;		
	} cpu750;
	
};
struct	percpu {
	short	pc_cputype;		
	short	pc_nnexus;		
	struct	nexus *pc_nexbase;	
	caddr_t	*pc_umaddr;		
	short	pc_nubabdp;		
	short	pc_haveubasr;		
	short	*pc_nextype;		
};
int	cpu;
extern struct	percpu percpu[];
struct	inode
{
	short	i_flag;
	u_char	i_count;	
	char	i_fstyp;	
	dev_t	i_dev;		
	long	i_number;	
	unsigned short i_mode;
	short	i_nlink;	
	short	i_uid;		
	short	i_gid;		
	off_t	i_size;		
	struct	stdata *i_sptr;	
	union {
		struct {
			daddr_t	I_addr[13];	
			daddr_t	I_lastr;	
		} i_f;
		struct {
			daddr_t	I_rdev;		
			long	I_key;		
		} i_d;
		struct {
			long I_tag;
			struct inode *I_cip;	
		} i_a;		
		struct {
			struct proc *I_proc;	
			int	    I_sigmask;	
		} i_p;
	} i_un;
	short	i_hlink;	
};
struct	inode *inode, *inodeNINODE;
int	ninode;
struct	inode *rootdir;		
struct	inode *ialloc();
struct	inode *ifind();
struct	inode *iget();
struct	inode *owner();
struct	inode *maknode();
struct	inode *namei();
struct argnamei {	
	short flag;	
	ino_t ino;	
	dev_t idev;
	short mode;	
};
struct nx {	
	struct inode *dp;
	char *cp;
	struct buf *nbp;
	int nlink;
};
struct	file
{
	short	f_flag;
	short	f_count;		
	struct inode *f_inode;		
	off_t	f_offset;		
};
struct	file *file, *fileNFILE;	
int	nfile;
struct	file *getf();
struct	file *falloc();
struct text
{
	swblk_t	x_daddr[12		];	
	swblk_t	x_ptdaddr;	
	size_t	x_size;		
	struct proc *x_caddr;	
	struct inode *x_iptr;	
	short	x_rssize;
	short	x_swrss;
	char	x_count;	
	char	x_ccount;	
	char	x_flag;		
	char	x_slptime;
	short	x_poip;		
};
struct	text *text, *textNTEXT;
int	ntext;
struct	callout {
	int	c_time;		
	caddr_t	c_arg;		
	int	(*c_func)();	
	struct	callout *c_next;
};
struct	callout *callfree, *callout, calltodo;
int	ncallout;
struct cmap
{
unsigned int 	c_next:13,	
		c_prev:13,	
		c_lock:1,	
		c_want:1,	
		c_page:16,	
		c_hlink:13,	
		c_intrans:1,	
		c_free:1,	
		c_gone:1,	
		c_type:2,	
		c_blkno:20,	
		c_ndx:10,	
		c_mdev:6;	
};
struct	cmap *cmap;
struct	cmap *ecmap;
int	ncmap;
struct	cmap *mfind();
int	firstfree, maxfree;
int	ecmx;			
short	cmhash[512		];
struct frame {
	int	fr_handler;
	u_int	fr_psw:16,		
		fr_mask:12,		
		:1,
		fr_s:1,			
		fr_spa:2;		
	int	fr_savap;		
	int	fr_savfp;		
	int	fr_savpc;		
};
struct rpb {
	struct	rpb *rp_selfref;	
	int	(*rp_dumprout)();	
	long	rp_checksum;		
	long	rp_flag;		
};
extern	struct rpb rpb;
int	icode[] =
{
	0x9f19af9f,	
	0x02dd09af,	
	0xbc5c5ed0,	
	0x2ffe110b,	
	0x2f637465,	
	0x74696e69,	
	0x00000000,	
	0x00000014,	
	0x00000000,	
};
int	szicode = sizeof(icode);
 
int	nbuf = 0;
int	nswbuf = 0;
startup(firstaddr)
	int firstaddr;
{
	register int unixsize;
	register unsigned i;
	register struct pte *pte;
	register caddr_t v;
	
	maxmem -= 2;
	pte = msgbufmap;
	for (i = 0; i < 2; i++)
		*(int *)pte++ = 	0x80000000 | 	0x10000000 | (maxmem + i);
	mtpr(0x39		, 1);
	
	printf(version);
	
	
	if (nbuf == 0) {
		nbuf = (32 * physmem) / 	((((unsigned)(1024*1024)+511)>>9));
		if (nbuf < 32)
			nbuf = 32;
	}
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	
		if (nswbuf > 256)
			nswbuf = 256;		
	}
	printf("real mem = %d nbuf = %d nswbuf = %d\n", 	((maxmem)<<9),
		nbuf, nswbuf);
	
	v = (caddr_t)(0x80000000 | (firstaddr * 	512));
	 	    (buffers) = ( char *)(v); (v) = (caddr_t)((buffers)+( 	4096*nbuf));
	 	    (buf) = ( struct buf *)(v); (v) = (caddr_t)((buf)+( nbuf));
	 	    (swbuf) = ( struct buf *)(v); (v) = (caddr_t)((swbuf)+( nswbuf));
	 	    (swsize) = ( short *)(v); (v) = (caddr_t)((swsize)+( nswbuf));	
	 	    (swpf) = ( int *)(v); (v) = (caddr_t)((swpf)+( nswbuf));
	 	    (inode) = ( struct inode *)(v); (v) = (caddr_t)(( inodeNINODE) = ((inode)+( ninode)));
	 	    (file) = ( struct file *)(v); (v) = (caddr_t)(( fileNFILE) = ((file)+( nfile)));
	 	    (proc) = ( struct proc *)(v); (v) = (caddr_t)(( procNPROC) = ((proc)+( nproc)));
	 	    (text) = ( struct text *)(v); (v) = (caddr_t)(( textNTEXT) = ((text)+( ntext)));
	 	    (callout) = ( struct callout *)(v); (v) = (caddr_t)((callout)+( ncallout));
	 	    (swapmap) = ( struct map *)(v); (v) = (caddr_t)((swapmap)+( nswapmap = nproc * 2));
	 	    (argmap) = ( struct map *)(v); (v) = (caddr_t)((argmap)+( 16));
	 	    (kernelmap) = ( struct map *)(v); (v) = (caddr_t)((kernelmap)+( nproc));
	
	ncmap = (physmem*	512 - ((int)v &~ 0x80000000)) /
		    (	512*2 + sizeof (struct cmap));
	 	    (cmap) = ( struct cmap *)(v); (v) = (caddr_t)(( ecmap) = ((cmap)+( ncmap)));
	if ((((int)(ecmap+1))&~0x80000000) > (32*	(	512/(sizeof (struct pte))))*	512)
		panic("sys pt too small");
	
	unixsize = 	((((unsigned)((int)(ecmap+1) &~ 0x80000000)+511)>>9));
	if (unixsize >= physmem - 8*8		)
		panic("no memory");
	pte = &Sysmap[firstaddr];
	for (i = firstaddr; i < unixsize; i++) {
		*(int *)(&Sysmap[i]) = 	0x80000000 | 	0x10000000 | i;
		clearseg(i);
	}
	mtpr(0x39		, 1);
	
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	
	meminit(unixsize, maxmem);
	maxmem = freemem;
	printf("avail mem = %d\n", 	((maxmem)<<9));
	rminit(kernelmap, 	(8*	(	512/(sizeof (struct pte)))), 1, "usrpt", nproc);
	
	configure();
	
	tocons(0xf03		);
	tocons(0xf04		);
}
sysphys()
{
	if(!suser())
		return;
	u.u_error = 22;
}
clkinit(base)
	time_t base;
{
	register unsigned todr = mfpr(0x1b		);
	long deltat;
	int year = 	1970;
	if (base < 5*	((unsigned)(365*	((unsigned)(24*60*60))		))	) {
		printf("WARNING: preposterous time in file system");
		time = 6*	((unsigned)(365*	((unsigned)(24*60*60))		))	 + 186*	((unsigned)(24*60*60))		 + 	((unsigned)(24*60*60))		/2;
		clkset();
		goto check;
	}
	
	if (todr < ((unsigned)(1<<28))) {
		printf("WARNING: todr too small");
		time = base;
		
		clkset();
		goto check;
	}
	
	for (time = (todr-((unsigned)(1<<28)))/100; time < base-	((unsigned)(365*	((unsigned)(24*60*60))		))	/2; time += 	((unsigned)(365*	((unsigned)(24*60*60))		))	) {
		if (	((year)%4==0)	)
			time += 	((unsigned)(24*60*60))		;
		year++;
	}
	
	deltat = time - base;
	if (deltat < 0)
		deltat = -deltat;
	if (deltat < 2*	((unsigned)(24*60*60))		)
		return;
	printf("WARNING: clock %s %d days",
	    time < base ? "lost" : "gained", deltat / 	((unsigned)(24*60*60))		);
check:
	printf(" -- CHECK AND RESET THE DATE!\n");
}
clkset()
{
	int year = 	1970;
	unsigned secyr;
	unsigned yrtime = time;
	
	for (;;) {
		secyr = 	((unsigned)(365*	((unsigned)(24*60*60))		))	;
		if (	((year)%4==0)	)
			secyr += 	((unsigned)(24*60*60))		;
		if (yrtime < secyr)
			break;
		yrtime -= secyr;
		year++;
	}
	mtpr(0x1b		, ((unsigned)(1<<28)) + yrtime*100);
}
sendsig(p, n)
	int (*p)();
{
	register int *usp, *regs;
	regs = u.u_ar0;
	usp = (int *)regs[(-5)];
	usp -= 5;
	if ((int)usp <= (0x80000000-8		*	512) - 	((u.u_ssize)<<9))
		(void) grow((unsigned)usp);
	;			
	asm("probew $3,$20,(r11)");
	asm("beql bad");
	*usp++ = n;
	if (n == 4	 || n == 8	) {
		*usp++ = u.u_code;
		u.u_code = 0;
	} else
		*usp++ = 0;
	*usp++ = (int)p;
	*usp++ = regs[(-2)];
	*usp++ = regs[(-1)];
	regs[(-5)] = (int)(usp - 5);
	regs[(-1)] &= ~(	0x80000000	|	0x08000000	);
	regs[(-2)] = (int)u.u_pcb.pcb_sigc;
	return;
asm("bad:");
bad:
	
	u.u_signal[4	] = 	(int (*)())0;
	u.u_procp->p_siga0 &= ~(1<<(4	-1));
	u.u_procp->p_siga1 &= ~(1<<(4	-1));
	psignal(u.u_procp, 4	);
}
dorti()
{
	struct frame frame;
	register int sp;
	register int reg, mask;
	extern int ipcreg[];
	(void) copyin((caddr_t)u.u_ar0[(-20)], (caddr_t)&frame, sizeof (frame));
	sp = u.u_ar0[(-20)] + sizeof (frame);
	u.u_ar0[(-2)] = frame.fr_savpc;
	u.u_ar0[(-20)] = frame.fr_savfp;
	u.u_ar0[(-21)] = frame.fr_savap;
	mask = frame.fr_mask;
	for (reg = 0; reg <= 11; reg++) {
		if (mask&1) {
			u.u_ar0[ipcreg[reg]] = fuword((caddr_t)sp);
			sp += 4;
		}
		mask >>= 1;
	}
	sp += frame.fr_spa;
	u.u_ar0[(-1)] = (u.u_ar0[(-1)] & 0xffff0000) | frame.fr_psw;
	if (frame.fr_s)
		sp += 4 + 4 * (fuword((caddr_t)sp) & 0xff);
	
	u.u_ar0[(-2)] = fuword((caddr_t)sp);
	sp += 4;
	u.u_ar0[(-1)] = fuword((caddr_t)sp);
	sp += 4;
	u.u_ar0[(-1)] |= (0x00c00000	|0x03000000	);
	u.u_ar0[(-1)] &= ~(	0x04000000	|	0x001f0000	|	0x3020ff00	);
	u.u_ar0[(-5)] = (int)sp;
}
int	memintvl = (60*60*30)		;
memenable()
{
	register struct mcr *mcr;
	register int m;
	for (m = 0; m < nmcr; m++) {
		mcr = mcraddr[m];
		switch (cpu) {
		}
	}
	if (memintvl > 0)
		timeout(memenable, (caddr_t)0, memintvl);
}
memerr()
{
	register struct mcr *mcr;
	register int m;
	for (m = 0; m < nmcr; m++) {
		mcr = mcraddr[m];
		switch (cpu) {
		}
	}
}
tbiscl(v)
	unsigned v;
{
	register caddr_t addr;		
	register int i;
	asm(".set TBIS,58");
	addr = 		((caddr_t)((v) << 	9		));
	for (i = 0; i < 2; i++) {
		asm("mtpr r11,$TBIS");
		addr += 	512;
	}
}
  
int	waittime = -1;
boot(paniced, arghowto)
	int paniced, arghowto;
{
	register int howto;		
	register int devtype;		
	howto = arghowto;
	if ((howto&4	)==0 && waittime < 0 && bfreelist[0].b_forw) {
		waittime = 0;
		update();
		printf("syncing disks... ");
		while (++waittime <= 5)
			sleep((caddr_t)&lbolt, 25);
		printf("done\n");
	}
	splx(0x1f);			
	devtype = 	((int)(((unsigned)(rootdev)>>8)&0377));
	if (howto&	8	) {
		printf("halting (in tight loop); hit\n\t^P\n\tHALT\n\n");
		mtpr(0x12		, 0x1f);
		for (;;)
			;
	} else {
		if (paniced == 0	)
			doadump();
		tocons(0xf02		);
	}
	for (;;)
		asm("halt");
	
}
tocons(c)
{
	while ((mfpr(0x22		)&0x00000080	) == 0)
		continue;
	mtpr(0x23		, c);
}
dumpsys()
{
	rpb.rp_flag = 1;
	if ((	((int)((dumpdev)&0377))&07) != 1)
		return;
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
	printf("dump ");
	switch ((*bdevsw[	((int)(((unsigned)(dumpdev)>>8)&0377))].d_dump)(dumpdev)) {
	case 6:
		printf("device bad\n");
		break;
	case 14:
		printf("device not ready\n");
		break;
	case 22:
		printf("area improper\n");
		break;
	case 5:
		printf("i/o error");
		break;
	default:
		printf("succeeded");
		break;
	}
}
struct mc780frame {
	int	mc8_bcnt;		
	int	mc8_summary;		
	int	mc8_cpues;		
	int	mc8_upc;		
	int	mc8_vaviba;		
	int	mc8_dreg;		
	int	mc8_tber0;		
	int	mc8_tber1;		
	int	mc8_timo;		
	int	mc8_parity;		
	int	mc8_sbier;		
	int	mc8_pc;			
	int	mc8_psl;		
};
struct mc750frame {
	int	mc5_bcnt;		
	int	mc5_summary;		
	int	mc5_va;			
	int	mc5_errpc;		
	int	mc5_mdr;
	int	mc5_svmode;		
	int	mc5_rdtimo;		
	int	mc5_tbgpar;		
	int	mc5_cacherr;		
	int	mc5_buserr;		
	int	mc5_mcesr;		
	int	mc5_pc;			
	int	mc5_psl;		
};
struct mc7ZZframe {
	int	mc3_bcnt;		
	int	mc3_summary;		
	int	mc3_parm[2];		
	int	mc3_pc;			
	int	mc3_psl;		
};
machinecheck(cmcf)
	caddr_t cmcf;
{
	register u_int type = ((struct mc780frame *)cmcf)->mc8_summary;
	printf("machine check %x: ", type);
	switch (cpu) {
	}
	switch (cpu) {
	}
	panic("mchk");
}
b.i             599586222   170   4     100664  8912      `
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	int	daddr_t;
typedef	char *	caddr_t;
typedef	u_short ino_t;
typedef	int	swblk_t;
typedef	int	size_t;
typedef	int	time_t;
typedef	int	label_t[14];
typedef	short	dev_t;
typedef	int	off_t;
typedef long	portid_t;
typedef struct	fd_set { int fds_bits[1]; } fd_set;
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
extern char	_ctype[];
typedef int	(*SIG_TYP)();
SIG_TYP signal();
struct	dir
{
	ino_t	d_ino;
	char	d_name[14];
};
struct vtimes {
	int	vm_utime;		
	int	vm_stime;		
	
	unsigned vm_idsrss;		
	unsigned vm_ixrss;		
	int	vm_maxrss;		
	int	vm_majflt;		
	int	vm_minflt;		
	int	vm_nswap;		
	int	vm_inblk;		
	int	vm_oublk;		
};
struct timeb
{
	time_t	time;
	unsigned short millitm;
	short	timezone;
	short	dstflag;
};
struct vtimes newv, oldv;
struct timeb newt, oldt;
char	*cpp = "/lib/cpp";
char	*ccom = "/usr/pjw/comp/vcc/comp.sv";
char	*c2 = "/lib/c2";
char	*as = "/bin/as";
char	*ld = "/bin/ld";
char	*crt0 = "/lib/crt0.o";
char	tmp0[30];		
char	*tmp1, *tmp2, *tmp3, *tmp4, *tmp5;
char	*outfile;
char	*savestr(), *strspl(), *setsuf();
int	idexit();
char	**av, **clist, **llist, **plist;
int	cflag, eflag, gflag, oflag, pflag, sflag, wflag, Rflag, exflag, proflag;
int	vflag; 
char	*dflag;
int	exfail;
char	*chpass;
char	*npassname;
extern	int	optind;
extern	int	opterr;
extern	char	*optarg;
extern	int	optopt;
int	nc, nl, np, nxo, na;
main(argc, argv)
	char **argv;
{
	char *t;
	char *assource;
	int i, j, c;
	
	av = (char **)calloc(argc+10, sizeof (char **));
	clist = (char **)calloc(argc, sizeof (char **));
	llist = (char **)calloc(argc, sizeof (char **));
	plist = (char **)calloc(argc, sizeof (char **));
	opterr = 0;
	while (optind<argc) switch (c = getopt(argc, argv, "vsSo:ROPgwEpPcD:I:U:C:t:B:l:d:")) {
	case 'v':
		vflag++;
		continue;
	case 'S':
		sflag++;
		cflag++;
		continue;
	case 'l':
		llist[nl++] = strspl("-l", optarg);
		continue;
	case 'o':
		outfile = optarg;
		switch (getsuf(outfile)) {
		case 'c':
		case 'o':
			error("-o would overwrite %s", outfile);
			exit(8);
		}
		continue;
	case 'R':
		Rflag++;
		continue;
	case 'O':
		oflag++;
		continue;
	case 'p':
		proflag++;
		continue;
	case 'g':
		gflag++;
		continue;
	case 'w':
		wflag++;
		continue;
	case 'E':
		exflag++;
	case 'P':
		pflag++;
		t = strspl("-", "x");
		t[1] = optopt;
		plist[np++] = t;
	case 'c':
		cflag++;
		continue;
	case 'D':
	case 'I':
	case 'U':
	case 'C':
		plist[np] = strspl("-X", optarg);
		plist[np++][1] = c;
		continue;
	case 't':
		if (chpass)
			error("-t overwrites earlier option", 0);
		chpass = optarg;
		if (chpass[0]==0)
			chpass = "012p";
		continue;
	case 'B':
		if (npassname)
			error("-B overwrites earlier option", 0);
		npassname = optarg;
		if (npassname[0]==0)
			npassname = "/usr/c/o";
		continue;
	case 'd':
		dflag = strspl("-d", optarg);
		continue;
	case '?':
	case 's':
		t = strspl("-", "x");
		t[1] = optopt;
		llist[nl++] = t;
		continue;
	case (-1):
		t = argv[optind];
		optind++;
		c = getsuf(t);
		if (c=='c' || c=='s' || c=='i' || exflag) {
			clist[nc++] = t;
			t = setsuf(t, 'o');
		}
		if (nodup(llist, t)) {
			llist[nl++] = t;
			if (getsuf(t)=='o')
				nxo++;
		}
	}
	if (gflag) {
		if (oflag)
			fprintf((&_iob[2]), "cc: warning: -g disables -O\n");
		oflag = 0;
	}
	if (npassname && chpass ==0)
		chpass = "012p";
	if (chpass && npassname==0)
		npassname = "/usr/new";
	if (chpass)
	for (t=chpass; *t; t++) {
		switch (*t) {
		case '0':
			ccom = strspl(npassname, "ccom");
			continue;
		case '2':
			c2 = strspl(npassname, "c2");
			continue;
		case 'p':
			cpp = strspl(npassname, "cpp");
			continue;
		}
	}
	if (proflag)
		crt0 = "/lib/mcrt0.o";
	if (nc==0)
		goto nocom;
	if (signal(2	, 	(int (*)())1) != 	(int (*)())1)
		(void)signal(2	, idexit);
	if (signal(15	, 	(int (*)())1) != 	(int (*)())1)
		(void)signal(15	, idexit);
	if (pflag==0)
		sprintf(tmp0, "/tmp/ctm%05.5d", getpid());
	tmp1 = strspl(tmp0, "1");
	tmp2 = strspl(tmp0, "2");
	tmp3 = strspl(tmp0, "3");
	if (pflag==0)
		tmp4 = strspl(tmp0, "4");
	if (oflag)
		tmp5 = strspl(tmp0, "5");
	for (i=0; i<nc; i++) {
		int suffix = getsuf(clist[i]);
		if (nc > 1) {
			printf("%s:\n", clist[i]);
			fflush((&_iob[1]));
		}
		if (suffix == 's') {
			assource = clist[i];
			goto assemble;
		} else
			assource = tmp3;
		if (suffix == 'i')
			goto compile;
		if (pflag)
			tmp4 = setsuf(clist[i], 'i');
		av[0] = "cpp";
		av[1] = clist[i];
		av[2] = exflag ? "-" : tmp4;
		na = 3;
		for (j = 0; j < np; j++)
			av[na++] = plist[j];
		av[na++] = 0;
		switch (callsys(cpp, av)) {
			case 0:
				break;
			default:
				if (callsys("/lib/cpre",av)) {
					exfail++;
					exflag++;
				}
		}
		if (pflag || exfail) {
			cflag++;
			continue;
		}
		if (sflag)
			assource = tmp3 = setsuf(clist[i], 's');
compile:
		av[0] = "ccom";
		av[1] = suffix=='i'? clist[i]: tmp4;
		av[2] = oflag? tmp5:tmp3;
		na = 3;
		if (proflag)
			av[na++] = "-XP";
		if (gflag)
			av[na++] = "-Xg";
		if (wflag)
			av[na++] = "-w";
		av[na] = 0;
		if (callsys(ccom, av)) {
			cflag++;
			eflag++;
			continue;
		}
		if (oflag) {
			av[0] = "c2"; av[1] = tmp5; av[2] = tmp3; av[3] = 0;
			if (callsys(c2, av)) {
				unlink(tmp3);
				tmp3 = assource = tmp5;
			} else
				unlink(tmp5);
		}
		if (sflag)
			continue;
	assemble:
			if (tmp1) unlink(tmp1); 	if (tmp2) unlink(tmp2); 	if (tmp4) unlink(tmp4);
		av[0] = "as"; av[1] = "-o"; av[2] = setsuf(clist[i], 'o');
		na = 3;
		if (Rflag)
			av[na++] = "-R";
		if (dflag)
			av[na++] = dflag;
		av[na++] = assource;
		av[na] = 0;
		if (callsys(as, av) > 1) {
			cflag++;
			eflag++;
			continue;
		}
	}
nocom:
	if (cflag==0 && nl!=0) {
		i = 0;
		av[0] = "ld"; av[1] = "-X"; av[2] = crt0; na = 3;
		if (outfile) {
			av[na++] = "-o";
			av[na++] = outfile;
		}
		while (i < nl)
			av[na++] = llist[i++];
		if (gflag)
			av[na++] = "-lg";
		av[na++] = "-lc";
		av[na++] = 0;
		eflag |= callsys(ld, av);
		if (nc==1 && nxo==1 && eflag==0)
			unlink(setsuf(clist[0], 'o'));
	}
	dexit();
}
idexit()
{
	eflag = 100;
	dexit();
}
dexit()
{
	if (!pflag) {
			if (tmp1) unlink(tmp1);
			if (tmp2) unlink(tmp2);
		if (sflag==0)
				if (tmp3) unlink(tmp3);
			if (tmp4) unlink(tmp4);
			if (tmp5) unlink(tmp5);
	}
	exit(eflag);
}
error(s, x)
	char *s, *x;
{
	struct _iobuf *diag = exflag ? (&_iob[2]) : (&_iob[1]);
	fprintf(diag, "cc: ");
	fprintf(diag, s, x);
	 (--( diag)->_cnt>=0? ((int)(*( diag)->_ptr++=(unsigned)('\n'))):_flsbuf((unsigned)('\n'), diag));
	exfail++;
	cflag++;
	eflag++;
}
getsuf(as)
char as[];
{
	register int c;
	register char *s;
	register int t;
	s = as;
	c = 0;
	while (t = *s++)
		if (t=='/')
			c = 0;
		else
			c++;
	s -= 3;
	if (c <= 14 && c > 2 && *s++ == '.')
		return (*s);
	return (0);
}
char *
setsuf(as, ch)
	char *as;
{
	register char *s, *s1;
	s = s1 = savestr(as);
	while (*s)
		if (*s++ == '/')
			s1 = s;
	s[-1] = ch;
	return (s1);
}
callsys(f, v)
	char *f, **v;
{
	int t, status;
	register char **vp;	
	if(vflag) {	
		vp = v;
		fprintf((&_iob[2]),"+ ");
		while (*vp)
			fprintf((&_iob[2]),"%s ",*vp++);
		fprintf((&_iob[2]), "\n");
	}
	ftime(&oldt);
	vtimes(0, &oldv);
	t = vfork();
	if (t == -1) {
		printf("No more processes\n");
		return (100);
	}
	if (t == 0) {
		execv(f, v);
		printf("Can't find %s\n", f);
		fflush((&_iob[1]));
		_exit(100);
	}
	while (t != wait(&status))
		;
	ftime(&newt);
	vtimes(0, &newv);
	printf("%s\n", f);
	printf("real %g user %g sys %g ", newt.time - oldt.time
		+ newt.millitm / 1000. - oldt.millitm / 1000.,
		(newv.vm_utime - oldv.vm_utime) / 60.,
		(newv.vm_stime - oldv.vm_stime) / 60.);
	printf("reads %d writes %d\n", newv.vm_inblk - oldv.vm_inblk,
		newv.vm_oublk - oldv.vm_oublk);
	if ((t=(status&0377)) != 0 && t!=14) {
		if (t!=2) {
			printf("Fatal error in %s\n", f);
			eflag = 8;
		}
		dexit();
	}
	return ((status>>8) & 0377);
}
nodup(l, os)
	char **l, *os;
{
	register char *t, *s;
	register int c;
	s = os;
	if (getsuf(s) != 'o')
		return (1);
	while (t = *l++) {
		while (c = *s++)
			if (c != *t++)
				break;
		if (*t==0 && c==0)
			return (0);
		s = os;
	}
	return (1);
}
char	*savetab;
int	saveleft;
char *
savestr(cp)
	register char *cp;
{
	register int len;
	len = strlen(cp) + 1;
	if (len > saveleft) {
		saveleft = 1024;
		if (len > saveleft)
			saveleft = len;
		savetab = (char *)malloc(saveleft);
		if (savetab == 0) {
			fprintf((&_iob[2]), "ran out of memory (savestr)\n");
			exit(1);
		}
	}
	strncpy(savetab, cp, len);
	cp = savetab;
	savetab += len;
	saveleft -= len;
	return (cp);
}
char *
strspl(left, right)
	char *left, *right;
{
	char buf[1024];
	strcpy(buf, left);
	strcat(buf, right);
	return (savestr(buf));
}
c.i             599586274   170   4     100664  5928      `
/* ac.c */
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	int	daddr_t;
typedef	char *	caddr_t;
typedef	u_short ino_t;
typedef	int	swblk_t;
typedef	int	size_t;
typedef	int	time_t;
typedef	int	label_t[14];
typedef	short	dev_t;
typedef	int	off_t;
typedef long	portid_t;
typedef struct	fd_set { int fds_bits[1]; } fd_set;
struct tm { 
	int	tm_sec;
	int	tm_min;
	int	tm_hour;
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};
struct utmp {
	char	ut_line[8];		
	char	ut_name[8];		
	long	ut_time;		
};
struct	utmp ibuf, ubuf[400	], tbuf[101	];
int	nnames;		
char	*wtmp = "/usr/adm/wtmp";
char	REBOOT[] = "~";
char	OLDTIME[] = "|";
char	NEWTIME[] = "{";
char	DATERR[] = "ac: botched date change\n";
int	pflag, byday, tflag;
time_t	lasttime, dtime, starttime, stoptime;
int	ncount;
char	*SYSBUF[1024];
char	**nptr;
char	*ctime(), *strncpy();
time_t	time(), nexttime(), prevtime();
struct	tm *localtime();
main(argc, argv)
	register int argc;
	register char **argv;
{
	register struct _iobuf *wf;
	setbuf((&_iob[1]), SYSBUF);
	while (--argc > 0 && **++argv == '-')
	switch(*++*argv) {
	case 'd':
		byday++;
		continue;
	case 'w':
		if (--argc > 0)
			wtmp = *++argv;
		continue;
	case 'p':
		pflag++;
		continue;
	case 't':
		tflag++;
		pflag++;
		continue;
	}
	ncount = argc;
	nptr = argv;
	if ((wf = fopen(wtmp, "r")) == 0) {
		fprintf((&_iob[2]), "ac: cannot open %s\n", wtmp);
		exit(1);
	}
	while (fread((char *)&ibuf, sizeof(ibuf), 1, wf) == 1) {
		loop();
		lasttime = ibuf.ut_time;
	}
	*ibuf.ut_name = '\0';
		(void)strncpy(ibuf.ut_line,  REBOOT, sizeof(ibuf.ut_line));
	time(&ibuf.ut_time);
	loop();
	print();
	exit(0);
}
loop()
{
	register struct utmp *tp;
	register char *p;
	register int n, i;
	if (tflag && *ibuf.ut_name)
			(void)strncpy(ibuf.ut_name,  ibuf.ut_line, sizeof(ibuf.ut_name));
	if (	(*ibuf.ut_line == *  NEWTIME && strncmp(ibuf.ut_line,   NEWTIME, sizeof(ibuf.ut_line)) == 0)) {
		if (dtime == 0) {
			fprintf((&_iob[2]), DATERR);
			return;
		}
			for(tp = tbuf; tp < &tbuf[101	]; tp++) if (*tp->ut_line)
			tp->ut_time += ibuf.ut_time - dtime;
		dtime = 0;
		return;
	}
	if (dtime != 0) {
		fprintf((&_iob[2]), DATERR);
		dtime = 0;
	}
	if (	(*ibuf.ut_line == *  OLDTIME && strncmp(ibuf.ut_line,   OLDTIME, sizeof(ibuf.ut_line)) == 0)) {
		dtime = ibuf.ut_time;
		return;
	}
	if (lasttime > ibuf.ut_time + 10	)
		fprintf((&_iob[2]), "ac: entry not in time sequence\n");
	if (byday) {
		if (starttime == 0 || starttime > ibuf.ut_time + 10	) {
			starttime = prevtime(ibuf.ut_time);
			stoptime = nexttime(ibuf.ut_time);
		}
		while (ibuf.ut_time >= stoptime) {
				for(tp = tbuf; tp < &tbuf[101	]; tp++) if (*tp->ut_line) {
				update(tp, stoptime);
				tp->ut_time = stoptime;
			}
			print();
			starttime = stoptime;
			stoptime = nexttime(stoptime);
		}
	}
	if (	(*ibuf.ut_line == *  REBOOT && strncmp(ibuf.ut_line,   REBOOT, sizeof(ibuf.ut_line)) == 0)) {
			for(tp = tbuf; tp < &tbuf[101	]; tp++) if (*tp->ut_line) {
			update(tp, ibuf.ut_time);
			*tp->ut_name = '\0';
			tp->ut_time = 0;
		}
		return;
	}
	i = 0;
	p = ibuf.ut_line;
	while (n = *p++)
		i += i+n;
	tp = &tbuf[((unsigned)(i*2)) % 101	];
	n = 101	; do {
		if (	(*tp->ut_line == * ibuf.ut_line && strncmp(tp->ut_line,  ibuf.ut_line, sizeof(tp->ut_line)) == 0)) {
			if (*tp->ut_name)
				update(tp, ibuf.ut_time);
			*tp = ibuf;
			return;
		}
		if (*tp->ut_line == '\0') {
			*tp = ibuf;
			return;
		}
		if (--tp < tbuf)
			tp += 101	;
	} while (--n);
	fprintf((&_iob[2]), "ac: tbuf table overflow\n");
	exit(1);
}
update(tp, t)
	register struct utmp *tp;
	time_t t;
{
	register struct utmp *up;
	register int n;
	if (*tp->ut_name && among(tp)) {
		t -= tp->ut_time;
		if (t < 0)
			fprintf((&_iob[2]), "ac: strange login: %-8.8s%6.2f\n",
				tp->ut_name, (double)t/3600);
		up = ubuf;
		if ((n = nnames) > 0) do {
			if (	(*up->ut_name == * tp->ut_name && strncmp(up->ut_name,  tp->ut_name, sizeof(up->ut_name)) == 0)) {
				up->ut_time += t;
				return;
			}
			up++;
		} while (--n);
		if (nnames < 400	) {
				(void)strncpy(up->ut_name,  tp->ut_name, sizeof(up->ut_name));
			up->ut_time = t;
			nnames++;
			return;
		}
		fprintf((&_iob[2]), "ac: ubuf table overflow\n");
		exit(1);
	}
}
among(up)
	register struct utmp *up;
{
	register int j;
	if (ncount <= 0)
		return(1);
	for (j = 0; j < ncount; j++)
		if (	(*up->ut_name == * nptr[j] && strncmp(up->ut_name,  nptr[j], sizeof(up->ut_name)) == 0))
			return(1);
	return(0);
}
print()
{
	register struct utmp *up;
	register int n;
	time_t ttime, t;
	int namecomp();
	qsort(ubuf, nnames, sizeof(ubuf[0]), namecomp);
	ttime = 0;
	up = ubuf;
	if ((n = nnames) > 0) do {
		ttime += up->ut_time;
		if (pflag && up->ut_time != 0)
			printf("\t%-8.8s%6.2f\n",
				up->ut_name, (double)up->ut_time/3600);
		*up->ut_name = '\0';
		up++;
	} while (--n);
	nnames = 0;
	if (ttime != 0) {
		if (byday) {
			t = stoptime-1;
			printf("%.6s", ctime(&t)+4);
		}
		printf("\ttotal%9.2f\n", (double)ttime/3600);
	}
	fflush((&_iob[1]));
}
namecomp(up1, up2)
	register struct utmp *up1, *up2;
{
	return(	strncmp(up1->ut_name,  up2->ut_name, sizeof(up1->ut_name)));
}
time_t
nexttime(t)
	time_t t;
{
	register int curday;
	time_t n;
	curday = localtime(&t)->tm_yday;
	for (n = 86400L; n; n >>= 1) {
		do {
			t += n;
		} while (curday == localtime(&t)->tm_yday);
		t -= n;
	}
	return(t+1);
}
time_t
prevtime(t)
	time_t t;
{
	register int curday;
	time_t n;
	curday = localtime(&t)->tm_yday;
	for (n = 86400L; n; n >>= 1) {
		do {
			t -= n;
		} while (curday == localtime(&t)->tm_yday);
		t += n;
	}
	return(t);
}
d.i             556379116   170   4     100664  87        `
struct S {
	int (*f)();
};
main()
{	struct S *s;
	(*s->f)(s);
	if((*s->f)(s) == 1);
}


f.i             556379116   170   4     100664  171       `
union U {
	long	u;
};

union U *f();

struct S {
	long	x;
	long	s;
};

union U Z;

main(){
	struct S *a;
	register struct S *r;
	
	a->s = f(r, a->s, (union U*) &Z)->u;
}


g.i             599586310   170   4     100664  12047     `
/* ../common/cgen.c */
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
	char		*hash();
	char		*savestr();
	char		*tstr();
	extern int	tstrused;
	extern char	*tstrbuf[];
	extern char	**curtstr;
extern int nerrors;  
typedef union ndu NODE;
typedef unsigned int TWORD;
typedef long CONSZ;  
extern int dope[];  
extern char *opst[];  
	
union ndu {
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		NODE *left;
		NODE *right;
	}in;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		char * name;
		char pad[8  -sizeof(char *)];	
		CONSZ lval;
		int rval;
	}tn;	
	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int label;  
		int lop;  
	}bn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cst[(6+4)];
		int stsize;  
		short stalign;  
		short argsize;  
	}stn;	
	struct {
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
	}fn;	
	
	struct {
		
		int op;
		int goal;
		TWORD type;
		int cdim;
		int csiz;
		double dval;
	}fpn;	
};
	
	
		
	
	
	
 
	
extern int busy[];
extern NODE node[];
typedef struct shape SHAPE;
	
extern struct shape {
	int	op;	
	SHAPE	*sl;	
	SHAPE	*sr;
	int	sh;	
	int	sc;	
} shapes[];
extern SHAPE	*pshape[];
typedef struct optab OPTAB;
struct optab {
	int	op;	
	int	tyop;	
	OPTAB	*nextop;
	SHAPE	**lshape;	
	int	ltype;		
	SHAPE	**rshape;	
	int	rtype;
	int	needs;
	int	rewrite;
	char	*cstring;
	int	cost;
	int	lcount;		
	int	rcount;		
	int	stinline;	
};
extern OPTAB
	*match(),
	*ophead[],
	table[];
extern NODE resc[];
extern int tmpoff;
extern int maxboff;
extern int maxtemp;
extern int maxarg;
extern int ftnno;
extern int sideff;
extern NODE
	*talloc(),
	*ind2type(),
	*tcopy(),
	*getadr(),
	*getlr();
extern CONSZ rdin();
extern char *rnames[];
extern int lineno;
extern char ftitle[];
extern int fldshf, fldsz;
extern int lflag, udebug, e2debug, odebug, rdebug, radebug, sdebug;
extern int fast;  
	
	
	
	
typedef struct inst INST;
struct inst {
	NODE	*p;
	OPTAB	*q;
	int	goal;
};
extern INST inst[300];
extern nins;
	
	
typedef SHAPE	*SHTABLE[2][20];
extern SHTABLE	sha;
rewcom( p, goal )
NODE *p; 
{
	
	
	
	int o, ty, g1, g2;
	NODE *l, *r, *ql, *qr;
	o = p->tn.op;
	g1 = g2 = 6;
	p->tn.goal = goal;
	
	switch( o )
	{
	case 97:
		cerror( "rewcom(%d) is FREE", p-node );
	case 110:
		g1 = (6+3);
		break;
	case 59:
		g1 = (6+1);
		g2 = goal;
		break;
	case 22:
	case 112:
	case 56:
	case 108:
		g1 = g2 = goal;
		break;
	case 70:
	case 100:
	case 73:
		g2 = (6+1);
		break;
	}
	switch( ty =  (dope[o]&016) )
	{
	case 010:
		rewcom( r = p->in.right, g2 );
	case 04:
		rewcom( l = p->in.left, g1 );
		break;
	case 02:
		return;
	}
	if( o==59 || o==22 || o==108 ) return;
	
	
	
	
	if( l->tn.op == 59 && l->in.left->tn.op != 110 ) 
	{
		
		
		
		ql = l->in.left;
		qr = l->in.right;
		*l = *p;  
		l->in.left = qr;
		p->in.right = l;
		p->in.left = ql;
		p->tn.op = 59;
		rewcom( p, p->tn.goal );
	}
	if( ty == 04 ) return;
	if( r->tn.op == 59 && r->in.right->tn.op != 110 ) 
	{
		
		
		
		ql = r->in.left;
		qr = r->in.right;
		*r = *p;
		p->tn.op = 59;
		p->in.left = ql;
		r->in.right = qr;
		rewcom( p, p->tn.goal );
	}
}
rewlhs(p)
NODE *p; 
{
	
	
	NODE *q, *t;
	q = talloc();
	*q = *p;
	t = tcopy( p->in.left, 0 );
	p->in.left = q;
	p->in.right = t;
	p->tn.op = 59;
	return;
}
rewsto(p)
NODE *p; 
{
	
	
	int o, ao;
	NODE *t, *q;
	
	while( (o=p->tn.op) == 59 ) p = p->in.right;
	if( o == 95 ) return(0);  
	if( o == 99 ) 
	{
		 		
		t = talloc();
		*t = *p->in.left;  
		q = talloc();
		*q = *t;
		t->tn.op = 95;
		t->tn.lval = freetemp(argsize(p)/32 );
		t->tn.lval =  ((t->tn.lval)/8);
		t->tn.name = (char *) 0;
		t->tn.type =      02000   ;
		q->tn.op = 2+ 14;
		q->in.left = t;
		
		t = talloc();
		*t = *p;
		t->in.left = q;
		t->in.right = p->in.left;
		t->tn.op = 98;
		
		p->in.left = talloc();
		p->in.left->tn.op = 59;
		p->in.left->in.left = t;
		p->in.left->in.right = t = talloc(); 
		*t = *q;
		t->in.left = talloc();
		*t->in.left = *q->in.left;
		
		
		if( odebug>1 ) e2print( p );
		return( 1 );
	}
	if( odebug>1 ) 
	{
		e2print( p );
		printf( "\nrewritten by rewsto as:\n" );
	}
	if(  (dope[o]&01) && o!=78 && o!=79 && lhsok( p->in.left ) ) {
		
		rewlhs( p );
		return( 1 );
	}
	ao = 1+ o;
	if(  (dope[ao]&020000) ) 
	{
		if( p->in.left->tn.op == 95 ) 
		{
			p->tn.op = ao;
			rewlhs( p );
			if( odebug>1 ) e2print( p );
			return( 1 );
		}
	}
	
	
	t = talloc();
	*t = *p;  
	q = talloc();
	*q = *p;
	t->tn.op = 95;
	t->tn.lval = freetemp(argsize(p)/32 );
	t->tn.lval =  ((t->tn.lval)/8);
	t->tn.name = (char *) 0;
	q->tn.op = 58;
	q->in.left = t;
	q->in.right = talloc();
	*(q->in.right) = *p;
		
	p->in.right = talloc();
	*(p->in.right) = *t;
	p->tn.op = 59;
	p->in.left = q;
	
	if( odebug>1 ) e2print( p );
	return( 1 );
}
iseff( p )
NODE *p; 
{
	
	int o;
	o = p->tn.op;
	if(  (dope[o]&02000) ||  (dope[o]&01) ) return( 1 );
	switch(  (dope[ o ]&016) )
	{
	case 010:
		if( iseff( p->in.right ) ) return( 1 );
	case 04:
		return( iseff( p->in.left ) );
	}
	return( 0 );
}
NODE *
lhsto( p )
NODE *p; 
{
	
	
	NODE *q;
	int o;
	for( q = p->in.left; (o=q->tn.op)!=(2+ 11); q=q->in.left )
	{
		if(  (dope[o]&016) == 02 ) return( (NODE *)0);
	}
	
	q = q->in.left;
	o = q->tn.op;
	if(  (dope[o]&016) == 02 ) return( (NODE *)0 );
	else return( q );
}
static int
c2bigger( p ) NODE *p; {
	
	register TWORD t, tl;
	t = p->tn.type;
	tl = p->in.left->tn.type;
	if( (t|tl)&      04000 ) return( 0 );  
	if( t&040 ) return( 1 );
	if( tl&040 ) return( 0 );
	if( t&	020 ) return( 1 );
	if( tl&	020 ) return( 0 );
	if( t&(	010|	01000) ) return( 1 );
	if( tl&(	010|	01000) ) return( 0 );
	if( t&(	(	04|	010)|(0400|	01000)) ) return( 1 );
	if( tl&(	(	04|	010)|(0400|	01000)) ) return( 0 );
	if( t &(	02|0200) ) return( 1 );
	return( 0 );
	}
NODE *
ind2type( p )
register NODE *p; 
{
	
	register TWORD t;
	NODE *q;
	t = p->tn.type;
	if( t == 	01 || t == 	02 ) t = 	(	04|	010);
	else if( t == 	0100 || t == 0200 ) t = (0400|	01000);
	else if( t == 	020 ) t = 040;
	else return( p );
	if( p->tn.op == 104 && c2bigger(p) ) 
	{
		p->tn.type = t;
		return( p );
	}
	q = talloc();
	q->tn.op = 104;
	q->in.left = p;
	q->in.right = 0;
	q->tn.name = (char *) 0;
	q->tn.type = t;
	q->tn.goal = 6;
	return( q );
}
NODE *
reweop( p )
register NODE *p; 
{
	
	
	
	
	
	
	register NODE *q, *t;
	register TWORD ty;
	if( odebug>1 ) 
	{
		e2print( p );
		printf( "\nrewritten by reweop as:\n" );
	}
	q = tcopy( p, 0 );
	if( p->in.left->tn.op == 104 ) 
	{
		
		
		
		t = p->in.left;
		ty = t->in.left->tn.type;
		p->in.left = t->in.left;
		tfree( p->in.right );
		p->in.right = t;
		t->in.left = q;
		
		t->tn.type = ty;
	}
	else 
	{
		tfree( p->in.right );
		p->in.right = q;
	}
	
	p->tn.op = 58;
	q->tn.op = (-1)+ q->tn.op;
	p->tn.type = p->in.left->tn.type;
	q->tn.type = q->in.right->tn.type;
	if( odebug>1 ) e2print( p );
}
rewass( p )
NODE *p; 
{
	NODE *q;
	int o;
	
	if( odebug ) 
	{
		printf( "rewass called with:\n" );
		e2print( p );
	}
	o = p->tn.op;
	if( o == 2+ 14 ) 
	{
		if( p->in.left->tn.op == 118 ) 
		{
			
			q = p->in.left;
			q->tn.op = 4;
			*p = *q;
			q->tn.op = 97;
			return(0);  
		}
		
		rewsto( p->in.left );
		
		if( odebug ) 
		{
			printf( "\nrewritten by rewass as:\n" );
			e2print( p );
		}
		return(1);
	}
	if( ! (dope[o]&01) || o==58 ) 
	{
		if( o==58 ) 
		{
			
			o = p->in.left->tn.op;
			if( o==118 || o==120 || o==119 ) 
			{
				
				p->in.left->tn.op = 94;
				p->in.left->tn.rval =  0;
				if( odebug ) 
				{
					printf( "funny node redone\n" );
					e2print(p);
				}
				return(0);
			}
		}
		else 
		{
			TWORD t = p->in.left->tn.type;
			
			
			p->in.left = ind2type( p->in.left );
			p->in.right = ind2type( p->in.right );
			if( odebug ) {
				printf( "conversions inserted" );
				e2print(p);
			}
			
			if( t != p->in.left->tn.type ) {
				
				return( 0 );
			}
		}
		e2print(p);
		cerror( "can't deal with op %s", opst[o] );
	}
	if( o == 78 || o == 79 ) 
	{
		
		if( odebug>1 ) 
		{
			e2print( p );
			printf( "\nrewritten by rewass as:\n" );
		}
		if( p->in.goal == (6+1) )
		{
			p->in.op = ((o==78)?1+ 6:1+ 8);
		}
		else
		{
			q = tcopy(p, 0);
			regrcl( p->in.left );
			tfree( p->in.left );
			p->in.left = q;
			q->tn.op = ((o==78)?1+ 6:1+ 8);
			p->tn.op = ((o==78)?8:6);
		}
		if( odebug ) 
		{
			printf( "\nrewritten by rewass as:\n" );
			e2print( p );
		}
		return(1);
	}
	
	if( q = lhsto(p) ) 
	{
		if( !rewsto( q ) ) cerror( "rewass0" );  
		rewcom( p, p->tn.goal );  
		if( p->tn.op != 59 ) cerror( "rewass1" );
		if( ! (dope[ p->in.right->tn.op ]&01) ) cerror( "rewass2" );
		(void)reweop( p->in.right );
	}
	else (void)reweop( p );  
	return(1);
}
outshp( pp )
SHAPE **pp; 
{
	SHAPE *p;
	if (pp == 0)
		return;
	for( ; p = *pp; ++pp )
	{
		printf("\t\t");
		shpr(p);
		printf( " (%d)\n", p->sc );
	}
}
tabpr()
{
	register	OPTAB	*p;
	for (p =table; ;p++)
	{
		printf("Dump of table[%d] (stinline %d)\n", p-table, p->stinline );
		printf("\top = %s\n", opst[p->op]);
		printf("\tnextop = %d\n", p->nextop?p->nextop-table:-1 );
		printf("\tlshape = %d\n", p->lshape-pshape);
		printf("\tltype = 0%o\n", p->ltype);
		printf("\trshape = %d\n", p->rshape-pshape);
		printf("\trtype = 0%o\n", p->rtype);
		printf("\tneeds = %d\n", p->needs);
		printf("\trewrite = %d\n", p->rewrite);
		printf("\tcstring = %s", p->cstring);
		printf("\tcost = %d\n", p->cost);
		printf("\tLeft:\n");
		outshp(p->lshape);
		printf("\tRight:\n");
		outshp(p->rshape);
		printf("\n");
	}
}
codgen( p )
NODE *p; 
{
	
	int i, flag;
	if (odebug > 5)
	{
		tabpr();
		
	}
	
	
	
	
again:
	
	rewcom( p, (6+1) );
	if( odebug ) 
	{
		printf( "After goals are computed:" );
		e2print( p );
	}
	
	if( costs( p ) ) goto again;  
	if( odebug ) 
	{
		printf( "After costs are computed:" );
		e2print( p );
	}
	
	nins = 0;
	insout( p, (6+1) );
	
	flag = 0;
	for( i=0; i<nins; ++i ) 
	{
		if( inst[i].goal == (6+2) ) 
		{
			if( odebug ) 
			{
				printf( "subtree is stored in temp:\n" );
				e2print( inst[i].p );
			}
			if( rewsto( inst[i].p ) ) {
				if( !fast ) goto again;
				
				flag = 1;
			}
		}
	}
	if( flag ) goto again;
	if( odebug ) e2print(p);
	
	insprt();
}
INST inst[300];
int nins;
insprt()
{
	int i;
	register INST *pi;
	register NODE *p;
	register OPTAB *q;
	register c, goal;
	for( pi=inst,i=0; i<nins; ++i,++pi )
	{
		p = pi->p;
		q = pi->q;
		c = pi->goal;
		if( c == (6+3) && (q->rewrite&040) ) goal = 04 ;
		else if( c == (6+1) ) goal = 01 ;
		else goal = 02 ;
		if(odebug > 4)
		{
			printf("INSOUT: %d c=",i);
			preff(c);
			printf(" goal=");
			prgoal(goal);
			printf("\n");
			e2print(p);
		}
		allo( p, q );
		expand( p, goal, q->cstring, q );
		reclaim( p, q->rewrite, goal );
		
		if( c == (6+3) && p->tn.op != 96 ) 
		{
			cfix( p, (6+3) );
			if( p->tn.op != 96 ) cerror( "ctest fails" );
		}
		if( c>=0 && c<=6 && ! ( p ->in.op==94 &&  (( p ->tn.rval)<6)) )
		{
			cfix( p, 6 );
		}
	}
}
SHTABLE sha;
int odebug = 0;
cfix( p, goal )
NODE *p; 
{
	
	OPTAB *q;
	NODE *pp;
	int r;
	if(odebug > 4)
	{
		printf("CFIX: goal=");
		prgoal(goal);
		printf("\n");
		e2print(p);
	}
	if( goal == (6+3) ) 
	{
		r = 040;
		p->tn.goal = (6+3);
	}
	else 
	{
		r = (04|010|020);
		pp =  ( ( (( (dope[ p ->tn.op]&016))==02? p : p ->in.left)));
		if(  ( pp ->in.op==94 &&  (( pp ->tn.rval)<6)) ) r |= 01;
		pp =  ( ( (( (dope[ p ->tn.op]&016))==010? p ->in.right: p )));
		if(  ( pp ->in.op==94 &&  (( pp ->tn.rval)<6)) ) r |= 02;
	}
	if( goal == (6+3) ) goal = 04 ;
	else goal = 02 ;
	for( q=0; q = match( p, q ); )
	{
		
		
		if( q->rewrite & r ) 
		{
			
			allo( p, q );
			expand( p, goal, q->cstring, q );
			reclaim( p, q->rewrite, goal );
			return;
		}
	}
	e2print(p);
	cerror( "cfix trouble" );
}
preff(c)
{
	char buf[20];
	register char *p;
	p = c==(6+3) ? "CCC" : c==(6+2) ? "CTEMP" : c==(6+1) ? "CEFF" : 0;
	if(!p)
	{
		sprintf(buf,"0%o",c);
		p = buf;
	}
	printf("%s",p);
}

h.i             556379117   170   4     100664  144       `
struct S {
	long	x;
	long	s;
};
struct S *ptr(), data();
main(){
	struct S *a;
	int i;
	register struct S *r;
	*(ptr(a)) = data( r, i+1, a);
}

i.i             556379117   170   4     100664  194       `
struct S {
	int	(*f)();
struct	S	*table[10][20];
struct	S	*ptr;
};

main(){
	struct S *a;
	int i, j;
	register struct S *r;
	
	a->ptr = r->table[ i = (*a->f)(a)&07 ] [ j = 1 ];	/* no call */
}

j.i             588022776   170   4     100664  187       `
struct {int a, b, c, d[10];} *x;
main(n, f)
{
	x[n].a = f;
}
af()
{	double da, db;
	long la, lb;
	if((int)da == (int)db)
		;
	if((char)da == (char)db)
		;
	if((char)la == (char)lb)
		;
}

k.i             556379117   170   4     100664  779       `
/* bit fields strike again!! there seems to be an indirection problem */

struct cmap
{
unsigned int 	c_next:13,	/* index of next free list entry */
		c_prev:13,	/* index of previous (6700 for 8Mb) */
		c_lock:1,	/* locked for raw i/o or pagein */
		c_want:1,	/* wanted */
		c_page:16,	/* virtual page number in segment */
		c_hlink:13,	/* hash link for <blkno,mdev> */
		c_intrans:1,	/* intransit bit */
		c_free:1,	/* on the free list */
		c_gone:1,	/* associated page has been released */
		c_type:2,	/* type CSYS or CTEXT or CSTACK or CDATA */
		c_blkno:20,	/* disk block this is a copy of */
		c_ndx:10,	/* index of owner proc or text */
		c_mdev:6;	/* which mounted dev this is from (NMOUNT) */
};

extern struct cmap *cmap;

foo(i)
register i;
{
	cmap[i-1].c_next = i;
}


l.i             599586441   170   4     100664  7750      `
typedef int	(*SIG_TYP)();
SIG_TYP signal();
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	struct	_physadr { int r[1]; } *physadr;
typedef	int	daddr_t;
typedef	char *	caddr_t;
typedef	u_short ino_t;
typedef	int	swblk_t;
typedef	int	size_t;
typedef	int	time_t;
typedef	int	label_t[14];
typedef	short	dev_t;
typedef	int	off_t;
typedef long	portid_t;
typedef struct	fd_set { int fds_bits[1]; } fd_set;
int	hz;			
int	timezone;		
int	dstflag;		
char	canonb[256		];	
extern char	version[];		
int	lbolt;			
time_t	time;			
time_t	bootime;		
long	trannum;		
int	hand;			
int	nblkdev;
int	nchrdev;
int	nstream;		
int	nswdev;			
int	mpid;			
char	runin;			
char	runout;			
int	runrun;			
char	kmapwnt;		
char	curpri;			
int	maxmem;			
int	physmem;		
int	nswap;			
int	updlock;		
daddr_t	rablock;		
extern	int intstack[];		
dev_t	rootdev;		
dev_t	dumpdev;		
long	dumplo;			
dev_t	swapdev;		
dev_t	argdev;			
dev_t	pipedev;		
extern	int icode[];		
extern	int szicode;		
dev_t	getmdev();
daddr_t	bmap();
caddr_t	calloc();
unsigned max();
unsigned min();
int	memall();
int	uchar(), schar();
int	vmemall();
char	*wmemall();
swblk_t	vtod();
extern struct sysent
{
	int	sy_narg;		
	int	(*sy_call)();		
} sysent[];
extern char	vmmap[];		
int	umbabeg,umbaend;	
int	noproc;			
extern	int catcher[256];
char	*panicstr;
int	wantin;
int	boothowto;		
struct map {
	struct	mapent *m_limit;	
	char	*m_name;		
};
struct mapent
{
	int	m_size;		
	int	m_addr;		
};
struct	nexus {
	union nexcsr {
		long	nex_csr;
		u_char	nex_type;
	} nexcsr;
	long	nex_pad[0x2000 / sizeof (long) - 1];
};
struct pte
{
unsigned int	pg_pfnum:21,		
		:2,
		pg_vreadm:1,		
		pg_swapm:1,		
		pg_fod:1,		
		pg_m:1,			
		pg_prot:4,		
		pg_v:1;			
};
struct hpte
{
unsigned int	pg_pfnum:21,
		:2,
		pg_high:9;		
};
struct fpte
{
unsigned int	pg_blkno:20,		
		pg_fileno:5,		
		pg_fod:1,		
		:1,
		pg_prot:4,
		pg_v:1;
};
struct bufhd
{
	long	b_flags;		
	struct	buf *b_forw, *b_back;	
};
struct buf
{
	long	b_flags;		
	struct	buf *b_forw, *b_back;	
	struct	buf *av_forw, *av_back;	
	long	b_bcount;		
	short	b_error;		
	dev_t	b_dev;			
	union {
	    caddr_t b_addr;		
	    int	*b_words;		
	    struct filsys *b_filsys;	
	    struct dinode *b_dino;	
	    daddr_t *b_daddr;		
	} b_un;
	daddr_t	b_blkno;		
	long	b_resid;		
	struct  proc *b_proc;		
};
struct mba_regs
{
	int	mba_csr;		
	int	mba_cr;			
	int	mba_sr;			
	int	mba_var;		
	int	mba_bcr;		
	int	mba_dr;
	int	mba_pad1[250];
	struct mba_drv {		
		int	mbd_cs1;		
		int	mbd_ds;			
		int	mbd_er1;		
		int	mbd_mr1;		
		int	mbd_as;			
		int	mbd_da;			
		int	mbd_dt;			
		int	mbd_la;			
		int	mbd_sn;			
		int	mbd_of;			
		int	mbd_fill[22];
	} mba_drv[8];
	struct	pte mba_map[256];	
	int	mba_pad2[256*5];	
};
struct	mba_hd {
	short	mh_active;		
	short	mh_ndrive;		
	struct	mba_regs *mh_mba;	
	struct	mba_regs *mh_physmba;	
	struct	mba_device *mh_mbip[8];	
	struct	mba_device *mh_actf;	
	struct	mba_device *mh_actl;	
};
struct	mba_device {
	struct	mba_driver *mi_driver;
	short	mi_unit;	
	short	mi_mbanum;	
	short	mi_drive;	
	short	mi_dk;		
	short	mi_alive;	
	short	mi_type;	
	struct	buf mi_tab;	
	struct	mba_device *mi_forw;
	struct	mba_regs *mi_mba;
	struct	mba_drv *mi_drv;
	struct	mba_hd *mi_hd;
};
struct	mba_slave {
	struct	mba_driver *ms_driver;
	short	ms_ctlr;		
	short	ms_unit;		
	short	ms_slave;		
	short	ms_alive;
};
struct mba_driver {
	int	(*md_attach)();		
	int	(*md_slave)();		
	int	(*md_ustart)();		
	int	(*md_start)();		
	int	(*md_dtint)();		
	int	(*md_ndint)();		
	short	*md_type;		
	char	*md_dname, *md_sname;	
	struct	mba_device **md_info;	
};
					
					
struct vmmeter
{
	unsigned v_swtch;	
	unsigned v_trap;	
	unsigned v_syscall;	
	unsigned v_intr;	
	unsigned v_pdma;	
	unsigned v_pswpin;	
	unsigned v_pswpout;	
	unsigned v_pgin;	
	unsigned v_pgout;	
	unsigned v_pgpgin;	
	unsigned v_pgpgout;	
	unsigned v_intrans;	
	unsigned v_pgrec;	
	unsigned v_xsfrec;	
	unsigned v_xifrec;	
	unsigned v_exfod;	
	unsigned v_zfod;	
	unsigned v_vrfod;	
	unsigned v_nexfod;	
	unsigned v_nzfod;	
	unsigned v_nvrfod;	
	unsigned v_pgfrec;	
	unsigned v_faults;	
	unsigned v_scan;	
	unsigned v_rev;		
	unsigned v_seqfree;	
	unsigned v_dfree;	
	unsigned v_swpin;	
	unsigned v_swpout;	
};
struct vmtotal
{
	short	t_rq;		
	short	t_dw;		
	short	t_pw;		
	short	t_sl;		
	short	t_sw;		
	int	t_vm;		
	int	t_avm;		
	short	t_rm;		
	short	t_arm;		
	int	t_vmtxt;	
	int	t_avmtxt;	
	short	t_rmtxt;	
	short	t_armtxt;	
	short	t_free;		
};
struct	forkstat
{
	int	cntfork;
	int	cntvfork;
	int	sizfork;
	int	sizvfork;
};
struct	swptstat
{
	int	pteasy;		
	int	ptexpand;	
	int	ptshrink;	
	int	ptpack;		
};
struct uba_regs
{
	int	uba_cnfgr;		
	int	uba_cr;			
	int	uba_sr;			
	int	uba_dcr;		
	int	uba_fmer;		
	int	uba_fubar;		
	int	pad1[2];
	int	uba_brsvr[4];
	int	uba_brrvr[4];		
	int	uba_dpr[16];		
	int	pad2[480];
	struct	pte uba_map[496];	
	int	pad3[16];		
};
 
 
struct	uba_hd {
	struct	uba_regs *uh_uba;	
	struct	uba_regs *uh_physuba;	
	int	(**uh_vec)();		
	struct	uba_device *uh_actf;	
	struct	uba_device *uh_actl;	
	short	uh_mrwant;		
	short	uh_bdpwant;		
	int	uh_bdpfree;		
	int	uh_hangcnt;		
	int	uh_zvcnt;		
	int	uh_errcnt;		
	int	uh_lastiv;		
	short	uh_users;		
	short	uh_xclu;		
	struct	map *uh_map;		
};
struct uba_ctlr {
	struct	uba_driver *um_driver;
	short	um_ctlr;	
	short	um_ubanum;	
	short	um_alive;	
	int	(**um_intr)();	
	caddr_t	um_addr;	
	struct	uba_hd *um_hd;
	int	um_cmd;		
	int	um_ubinfo;	
	struct	buf um_tab;	
};
struct uba_device {
	struct	uba_driver *ui_driver;
	short	ui_unit;	
	short	ui_ctlr;	
	short	ui_ubanum;	
	short	ui_slave;	
	int	(**ui_intr)();	
	caddr_t	ui_addr;	
	short	ui_dk;		
	int	ui_flags;	
	short	ui_alive;	
	short	ui_type;	
	caddr_t	ui_physaddr;	
	struct	uba_device *ui_forw;
	struct	uba_ctlr *ui_mi;
	struct	uba_hd *ui_hd;
};
struct uba_driver {
	int	(*ud_probe)();		
	int	(*ud_slave)();		
	int	(*ud_attach)();		
	int	(*ud_dgo)();		
	u_short	*ud_addr;		
	char	*ud_dname;		
	struct	uba_device **ud_dinfo;	
	char	*ud_mname;		
	struct	uba_ctlr **ud_minfo;	
	short	ud_xclu;		
};
union cpusid {
	int	cpusid;
	struct cpuany {
		u_int	:24,
			cp_type:8;
	} cpuany;
	struct cpu780 {
		u_int	cp_sno:12,		
			cp_plant:3,		
			cp_eco:9,		
			cp_type:8;		
	} cpu780;
	struct cpu750 {
		u_int	cp_hrev:8,		
			cp_urev:8,		
			:8,
			cp_type:8;		
	} cpu750;
	
};
struct	percpu {
	short	pc_cputype;		
	short	pc_nnexus;		
	struct	nexus *pc_nexbase;	
	caddr_t	*pc_umaddr;		
	short	pc_nubabdp;		
	short	pc_haveubasr;		
	short	*pc_nextype;		
};
struct scb {
	int	(*scb_stray)();		
	int	(*scb_machchk)();	
	int	(*scb_kspinval)();	
	int	(*scb_powfail)();	
	int	(*scb_resinstr)();	
	int	(*scb_custinst)();	
	int	(*scb_resopnd)();	
	int	(*scb_resaddr)();	
	int	(*scb_acv)();		
	int	(*scb_tnv)();		
	int	(*scb_tracep)();	
	int	(*scb_bpt)();		
	int	(*scb_compat)();	
	int	(*scb_arith)();		
	int	(*scb_stray2)();
	int	(*scb_stray3)();
	int	(*scb_chmk)();		
	int	(*scb_chme)();		
	int	(*scb_chms)();		
	int	(*scb_chmu)();		
	int	(*scb_sbisilo)();	
	int	(*scb_cmrd)();		
	int	(*scb_sbialert)();	
	int	(*scb_sbiflt)();	
	int	(*scb_wtime)();		
	int	(*scb_stray4[8])();
	int	(*scb_soft[15])();	
	int	(*scb_timer)();		
	int	(*scb_stray5[7])();
	int	(*scb_stray6[4])();
	int	(*scb_csdr)();		
	int	(*scb_csdx)();		
	int	(*scb_ctr)();		
	int	(*scb_ctx)();		
	int	(*scb_ipl14[16])();	
	int	(*scb_ipl15[16])();	
	int	(*scb_ipl16[16])();	
	int	(*scb_ipl17[16])();	
	int	(*scb_ubaint[128])();	
};
struct	mcr {
	int	mc_reg[3];
};
unifind(vubp, pubp, vumem, pumem, memmap)
	struct uba_regs *vubp, *pubp;
	caddr_t vumem, pumem;
	struct pte *memmap;
{
		



	struct uba_hd *uhp;

	int i, haveubasr = 0;
	for (i = 0; i < 128; i++)
		uhp->uh_vec[i] =
		    		((int (*)())(((int)&catcher[i*2])+ 1));
}
m.i             556379118   170   4     100664  1867      `
struct defs {
     int cbits;          
     int ibits;          
     int sbits;          
     int lbits;          
     int ubits;          
     int fbits;          
     int dbits;          
     float fprec;        
     float dprec;        
     int flgs;           
     int flgm;           
     int flgd;           
     int flgl;           
     int rrc;            
     int crc;            
     char rfs[8];        
   };
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
struct record{
	int field1,field2,field3;
	};
	struct list { int f1; double f2; float f3; } ;
	union rec { int recf1; float recf2; double recf3; } ;
struct list rfun(x)  struct list x;
{
x.f1=x.f1+100;
x.f2=x.f2+200.0;
x.f3=x.f3+300.0;
return x;
}
union rec ufun(x) union rec x;
{
x.recf2=x.recf2+100.0;
return x;
}

s141(pd0)	
	struct defs *pd0;
{
static char s141er[]="s141,er%d\n";
static char qs141[8]="s141   ";
struct list r1,r2,r3;
union rec rec1, rec2;
char *ps = qs141,
     *pt = pd0->rfs;
int rc = 0 ;

 while ( *(pt)++ = *(ps)++ );

r1.f1=1000; r1.f2=2000.0; r1.f3=3000.0;
r3=r2=r1;

if (1000!=r2.f1 || 2000.0!=r2.f2 || 3000.0!=r2.f3
   || r1.f1!=r3.f1 || r1.f2!=r3.f2 || r1.f3!=r3.f3)
	{ rc++; if (pd0->flgd) printf(s141er,1); }
r2.f3=r2.f2=r2.f1=1;
r3=rfun(r2=r1);

if (r3.f1!=r1.f1+100 || r1.f1!=r2.f1 || r1.f1!=1000 ||
    r3.f2!=r1.f2+200.0 || r1.f2!=r2.f2 || r1.f2!=2000.0 ||
    r3.f3!=r1.f3+300.0 || r1.f3!=r2.f3 || r1.f3!=3000.0 )
	{ rc+=2; if (pd0->flgd) printf(s141er,2); }
if (r3.f3!=rfun(r1).f3)
	{ rc+=4; if (pd0->flgd) printf(s141er,4); }
rec1.recf2=33.0;
rec2=ufun(rec1);
if (ufun(rec1).recf2!=133.0 || rec1.recf2!=33.0)
	{ rc +=8 ; if (pd0->flgd) printf(s141er,8); }
return rc;
}

n.i             556379118   170   4     100664  1281      `
struct Index { unsigned char _Index_major ; unsigned char _Index_minor ; };
struct IList { struct Index _IList_index ; struct IList * _IList_next ; };
struct Menu { struct IList * _Menu_list ; int _Menu_size ; }; 
int f( _auto_this , _auto_i )
register struct Menu * _auto_this; 
struct Index _auto_i; 
{ struct IList * _auto_l ; 
struct IList * _auto__Xthis__ctor_IList ; 
struct Index _auto__Xi__ctor_IList ; 
struct IList * _auto__Xn__ctor_IList ; 
struct Index * _auto__Xthis__ctorF__Index ; 

_auto_l->_IList_next=(struct IList*)((_auto__Xthis__ctor_IList=(
struct IList*)0),((_auto__Xi__ctor_IList=_auto_i),((_auto__Xn__ctor_IList=(struct IList*
)0),(((_auto__Xthis__ctor_IList==(struct IList*)0)?(_auto__Xthis__ctor_IList=
(struct IList*)_new((unsigned int)8)):0),((
(_auto__Xthis__ctorF__Index=(struct Index*)(&_auto__Xthis__ctor_IList->_IList_index)),(((_auto__Xthis__ctorF__Index==(
struct Index*)0)?(_auto__Xthis__ctorF__Index=(struct Index*)_new((unsigned int)
4)):0),((_auto__Xthis__ctorF__Index->_Index_major=(_auto__Xthis__ctorF__Index->_Index_minor=0)),
_auto__Xthis__ctorF__Index))),((_auto__Xthis__ctor_IList->_IList_index=_auto__Xi__ctor_IList),((_auto__Xthis__ctor_IList->_IList_next=(struct IList*
)_auto__Xn__ctor_IList),_auto__Xthis__ctor_IList)))))));
}; 


o.i             580049358   170   4     100664  249       `
m(){
	register char *s;
	register c;
	*s++ = (c&0200? c : '/');
}
typedef struct P0 {
	unsigned L9 : 8;		
} P0;
P0 x;
unsigned char sv[512];
addproc(n)
{	int j, i;
	((P0 *)(&sv[i]))->L9 = j = addqueue();
}
a()
{	int j;
	(&x)->L9 = j = addqueue();
}

p.i             556379118   170   4     100664  176       `
typedef struct Menu{
	char	**item;
} Menu;

Menu menus[10] ; 

char m_strings[100][10];

m_init()
{
	register m, i, s ;

			menus[m].item[i] = &(m_strings[s++][0]);	/* r0 */
}
q.i             556379118   170   4     100664  117       `
char *a = "abc";
char b[10];
int i;
main()
{	int f();
	a[f(a)] = b[i++];	/* is that right? */
}
f(n)
{
	return(0);
}

r.i             556379118   170   4     100664  68        `
union D{
	double v;
	int *s;
}*dp;
push(d)
union D d;
{
	*dp++=d;
}
s.i             556379118   170   4     100664  251       `
struct X { unsigned char a; unsigned char b;};
struct I { char	*t; long f; long o;};
struct C { int	 g;
	struct X x;
	struct I ***i;
}

main()
{
	register struct C *r;
	struct I c;
	struct I *f();

	*( r->i[r->x.a][r->x.b] = f((struct I*)0) ) = c;
}


t.i             556379118   170   4     100664  418       `
main()
{ unsigned short a, b;
	a = b ? 1 : 0;
}
struct vertex { double x, y;};
double dist();
flip(v)
register struct vertex *v;
{
	struct vertex p;
	if(dist(p.x, p.y)<dist(v->x, v->y))
		return(1);
	return(0);
}
f()
{
  double x[10], step;
  int n;
  step = (x[n-1]-x[0])/(n-1);
}
eval(n,x,f,d,m,p,g)
  int n,m;
  double x[], f[], d[], p[], g[];
{	int i, j;
  g[i] = f[j] + (f[j+1]-f[j])*(p[i]-x[j])/(x[j+1]-x[j]);
}
u.i             599586556   170   4     100664  160       `
typedef struct seq {
	short cnt, size;
	struct seqd {
		char *p;
		int beg, end;
	} *data;
} seq;
main(s)
seq *s;
{
	foo((s->cnt *= 2) * sizeof(struct seq));
}
v.i             556379119   170   4     100664  99        `
union M {
	long	s;
};
main()
{
	register long u;
	register union M *m;

	u = (m->s &= 0xFFFFFF);
}

w.i             599586619   170   4     100664  3774      `
int	flags;
double	wlong, awlong, nlat, elev;
double	obliq, phi, eps, tobliq;
double	dphi, deps;
double	day, deld;
double	eday, capt, capt2, capt3, gst;
double	pi, radian, radsec, deltat;
double	erad, glat;
double	xms, yms, zms;
double	xdot, ydot, zdot;
double	ecc, incl, node, argp, mrad, anom, motion;
double	lambda, beta, rad, mag, semi;
double	alpha, delta, rp, hp;
double	ra, decl, semi2;
double	lha, decl2, lmb2;
double	az, el;
double	meday, seday, mhp, salph, sdelt, srad;
double	rah, ram, ras, dday, dmin, dsec;
long	agc;
double	da, dd, px, epoch;
char	line[100];
double	sin();
double	cos();
double	floor();
double	ltod();
double	sqrt();
double	pyth();
double	fmod();
double	atan2();
double	log();
double	fabs();
double	dist();
double	rise();
double	set();
double	melong();
double	solstice();
double	betcross();
int	evcomp();
long	time();
double	sunel();
double	readate();
double	convdate();
double	ltod();
double	atof();
double	cosadd();
double	sinadd();
char *	skip();
struct	obj1
{
	double	ra;
	double	decl2;
	double	semi2;
	double	az;
	double	el;
	double	mag;
};
struct	obj2
{
	char	*name;
	int	(*obj)();
	struct	obj1	point[12+2];
}
osun, omoon, oshad, omerc, ovenus,
omars, osat, ojup, ostar;
extern struct	obj2	*objlst[];
struct	obj3
{
	double	t1;
	double	t2;
	double	t3;
	double	t4;
	double	t5;
} occ;
extern int	dmo[];
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
main(argc, argv)
char *argv[];
{
	register i, j;
	double d;
	pi = 3.1415926535897932;
	radian = pi/180.;
	radsec = radian/3600.;
	args(argc, argv);
	init();
	deld = 1.0/12;
loop:
	d = day;
	pdate(d);
	if(flags & 8) {
		printf(" ");
		ptime(d);
	}
	printf("\n");
	for(i=0; i<=12+1; i++) {
		setime(d);
		for(j=0; objlst[j]; j++) {
			(*objlst[j]->obj)();
			setobj(&objlst[j]->point[i]);
			if(flags & 8)
				output(objlst[j]->name, &objlst[j]->point[i]);
		}
		d += deld;
		if(flags & 8)
			exit(0);
	}
	search();
	day += 1.0;
	if(flags & 1)
		goto loop;
	exit(0);
}
args(argc, argv)
char *argv[];
{
	register char *p;
	long t;
	p = "";
	if(argc > 1)
		p = argv[1];
	while(*p)
	switch(*p++) {
	case 'd':
		flags |= 64;
		continue;
	case 'l':
		flags |= 128;
		continue;
	case 'c':
		flags |= 1;
		continue;
	case 'p':
		flags |= 8;
		continue;
	case 's':
		flags |= 4;
		continue;
	case 'a':
		flags |= 16;
		continue;
	case 't':
		flags |= 256;
		continue;
	case 'o':
		flags |= 2;
		continue;
	case 'k':
		flags |= 512;
		continue;
	case '-':
		continue;
	default:
		printf("unknown option '%c'\n", p[-1]);
	}
	t = time((int *)0);
	day = t/86400. + 25567.5;
	if(flags & 64)
		day = readate();
	awlong = (74. + 32./60.)*radian;
	nlat = (40. + 40./60.)*radian;
	elev = 0.;
	if(flags & 128)
		readlat();
}
double
readate()
{
	register i;
	double ifa[5];
	printf("year mo da hr min\n");
	rline((&_iob[0]));
	for(i=0; i<5; i++)
		ifa[i] = atof(skip(i));
	return(convdate(ifa));
}
double
convdate(ifa)
double ifa[];
{
	double y, d;
	register i;
	y = ifa[0];
	i = (int)ifa[1];
	d = ifa[2];
	while(i < 1) {
		i += 12;
		y -= 1.;
	}
	while(i > 12) {
		i -= 12;
		y += 1.;
	}
	if(y < 0.)
		y += 1.;
	y += 4712.;
	if(fmod(y, 4.) == 0 && i > 2)
		d += 1.;
	y = y*365. +
		floor((y+3.)/4.) +
		dmo[i-1] + d - 1.;
	if(y > 2361232.)
		y -= floor((y-1794167.)/36525.) -
			floor((y-1721117.)/146100.);
	y += ifa[3]/24. + ifa[4]/1440. - .5;
	return(y-2415020.);
}
readlat()
{
	register i;
	double ifa[3];
	printf("wlong nlat elev\n");
	rline((&_iob[0]));
	for(i=0; i<3; i++)
		ifa[i] = atof(skip(i));
	awlong = ifa[0] * radian;
	nlat = ifa[1] * radian;
	elev = ifa[2];
}
double
fmod(a, b)
double a, b;
{
	return(a - floor(a/b)*b);
}
x.i             556379119   170   4     100664  94        `
struct tbl {
	int a, b, c, d, e;
	int *deadrow;
}t[2];
m(){
	int a, n;
	t[n].deadrow[a]=0;
}

y.i             556379119   170   4     100664  187       `
union data { double	f; };
struct xnode { union { struct xnode	*xu_xnd; } x_u1;
	struct xnode	*x_right;
	union data	x_value;
};
main()
{	struct xnode	*x;
	*x = *x->x_right->x_u1.xu_xnd;
}

z.i             556379120   170   4     100664  40179     `
struct defs {
     int cbits;          
     int ibits;          
     int sbits;          
     int lbits;          
     int ubits;          
     int fbits;          
     int dbits;          
     float fprec;        
     float dprec;        
     int flgs;           
     int flgm;           
     int flgd;           
     int flgl;           
     int rrc;            
     int crc;            
     char rfs[8];        
   }xx = { 0,0,0,0,0,0,0,0,0,1, 1, 1, 1} ;
extern	struct	_iobuf {
	int	_cnt;
	unsigned char	*_ptr;
	unsigned char	*_base;
	short	_flag;
	char	_file;
} _iob[20];
struct _iobuf	*fopen();
struct _iobuf	*fdopen();
struct _iobuf	*freopen();
long	ftell();
char	*fgets();
struct record{
	int field1,field2,field3;
	};
main()
{
	s714(&xx);
}

s714(pd0)          
struct defs *pd0;
{
   static char f[] = "Local error %d.\n";
   static char s714er[] = "s714,er%d\n";
   static char qs714[8] = "s714   ";
   register int prlc, lrc;
   int rc;
   char cl, cr;
   short sl, sr;
   int il, ir;
   long ll, lr;
   unsigned ul, ur;
   float fl, fr;
   double dl, dr;
   char *ps, *pt;
   ps = qs714;
   pt = pd0->rfs;
   rc = 0;
   lrc = 0;
   prlc = pd0->flgl;
   while (*pt++ = *ps++);
	
   cl = 5; cr = 2;
   cl = cr;
   if(cl != 2){
     lrc = 1;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl = sr;
   if(cl != 2){
     lrc = 2;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl = ir;
   if(cl != 2){
     lrc = 3;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl = lr;
   if(cl != 2){
     lrc = 4;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl = ur;
   if(cl != 2){
     lrc = 5;
     if(prlc) printf(f,lrc);
   }
   cl = 5; fr = 2;
   cl = fr;
   if(cl != 2){
     lrc = 6;
     if(prlc) printf(f,lrc);
   }
   cl = 5; dr = 2;
   cl = dr;
   if(cl != 2){
     lrc = 7;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl = cr;
   if(sl != 2){
     lrc = 8;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl = sr;
   if(sl != 2){
     lrc = 9;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl = ir;
   if(sl != 2){
     lrc = 10;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl = lr;
   if(sl != 2){
     lrc = 11;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl = ur;
   if(sl != 2){
     lrc = 12;
     if(prlc) printf(f,lrc);
   }
   sl = 5; fr = 2;
   sl = fr;
   if(sl != 2){
     lrc = 13;
     if(prlc) printf(f,lrc);
   }
   sl = 5; dr = 2;
   sl = dr;
   if(sl != 2){
     lrc = 14;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il = cr;
   if(il != 2){
     lrc = 15;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il = sr;
   if(il != 2){
     lrc = 16;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il = ir;
   if(il != 2){
     lrc = 17;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il = lr;
   if(il != 2){
     lrc = 18;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il = ur;
   if(il != 2){
     lrc = 19;
     if(prlc) printf(f,lrc);
   }
   il = 5; fr = 2;
   il = fr;
   if(il != 2){
     lrc = 20;
     if(prlc) printf(f,lrc);
   }
   il = 5; dr = 2;
   il = dr;
   if(il != 2){
     lrc = 21;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll = cr;
   if(ll != 2){
     lrc = 22;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll = sr;
   if(ll != 2){
     lrc = 23;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll = ir;
   if(ll != 2){
     lrc = 24;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll = lr;
   if(ll != 2){
     lrc = 25;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll = ur;
   if(ll != 2){
     lrc = 26;
     if(prlc) printf(f,lrc);
   }
   ll = 5; fr = 2;
   ll = fr;
   if(ll != 2){
     lrc = 27;
     if(prlc) printf(f,lrc);
   }
   ll = 5; dr = 2;
   ll = dr;
   if(ll != 2){
     lrc = 28;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul = cr;
   if(ul != 2){
     lrc = 29;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul = sr;
   if(ul != 2){
     lrc = 30;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul = ir;
   if(ul != 2){
     lrc = 31;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul = lr;
   if(ul != 2){
     lrc = 32;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul = ur;
   if(ul != 2){
     lrc = 33;
     if(prlc) printf(f,lrc);
   }
   ul = 5; fr = 2;
   ul = fr;
   if(ul != 2){
     lrc = 34;
     if(prlc) printf(f,lrc);
   }
   ul = 5; dr = 2;
   ul = dr;
   if(ul != 2){
     lrc = 35;
     if(prlc) printf(f,lrc);
   }
   fl = 5; cr = 2;
   fl = cr;
   if(fl != 2){
     lrc = 36;
     if(prlc) printf(f,lrc);
   }
   fl = 5; sr = 2;
   fl = sr;
   if(fl != 2){
     lrc = 37;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ir = 2;
   fl = ir;
   if(fl != 2){
     lrc = 38;
     if(prlc) printf(f,lrc);
   }
   fl = 5; lr = 2;
   fl = lr;
   if(fl != 2){
     lrc = 39;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ur = 2;
   fl = ur;
   if(fl != 2){
     lrc = 40;
     if(prlc) printf(f,lrc);
   }
   fl = 5; fr = 2;
   fl = fr;
   if(fl != 2){
     lrc = 41;
     if(prlc) printf(f,lrc);
   }
   fl = 5; dr = 2;
   fl = dr;
   if(fl != 2){
     lrc = 42;
     if(prlc) printf(f,lrc);
   }
   dl = 5; cr = 2;
   dl = cr;
   if(dl != 2){
     lrc = 43;
     if(prlc) printf(f,lrc);
   }
   dl = 5; sr = 2;
   dl = sr;
   if(dl != 2){
     lrc = 44;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ir = 2;
   dl = ir;
   if(dl != 2){
     lrc = 45;
     if(prlc) printf(f,lrc);
   }
   dl = 5; lr = 2;
   dl = lr;
   if(dl != 2){
     lrc = 46;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ur = 2;
   dl = ur;
   if(dl != 2){
     lrc = 47;
     if(prlc) printf(f,lrc);
   }
   dl = 5; fr = 2;
   dl = fr;
   if(dl != 2){
     lrc = 48;
     if(prlc) printf(f,lrc);
   }
   dl = 5; dr = 2;
   dl = dr;
   if(dl != 2){
     lrc = 49;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl += cr;
   if(cl != 7){
     lrc = 50;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl += sr;
   if(cl != 7){
     lrc = 51;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl += ir;
   if(cl != 7){
     lrc = 52;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl += lr;
   if(cl != 7){
     lrc = 53;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl += ur;
   if(cl != 7){
     lrc = 54;
     if(prlc) printf(f,lrc);
   }
   cl = 5; fr = 2;
   cl += fr;
   if(cl != 7){
     lrc = 55;
     if(prlc) printf(f,lrc);
   }
   cl = 5; dr = 2;
   cl += dr;
   if(cl != 7){
     lrc = 56;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl += cr;
   if(sl != 7){
     lrc = 57;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl += sr;
   if(sl != 7){
     lrc = 58;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl += ir;
   if(sl != 7){
     lrc = 59;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl += lr;
   if(sl != 7){
     lrc = 60;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl += ur;
   if(sl != 7){
     lrc = 61;
     if(prlc) printf(f,lrc);
   }
   sl = 5; fr = 2;
   sl += fr;
   if(sl != 7){
     lrc = 62;
     if(prlc) printf(f,lrc);
   }
   sl = 5; dr = 2;
   sl += dr;
   if(sl != 7){
     lrc = 63;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il += cr;
   if(il != 7){
     lrc = 64;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il += sr;
   if(il != 7){
     lrc = 65;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il += ir;
   if(il != 7){
     lrc = 66;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il += lr;
   if(il != 7){
     lrc = 67;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il += ur;
   if(il != 7){
     lrc = 68;
     if(prlc) printf(f,lrc);
   }
   il = 5; fr = 2;
   il += fr;
   if(il != 7){
     lrc = 69;
     if(prlc) printf(f,lrc);
   }
   il = 5; dr = 2;
   il += dr;
   if(il != 7){
     lrc = 70;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll += cr;
   if(ll != 7){
     lrc = 71;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll += sr;
   if(ll != 7){
     lrc = 72;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll += ir;
   if(ll != 7){
     lrc = 73;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll += lr;
   if(ll != 7){
     lrc = 74;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll += ur;
   if(ll != 7){
     lrc = 75;
     if(prlc) printf(f,lrc);
   }
   ll = 5; fr = 2;
   ll += fr;
   if(ll != 7){
     lrc = 76;
     if(prlc) printf(f,lrc);
   }
   ll = 5; dr = 2;
   ll += dr;
   if(ll != 7){
     lrc = 77;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul += cr;
   if(ul != 7){
     lrc = 78;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul += sr;
   if(ul != 7){
     lrc = 79;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul += ir;
   if(ul != 7){
     lrc = 80;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul += lr;
   if(ul != 7){
     lrc = 81;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul += ur;
   if(ul != 7){
     lrc = 82;
     if(prlc) printf(f,lrc);
   }
   ul = 5; fr = 2;
   ul += fr;
   if(ul != 7){
     lrc = 83;
     if(prlc) printf(f,lrc);
   }
   ul = 5; dr = 2;
   ul += dr;
   if(ul != 7){
     lrc = 84;
     if(prlc) printf(f,lrc);
   }
   fl = 5; cr = 2;
   fl += cr;
   if(fl != 7){
     lrc = 85;
     if(prlc) printf(f,lrc);
   }
   fl = 5; sr = 2;
   fl += sr;
   if(fl != 7){
     lrc = 86;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ir = 2;
   fl += ir;
   if(fl != 7){
     lrc = 87;
     if(prlc) printf(f,lrc);
   }
   fl = 5; lr = 2;
   fl += lr;
   if(fl != 7){
     lrc = 88;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ur = 2;
   fl += ur;
   if(fl != 7){
     lrc = 89;
     if(prlc) printf(f,lrc);
   }
   fl = 5; fr = 2;
   fl += fr;
   if(fl != 7){
     lrc = 90;
     if(prlc) printf(f,lrc);
   }
   fl = 5; dr = 2;
   fl += dr;
   if(fl != 7){
     lrc = 91;
     if(prlc) printf(f,lrc);
   }
   dl = 5; cr = 2;
   dl += cr;
   if(dl != 7){
     lrc = 92;
     if(prlc) printf(f,lrc);
   }
   dl = 5; sr = 2;
   dl += sr;
   if(dl != 7){
     lrc = 93;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ir = 2;
   dl += ir;
   if(dl != 7){
     lrc = 94;
     if(prlc) printf(f,lrc);
   }
   dl = 5; lr = 2;
   dl += lr;
   if(dl != 7){
     lrc = 95;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ur = 2;
   dl += ur;
   if(dl != 7){
     lrc = 96;
     if(prlc) printf(f,lrc);
   }
   dl = 5; fr = 2;
   dl += fr;
   if(dl != 7){
     lrc = 97;
     if(prlc) printf(f,lrc);
   }
   dl = 5; dr = 2;
   dl += dr;
   if(dl != 7){
     lrc = 98;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl -= cr;
   if(cl != 3){
     lrc = 99;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl -= sr;
   if(cl != 3){
     lrc = 100;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl -= ir;
   if(cl != 3){
     lrc = 101;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl -= lr;
   if(cl != 3){
     lrc = 102;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl -= ur;
   if(cl != 3){
     lrc = 103;
     if(prlc) printf(f,lrc);
   }
   cl = 5; fr = 2;
   cl -= fr;
   if(cl != 3){
     lrc = 104;
     if(prlc) printf(f,lrc);
   }
   cl = 5; dr = 2;
   cl -= dr;
   if(cl != 3){
     lrc = 105;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl -= cr;
   if(sl != 3){
     lrc = 106;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl -= sr;
   if(sl != 3){
     lrc = 107;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl -= ir;
   if(sl != 3){
     lrc = 108;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl -= lr;
   if(sl != 3){
     lrc = 109;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl -= ur;
   if(sl != 3){
     lrc = 110;
     if(prlc) printf(f,lrc);
   }
   sl = 5; fr = 2;
   sl -= fr;
   if(sl != 3){
     lrc = 111;
     if(prlc) printf(f,lrc);
   }
   sl = 5; dr = 2;
   sl -= dr;
   if(sl != 3){
     lrc = 112;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il -= cr;
   if(il != 3){
     lrc = 113;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il -= sr;
   if(il != 3){
     lrc = 114;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il -= ir;
   if(il != 3){
     lrc = 115;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il -= lr;
   if(il != 3){
     lrc = 116;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il -= ur;
   if(il != 3){
     lrc = 117;
     if(prlc) printf(f,lrc);
   }
   il = 5; fr = 2;
   il -= fr;
   if(il != 3){
     lrc = 118;
     if(prlc) printf(f,lrc);
   }
   il = 5; dr = 2;
   il -= dr;
   if(il != 3){
     lrc = 119;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll -= cr;
   if(ll != 3){
     lrc = 120;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll -= sr;
   if(ll != 3){
     lrc = 121;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll -= ir;
   if(ll != 3){
     lrc = 122;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll -= lr;
   if(ll != 3){
     lrc = 123;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll -= ur;
   if(ll != 3){
     lrc = 124;
     if(prlc) printf(f,lrc);
   }
   ll = 5; fr = 2;
   ll -= fr;
   if(ll != 3){
     lrc = 125;
     if(prlc) printf(f,lrc);
   }
   ll = 5; dr = 2;
   ll -= dr;
   if(ll != 3){
     lrc = 126;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul -= cr;
   if(ul != 3){
     lrc = 127;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul -= sr;
   if(ul != 3){
     lrc = 128;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul -= ir;
   if(ul != 3){
     lrc = 129;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul -= lr;
   if(ul != 3){
     lrc = 130;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul -= ur;
   if(ul != 3){
     lrc = 131;
     if(prlc) printf(f,lrc);
   }
   ul = 5; fr = 2;
   ul -= fr;
   if(ul != 3){
     lrc = 132;
     if(prlc) printf(f,lrc);
   }
   ul = 5; dr = 2;
   ul -= dr;
   if(ul != 3){
     lrc = 133;
     if(prlc) printf(f,lrc);
   }
   fl = 5; cr = 2;
   fl -= cr;
   if(fl != 3){
     lrc = 134;
     if(prlc) printf(f,lrc);
   }
   fl = 5; sr = 2;
   fl -= sr;
   if(fl != 3){
     lrc = 135;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ir = 2;
   fl -= ir;
   if(fl != 3){
     lrc = 136;
     if(prlc) printf(f,lrc);
   }
   fl = 5; lr = 2;
   fl -= lr;
   if(fl != 3){
     lrc = 137;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ur = 2;
   fl -= ur;
   if(fl != 3){
     lrc = 138;
     if(prlc) printf(f,lrc);
   }
   fl = 5; fr = 2;
   fl -= fr;
   if(fl != 3){
     lrc = 139;
     if(prlc) printf(f,lrc);
   }
   fl = 5; dr = 2;
   fl -= dr;
   if(fl != 3){
     lrc = 140;
     if(prlc) printf(f,lrc);
   }
   dl = 5; cr = 2;
   dl -= cr;
   if(dl != 3){
     lrc = 141;
     if(prlc) printf(f,lrc);
   }
   dl = 5; sr = 2;
   dl -= sr;
   if(dl != 3){
     lrc = 142;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ir = 2;
   dl -= ir;
   if(dl != 3){
     lrc = 143;
     if(prlc) printf(f,lrc);
   }
   dl = 5; lr = 2;
   dl -= lr;
   if(dl != 3){
     lrc = 144;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ur = 2;
   dl -= ur;
   if(dl != 3){
     lrc = 145;
     if(prlc) printf(f,lrc);
   }
   dl = 5; fr = 2;
   dl -= fr;
   if(dl != 3){
     lrc = 146;
     if(prlc) printf(f,lrc);
   }
   dl = 5; dr = 2;
   dl -= dr;
   if(dl != 3){
     lrc = 147;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl *= cr;
   if(cl != 10){
     lrc = 148;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl *= sr;
   if(cl != 10){
     lrc = 149;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl *= ir;
   if(cl != 10){
     lrc = 150;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl *= lr;
   if(cl != 10){
     lrc = 151;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl *= ur;
   if(cl != 10){
     lrc = 152;
     if(prlc) printf(f,lrc);
   }
   cl = 5; fr = 2;
   cl *= fr;
   if(cl != 10){
     lrc = 153;
     if(prlc) printf(f,lrc);
   }
   cl = 5; dr = 2;
   cl *= dr;
   if(cl != 10){
     lrc = 154;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl *= cr;
   if(sl != 10){
     lrc = 155;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl *= sr;
   if(sl != 10){
     lrc = 156;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl *= ir;
   if(sl != 10){
     lrc = 157;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl *= lr;
   if(sl != 10){
     lrc = 158;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl *= ur;
   if(sl != 10){
     lrc = 159;
     if(prlc) printf(f,lrc);
   }
   sl = 5; fr = 2;
   sl *= fr;
   if(sl != 10){
     lrc = 160;
     if(prlc) printf(f,lrc);
   }
   sl = 5; dr = 2;
   sl *= dr;
   if(sl != 10){
     lrc = 161;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il *= cr;
   if(il != 10){
     lrc = 162;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il *= sr;
   if(il != 10){
     lrc = 163;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il *= ir;
   if(il != 10){
     lrc = 164;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il *= lr;
   if(il != 10){
     lrc = 165;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il *= ur;
   if(il != 10){
     lrc = 166;
     if(prlc) printf(f,lrc);
   }
   il = 5; fr = 2;
   il *= fr;
   if(il != 10){
     lrc = 167;
     if(prlc) printf(f,lrc);
   }
   il = 5; dr = 2;
   il *= dr;
   if(il != 10){
     lrc = 168;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll *= cr;
   if(ll != 10){
     lrc = 169;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll *= sr;
   if(ll != 10){
     lrc = 170;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll *= ir;
   if(ll != 10){
     lrc = 171;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll *= lr;
   if(ll != 10){
     lrc = 172;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll *= ur;
   if(ll != 10){
     lrc = 173;
     if(prlc) printf(f,lrc);
   }
   ll = 5; fr = 2;
   ll *= fr;
   if(ll != 10){
     lrc = 174;
     if(prlc) printf(f,lrc);
   }
   ll = 5; dr = 2;
   ll *= dr;
   if(ll != 10){
     lrc = 175;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul *= cr;
   if(ul != 10){
     lrc = 176;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul *= sr;
   if(ul != 10){
     lrc = 177;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul *= ir;
   if(ul != 10){
     lrc = 178;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul *= lr;
   if(ul != 10){
     lrc = 179;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul *= ur;
   if(ul != 10){
     lrc = 180;
     if(prlc) printf(f,lrc);
   }
   ul = 5; fr = 2;
   ul *= fr;
   if(ul != 10){
     lrc = 181;
     if(prlc) printf(f,lrc);
   }
   ul = 5; dr = 2;
   ul *= dr;
   if(ul != 10){
     lrc = 182;
     if(prlc) printf(f,lrc);
   }
   fl = 5; cr = 2;
   fl *= cr;
   if(fl != 10){
     lrc = 183;
     if(prlc) printf(f,lrc);
   }
   fl = 5; sr = 2;
   fl *= sr;
   if(fl != 10){
     lrc = 184;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ir = 2;
   fl *= ir;
   if(fl != 10){
     lrc = 185;
     if(prlc) printf(f,lrc);
   }
   fl = 5; lr = 2;
   fl *= lr;
   if(fl != 10){
     lrc = 186;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ur = 2;
   fl *= ur;
   if(fl != 10){
     lrc = 187;
     if(prlc) printf(f,lrc);
   }
   fl = 5; fr = 2;
   fl *= fr;
   if(fl != 10){
     lrc = 188;
     if(prlc) printf(f,lrc);
   }
   fl = 5; dr = 2;
   fl *= dr;
   if(fl != 10){
     lrc = 189;
     if(prlc) printf(f,lrc);
   }
   dl = 5; cr = 2;
   dl *= cr;
   if(dl != 10){
     lrc = 190;
     if(prlc) printf(f,lrc);
   }
   dl = 5; sr = 2;
   dl *= sr;
   if(dl != 10){
     lrc = 191;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ir = 2;
   dl *= ir;
   if(dl != 10){
     lrc = 192;
     if(prlc) printf(f,lrc);
   }
   dl = 5; lr = 2;
   dl *= lr;
   if(dl != 10){
     lrc = 193;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ur = 2;
   dl *= ur;
   if(dl != 10){
     lrc = 194;
     if(prlc) printf(f,lrc);
   }
   dl = 5; fr = 2;
   dl *= fr;
   if(dl != 10){
     lrc = 195;
     if(prlc) printf(f,lrc);
   }
   dl = 5; dr = 2;
   dl *= dr;
   if(dl != 10){
     lrc = 196;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl /= cr;
   if(cl != 2){
     lrc = 197;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl /= sr;
   if(cl != 2){
     lrc = 198;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl /= ir;
   if(cl != 2){
     lrc = 199;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl /= lr;
   if(cl != 2){
     lrc = 200;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl /= ur;
   if(cl != 2){
     lrc = 201;
     if(prlc) printf(f,lrc);
   }
   cl = 5; fr = 2;
   cl /= fr;
   if(cl != 2){
     lrc = 202;
     if(prlc) printf(f,lrc);
   }
   cl = 5; dr = 2;
   cl /= dr;
   if(cl != 2){
     lrc = 203;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl /= cr;
   if(sl != 2){
     lrc = 204;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl /= sr;
   if(sl != 2){
     lrc = 205;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl /= ir;
   if(sl != 2){
     lrc = 206;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl /= lr;
   if(sl != 2){
     lrc = 207;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl /= ur;
   if(sl != 2){
     lrc = 208;
     if(prlc) printf(f,lrc);
   }
   sl = 5; fr = 2;
   sl /= fr;
   if(sl != 2){
     lrc = 209;
     if(prlc) printf(f,lrc);
   }
   sl = 5; dr = 2;
   sl /= dr;
   if(sl != 2){
     lrc = 210;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il /= cr;
   if(il != 2){
     lrc = 211;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il /= sr;
   if(il != 2){
     lrc = 212;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il /= ir;
   if(il != 2){
     lrc = 213;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il /= lr;
   if(il != 2){
     lrc = 214;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il /= ur;
   if(il != 2){
     lrc = 215;
     if(prlc) printf(f,lrc);
   }
   il = 5; fr = 2;
   il /= fr;
   if(il != 2){
     lrc = 216;
     if(prlc) printf(f,lrc);
   }
   il = 5; dr = 2;
   il /= dr;
   if(il != 2){
     lrc = 217;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll /= cr;
   if(ll != 2){
     lrc = 218;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll /= sr;
   if(ll != 2){
     lrc = 219;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll /= ir;
   if(ll != 2){
     lrc = 220;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll /= lr;
   if(ll != 2){
     lrc = 221;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll /= ur;
   if(ll != 2){
     lrc = 222;
     if(prlc) printf(f,lrc);
   }
   ll = 5; fr = 2;
   ll /= fr;
   if(ll != 2){
     lrc = 223;
     if(prlc) printf(f,lrc);
   }
   ll = 5; dr = 2;
   ll /= dr;
   if(ll != 2){
     lrc = 224;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul /= cr;
   if(ul != 2){
     lrc = 225;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul /= sr;
   if(ul != 2){
     lrc = 226;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul /= ir;
   if(ul != 2){
     lrc = 227;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul /= lr;
   if(ul != 2){
     lrc = 228;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul /= ur;
   if(ul != 2){
     lrc = 229;
     if(prlc) printf(f,lrc);
   }
   ul = 5; fr = 2;
   ul /= fr;
   if(ul != 2){
     lrc = 230;
     if(prlc) printf(f,lrc);
   }
   ul = 5; dr = 2;
   ul /= dr;
   if(ul != 2){
     lrc = 231;
     if(prlc) printf(f,lrc);
   }
   fl = 5; cr = 2;
   fl /= cr;
   if(fl != 2.5){
     lrc = 232;
     if(prlc) printf(f,lrc);
   }
   fl = 5; sr = 2;
   fl /= sr;
   if(fl != 2.5){
     lrc = 233;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ir = 2;
   fl /= ir;
   if(fl != 2.5){
     lrc = 234;
     if(prlc) printf(f,lrc);
   }
   fl = 5; lr = 2;
   fl /= lr;
   if(fl != 2.5){
     lrc = 235;
     if(prlc) printf(f,lrc);
   }
   fl = 5; ur = 2;
   fl /= ur;
   if(fl != 2.5){
     lrc = 236;
     if(prlc) printf(f,lrc);
   }
   fl = 5; fr = 2;
   fl /= fr;
   if(fl != 2.5){
     lrc = 237;
     if(prlc) printf(f,lrc);
   }
   fl = 5; dr = 2;
   fl /= dr;
   if(fl != 2.5){
     lrc = 238;
     if(prlc) printf(f,lrc);
   }
   dl = 5; cr = 2;
   dl /= cr;
   if(dl != 2.5){
     lrc = 239;
     if(prlc) printf(f,lrc);
   }
   dl = 5; sr = 2;
   dl /= sr;
   if(dl != 2.5){
     lrc = 240;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ir = 2;
   dl /= ir;
   if(dl != 2.5){
     lrc = 241;
     if(prlc) printf(f,lrc);
   }
   dl = 5; lr = 2;
   dl /= lr;
   if(dl != 2.5){
     lrc = 242;
     if(prlc) printf(f,lrc);
   }
   dl = 5; ur = 2;
   dl /= ur;
   if(dl != 2.5){
     lrc = 243;
     if(prlc) printf(f,lrc);
   }
   dl = 5; fr = 2;
   dl /= fr;
   if(dl != 2.5){
     lrc = 244;
     if(prlc) printf(f,lrc);
   }
   dl = 5; dr = 2;
   dl /= dr;
   if(dl != 2.5){
     lrc = 245;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl %= cr;
   if(cl != 1){
     lrc = 246;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl %= sr;
   if(cl != 1){
     lrc = 247;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl %= ir;
   if(cl != 1){
     lrc = 248;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl %= lr;
   if(cl != 1){
     lrc = 249;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl %= ur;
   if(cl != 1){
     lrc = 250;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl %= cr;
   if(sl != 1){
     lrc = 251;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl %= sr;
   if(sl != 1){
     lrc = 252;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl %= ir;
   if(sl != 1){
     lrc = 253;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl %= lr;
   if(sl != 1){
     lrc = 254;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl %= ur;
   if(sl != 1){
     lrc = 255;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il %= cr;
   if(il != 1){
     lrc = 256;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il %= sr;
   if(il != 1){
     lrc = 257;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il %= ir;
   if(il != 1){
     lrc = 258;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il %= lr;
   if(il != 1){
     lrc = 259;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il %= ur;
   if(il != 1){
     lrc = 260;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll %= cr;
   if(ll != 1){
     lrc = 261;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll %= sr;
   if(ll != 1){
     lrc = 262;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll %= ir;
   if(ll != 1){
     lrc = 263;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll %= lr;
   if(ll != 1){
     lrc = 264;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll %= ur;
   if(ll != 1){
     lrc = 265;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul %= cr;
   if(ul != 1){
     lrc = 266;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul %= sr;
   if(ul != 1){
     lrc = 267;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul %= ir;
   if(ul != 1){
     lrc = 268;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul %= lr;
   if(ul != 1){
     lrc = 269;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul %= ur;
   if(ul != 1){
     lrc = 270;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl >>= cr;
   if(cl != 1){
     lrc = 271;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl >>= sr;
   if(cl != 1){
     lrc = 272;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl >>= ir;
   if(cl != 1){
     lrc = 273;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl >>= lr;
   if(cl != 1){
     lrc = 274;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl >>= ur;
   if(cl != 1){
     lrc = 275;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl >>= cr;
   if(sl != 1){
     lrc = 276;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl >>= sr;
   if(sl != 1){
     lrc = 277;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl >>= ir;
   if(sl != 1){
     lrc = 278;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl >>= lr;
   if(sl != 1){
     lrc = 279;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl >>= ur;
   if(sl != 1){
     lrc = 280;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il >>= cr;
   if(il != 1){
     lrc = 281;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il >>= sr;
   if(il != 1){
     lrc = 282;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il >>= ir;
   if(il != 1){
     lrc = 283;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il >>= lr;
   if(il != 1){
     lrc = 284;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il >>= ur;
   if(il != 1){
     lrc = 285;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll >>= cr;
   if(ll != 1){
     lrc = 286;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll >>= sr;
   if(ll != 1){
     lrc = 287;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll >>= ir;
   if(ll != 1){
     lrc = 288;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll >>= lr;
   if(ll != 1){
     lrc = 289;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll >>= ur;
   if(ll != 1){
     lrc = 290;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul >>= cr;
   if(ul != 1){
     lrc = 291;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul >>= sr;
   if(ul != 1){
     lrc = 292;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul >>= ir;
   if(ul != 1){
     lrc = 293;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul >>= lr;
   if(ul != 1){
     lrc = 294;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul >>= ur;
   if(ul != 1){
     lrc = 295;
     if(prlc) printf(f,lrc);
   }
   cl = 5; cr = 2;
   cl <<= cr;
   if(cl != 20){
     lrc = 296;
     if(prlc) printf(f,lrc);
   }
   cl = 5; sr = 2;
   cl <<= sr;
   if(cl != 20){
     lrc = 297;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ir = 2;
   cl <<= ir;
   if(cl != 20){
     lrc = 298;
     if(prlc) printf(f,lrc);
   }
   cl = 5; lr = 2;
   cl <<= lr;
   if(cl != 20){
     lrc = 299;
     if(prlc) printf(f,lrc);
   }
   cl = 5; ur = 2;
   cl <<= ur;
   if(cl != 20){
     lrc = 300;
     if(prlc) printf(f,lrc);
   }
   sl = 5; cr = 2;
   sl <<= cr;
   if(sl != 20){
     lrc = 301;
     if(prlc) printf(f,lrc);
   }
   sl = 5; sr = 2;
   sl <<= sr;
   if(sl != 20){
     lrc = 302;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ir = 2;
   sl <<= ir;
   if(sl != 20){
     lrc = 303;
     if(prlc) printf(f,lrc);
   }
   sl = 5; lr = 2;
   sl <<= lr;
   if(sl != 20){
     lrc = 304;
     if(prlc) printf(f,lrc);
   }
   sl = 5; ur = 2;
   sl <<= ur;
   if(sl != 20){
     lrc = 305;
     if(prlc) printf(f,lrc);
   }
   il = 5; cr = 2;
   il <<= cr;
   if(il != 20){
     lrc = 306;
     if(prlc) printf(f,lrc);
   }
   il = 5; sr = 2;
   il <<= sr;
   if(il != 20){
     lrc = 307;
     if(prlc) printf(f,lrc);
   }
   il = 5; ir = 2;
   il <<= ir;
   if(il != 20){
     lrc = 308;
     if(prlc) printf(f,lrc);
   }
   il = 5; lr = 2;
   il <<= lr;
   if(il != 20){
     lrc = 309;
     if(prlc) printf(f,lrc);
   }
   il = 5; ur = 2;
   il <<= ur;
   if(il != 20){
     lrc = 310;
     if(prlc) printf(f,lrc);
   }
   ll = 5; cr = 2;
   ll <<= cr;
   if(ll != 20){
     lrc = 311;
     if(prlc) printf(f,lrc);
   }
   ll = 5; sr = 2;
   ll <<= sr;
   if(ll != 20){
     lrc = 312;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ir = 2;
   ll <<= ir;
   if(ll != 20){
     lrc = 313;
     if(prlc) printf(f,lrc);
   }
   ll = 5; lr = 2;
   ll <<= lr;
   if(ll != 20){
     lrc = 314;
     if(prlc) printf(f,lrc);
   }
   ll = 5; ur = 2;
   ll <<= ur;
   if(ll != 20){
     lrc = 315;
     if(prlc) printf(f,lrc);
   }
   ul = 5; cr = 2;
   ul <<= cr;
   if(ul != 20){
     lrc = 316;
     if(prlc) printf(f,lrc);
   }
   ul = 5; sr = 2;
   ul <<= sr;
   if(ul != 20){
     lrc = 317;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ir = 2;
   ul <<= ir;
   if(ul != 20){
     lrc = 318;
     if(prlc) printf(f,lrc);
   }
   ul = 5; lr = 2;
   ul <<= lr;
   if(ul != 20){
     lrc = 319;
     if(prlc) printf(f,lrc);
   }
   ul = 5; ur = 2;
   ul <<= ur;
   if(ul != 20){
     lrc = 320;
     if(prlc) printf(f,lrc);
   }
   cl = 12; cr = 10;
   cl &= cr;
   if(cl != 8){
     lrc = 321;
     if(prlc) printf(f,lrc);
   }
   cl = 12; sr = 10;
   cl &= sr;
   if(cl != 8){
     lrc = 322;
     if(prlc) printf(f,lrc);
   }
   cl = 12; ir = 10;
   cl &= ir;
   if(cl != 8){
     lrc = 323;
     if(prlc) printf(f,lrc);
   }
   cl = 12; lr = 10;
   cl &= lr;
   if(cl != 8){
     lrc = 324;
     if(prlc) printf(f,lrc);
   }
   cl = 12; ur = 10;
   cl &= ur;
   if(cl != 8){
     lrc = 325;
     if(prlc) printf(f,lrc);
   }
   sl = 12; cr = 10;
   sl &= cr;
   if(sl != 8){
     lrc = 326;
     if(prlc) printf(f,lrc);
   }
   sl = 12; sr = 10;
   sl &= sr;
   if(sl != 8){
     lrc = 327;
     if(prlc) printf(f,lrc);
   }
   sl = 12; ir = 10;
   sl &= ir;
   if(sl != 8){
     lrc = 328;
     if(prlc) printf(f,lrc);
   }
   sl = 12; lr = 10;
   sl &= lr;
   if(sl != 8){
     lrc = 329;
     if(prlc) printf(f,lrc);
   }
   sl = 12; ur = 10;
   sl &= ur;
   if(sl != 8){
     lrc = 330;
     if(prlc) printf(f,lrc);
   }
   il = 12; cr = 10;
   il &= cr;
   if(il != 8){
     lrc = 331;
     if(prlc) printf(f,lrc);
   }
   il = 12; sr = 10;
   il &= sr;
   if(il != 8){
     lrc = 332;
     if(prlc) printf(f,lrc);
   }
   il = 12; ir = 10;
   il &= ir;
   if(il != 8){
     lrc = 333;
     if(prlc) printf(f,lrc);
   }
   il = 12; lr = 10;
   il &= lr;
   if(il != 8){
     lrc = 334;
     if(prlc) printf(f,lrc);
   }
   il = 12; ur = 10;
   il &= ur;
   if(il != 8){
     lrc = 335;
     if(prlc) printf(f,lrc);
   }
   ll = 12; cr = 10;
   ll &= cr;
   if(ll != 8){
     lrc = 336;
     if(prlc) printf(f,lrc);
   }
   ll = 12; sr = 10;
   ll &= sr;
   if(ll != 8){
     lrc = 337;
     if(prlc) printf(f,lrc);
   }
   ll = 12; ir = 10;
   ll &= ir;
   if(ll != 8){
     lrc = 338;
     if(prlc) printf(f,lrc);
   }
   ll = 12; lr = 10;
   ll &= lr;
   if(ll != 8){
     lrc = 339;
     if(prlc) printf(f,lrc);
   }
   ll = 12; ur = 10;
   ll &= ur;
   if(ll != 8){
     lrc = 340;
     if(prlc) printf(f,lrc);
   }
   ul = 12; cr = 10;
   ul &= cr;
   if(ul != 8){
     lrc = 341;
     if(prlc) printf(f,lrc);
   }
   ul = 12; sr = 10;
   ul &= sr;
   if(ul != 8){
     lrc = 342;
     if(prlc) printf(f,lrc);
   }
   ul = 12; ir = 10;
   ul &= ir;
   if(ul != 8){
     lrc = 343;
     if(prlc) printf(f,lrc);
   }
   ul = 12; lr = 10;
   ul &= lr;
   if(ul != 8){
     lrc = 344;
     if(prlc) printf(f,lrc);
   }
   ul = 12; ur = 10;
   ul &= ur;
   if(ul != 8){
     lrc = 345;
     if(prlc) printf(f,lrc);
   }
   cl = 12; cr = 10;
   cl ^= cr;
   if(cl != 6){
     lrc = 346;
     if(prlc) printf(f,lrc);
   }
   cl = 12; sr = 10;
   cl ^= sr;
   if(cl != 6){
     lrc = 347;
     if(prlc) printf(f,lrc);
   }
   cl = 12; ir = 10;
   cl ^= ir;
   if(cl != 6){
     lrc = 348;
     if(prlc) printf(f,lrc);
   }
   cl = 12; lr = 10;
   cl ^= lr;
   if(cl != 6){
     lrc = 349;
     if(prlc) printf(f,lrc);
   }
   cl = 12; ur = 10;
   cl ^= ur;
   if(cl != 6){
     lrc = 350;
     if(prlc) printf(f,lrc);
   }
   sl = 12; cr = 10;
   sl ^= cr;
   if(sl != 6){
     lrc = 351;
     if(prlc) printf(f,lrc);
   }
   sl = 12; sr = 10;
   sl ^= sr;
   if(sl != 6){
     lrc = 352;
     if(prlc) printf(f,lrc);
   }
   sl = 12; ir = 10;
   sl ^= ir;
   if(sl != 6){
     lrc = 353;
     if(prlc) printf(f,lrc);
   }
   sl = 12; lr = 10;
   sl ^= lr;
   if(sl != 6){
     lrc = 354;
     if(prlc) printf(f,lrc);
   }
   sl = 12; ur = 10;
   sl ^= ur;
   if(sl != 6){
     lrc = 355;
     if(prlc) printf(f,lrc);
   }
   il = 12; cr = 10;
   il ^= cr;
   if(il != 6){
     lrc = 356;
     if(prlc) printf(f,lrc);
   }
   il = 12; sr = 10;
   il ^= sr;
   if(il != 6){
     lrc = 357;
     if(prlc) printf(f,lrc);
   }
   il = 12; ir = 10;
   il ^= ir;
   if(il != 6){
     lrc = 358;
     if(prlc) printf(f,lrc);
   }
   il = 12; lr = 10;
   il ^= lr;
   if(il != 6){
     lrc = 359;
     if(prlc) printf(f,lrc);
   }
   il = 12; ur = 10;
   il ^= ur;
   if(il != 6){
     lrc = 360;
     if(prlc) printf(f,lrc);
   }
   ll = 12; cr = 10;
   ll ^= cr;
   if(ll != 6){
     lrc = 361;
     if(prlc) printf(f,lrc);
   }
   ll = 12; sr = 10;
   ll ^= sr;
   if(ll != 6){
     lrc = 362;
     if(prlc) printf(f,lrc);
   }
   ll = 12; ir = 10;
   ll ^= ir;
   if(ll != 6){
     lrc = 363;
     if(prlc) printf(f,lrc);
   }
   ll = 12; lr = 10;
   ll ^= lr;
   if(ll != 6){
     lrc = 364;
     if(prlc) printf(f,lrc);
   }
   ll = 12; ur = 10;
   ll ^= ur;
   if(ll != 6){
     lrc = 365;
     if(prlc) printf(f,lrc);
   }
   ul = 12; cr = 10;
   ul ^= cr;
   if(ul != 6){
     lrc = 366;
     if(prlc) printf(f,lrc);
   }
   ul = 12; sr = 10;
   ul ^= sr;
   if(ul != 6){
     lrc = 367;
     if(prlc) printf(f,lrc);
   }
   ul = 12; ir = 10;
   ul ^= ir;
   if(ul != 6){
     lrc = 368;
     if(prlc) printf(f,lrc);
   }
   ul = 12; lr = 10;
   ul ^= lr;
   if(ul != 6){
     lrc = 369;
     if(prlc) printf(f,lrc);
   }
   ul = 12; ur = 10;
   ul ^= ur;
   if(ul != 6){
     lrc = 370;
     if(prlc) printf(f,lrc);
   }
   cl = 12; cr = 10;
   cl |= cr;
   if(cl != 14){
     lrc = 371;
     if(prlc) printf(f,lrc);
   }
   cl = 12; sr = 10;
   cl |= sr;
   if(cl != 14){
     lrc = 372;
     if(prlc) printf(f,lrc);
   }
   cl = 12; ir = 10;
   cl |= ir;
   if(cl != 14){
     lrc = 373;
     if(prlc) printf(f,lrc);
   }
   cl = 12; lr = 10;
   cl |= lr;
   if(cl != 14){
     lrc = 374;
     if(prlc) printf(f,lrc);
   }
   cl = 12; ur = 10;
   cl |= ur;
   if(cl != 14){
     lrc = 375;
     if(prlc) printf(f,lrc);
   }
   sl = 12; cr = 10;
   sl |= cr;
   if(sl != 14){
     lrc = 376;
     if(prlc) printf(f,lrc);
   }
   sl = 12; sr = 10;
   sl |= sr;
   if(sl != 14){
     lrc = 377;
     if(prlc) printf(f,lrc);
   }
   sl = 12; ir = 10;
   sl |= ir;
   if(sl != 14){
     lrc = 378;
     if(prlc) printf(f,lrc);
   }
   sl = 12; lr = 10;
   sl |= lr;
   if(sl != 14){
     lrc = 379;
     if(prlc) printf(f,lrc);
   }
   sl = 12; ur = 10;
   sl |= ur;
   if(sl != 14){
     lrc = 380;
     if(prlc) printf(f,lrc);
   }
   il = 12; cr = 10;
   il |= cr;
   if(il != 14){
     lrc = 381;
     if(prlc) printf(f,lrc);
   }
   il = 12; sr = 10;
   il |= sr;
   if(il != 14){
     lrc = 382;
     if(prlc) printf(f,lrc);
   }
   il = 12; ir = 10;
   il |= ir;
   if(il != 14){
     lrc = 383;
     if(prlc) printf(f,lrc);
   }
   il = 12; lr = 10;
   il |= lr;
   if(il != 14){
     lrc = 384;
     if(prlc) printf(f,lrc);
   }
   il = 12; ur = 10;
   il |= ur;
   if(il != 14){
     lrc = 385;
     if(prlc) printf(f,lrc);
   }
   ll = 12; cr = 10;
   ll |= cr;
   if(ll != 14){
     lrc = 386;
     if(prlc) printf(f,lrc);
   }
   ll = 12; sr = 10;
   ll |= sr;
   if(ll != 14){
     lrc = 387;
     if(prlc) printf(f,lrc);
   }
   ll = 12; ir = 10;
   ll |= ir;
   if(ll != 14){
     lrc = 388;
     if(prlc) printf(f,lrc);
   }
   ll = 12; lr = 10;
   ll |= lr;
   if(ll != 14){
     lrc = 389;
     if(prlc) printf(f,lrc);
   }
   ll = 12; ur = 10;
   ll |= ur;
   if(ll != 14){
     lrc = 390;
     if(prlc) printf(f,lrc);
   }
   ul = 12; cr = 10;
   ul |= cr;
   if(ul != 14){
     lrc = 391;
     if(prlc) printf(f,lrc);
   }
   ul = 12; sr = 10;
   ul |= sr;
   if(ul != 14){
     lrc = 392;
     if(prlc) printf(f,lrc);
   }
   ul = 12; ir = 10;
   ul |= ir;
   if(ul != 14){
     lrc = 393;
     if(prlc) printf(f,lrc);
   }
   ul = 12; lr = 10;
   ul |= lr;
   if(ul != 14){
     lrc = 394;
     if(prlc) printf(f,lrc);
   }
   ul = 12; ur = 10;
   ul |= ur;
   if(ul != 14){
     lrc = 395;
     if(prlc) printf(f,lrc);
   }
   if(lrc != 0) {
     rc = 1;
     if(pd0->flgd != 0) printf(s714er,1);
   }
   return rc;
}

