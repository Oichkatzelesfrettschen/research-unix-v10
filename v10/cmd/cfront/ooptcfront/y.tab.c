
# line 24 "gram.y"
#include "cfront.h"
#include "size.h"
#include "template.h"
#include <string.h>

#define copy_if_need_be(s)  ((templp->in_progress || templp->parameters_in_progress) ? strdup(s) : s) 

extern int ansi_opt;
#define YYMAXDEPTH 600

static init_seen = 0;
static cdi = 0;
static Pnlist cd = 0, cd_vec[BLMAX];
static char stmt_seen = 0, stmt_vec[BLMAX];

//local class
//static Plist tn_vec[BLMAX];
extern Plist local_blk; // put in cfront.h
static Plist tn_vec[BLMAX], lcl_tn_vec[BLMAX], lcl_blk_vec[BLMAX];
extern void local_restore();
extern void local_name();

static Pname err_name = 0;

// fcts put into norm2.c just to get them out of gram.y
void sig_name(Pname);	
Ptype tok_to_type(TOK);
void memptrdcl(Pname, Pname, Ptype, Pname);

static Pptr doptr(TOK p, TOK t)
{
	Pptr r = new ptr(p,0);
	switch (t) {
	case CONST:
		r->rdo = 1;
               // if (p == RPTR) error('w',"redundant `const' after &");
		break;
	case VOLATILE:
		error('w',"\"volatile\" not implemented (ignored)");
		break;
	default:
		error("syntax error: *%k",t);
	}
	return r;
}

static Pbcl dobase(TOK pr, Pname n, TOK v = 0)
{
	Pbcl b = new basecl(0,0);

	if (pr == PROTECTED) {
		pr = PUBLIC;
		error("protectedBC");
	}
	b->ppp = pr;	// save protection indicator

	if (n) {
		if (n->base != TNAME) {
			error("BN%n not aTN",n);
			return 0;
		}

		Pbase bt = Pbase(n->tp);
		while (bt->base == TYPE) bt = Pbase(bt->b_name->tp);

		if (bt->base != COBJ) {
			error("BN%n not aCN",n);
			return 0;
		}

		if (v) {
			if (v != VIRTUAL) error("syntax error:%k inBCD",v);
			b->base = VIRTUAL;
		}
		else
			b->base = NAME;

		b->bclass = Pclass(bt->b_name->tp);
	}

	return b;
}

#define lex_unget(x) back = x

#define Ndata(a,b)	b->normalize(Pbase(a),0,0)
#define Ncast(a,b)	b->normalize(Pbase(a),0,1)
#define Nfct(a,b,c)	b->normalize(Pbase(a),Pblock(c),0)
#define Ncopy(n)	(n->base==TNAME)?new name(n->string):n

#define Finit(p)	Pfct(p)->f_init
#define Fargdcl(p,q,r)	Pfct(p)->argdcl(q,r)
#define Freturns(p)	Pfct(p)->returns
#define Vtype(v)	Pvec(v)->typ
#define Ptyp(p)		Pptr(p)->typ

		/* avoid redefinitions */
#undef EOFTOK
#undef ASM
#undef BREAK
#undef CASE
#undef CONTINUE
#undef DEFAULT
#undef DELETE
#undef DO
#undef ELSE
#undef ENUM
#undef FOR
#undef FORTRAN
#undef FRIEND
#undef GOTO
#undef IF
#undef NEW
#undef OPERATOR
#undef RETURN
#undef SIZEOF
#undef SWITCH
#undef THIS
#undef WHILE
#undef LP
#undef RP
#undef LB
#undef RB
#undef REF
#undef DOT
#undef NOT
#undef COMPL
#undef MUL
#undef AND
#undef PLUS
#undef MINUS
#undef ER
#undef OR
#undef ANDAND
#undef OROR
#undef QUEST
#undef COLON
#undef ASSIGN
#undef CM
#undef SM
#undef LC
#undef RC
#undef ID
#undef STRING
#undef ICON
#undef FCON
#undef CCON
#undef ZERO
#undef ASOP
#undef RELOP
#undef EQUOP
#undef DIVOP
#undef SHIFTOP
#undef ICOP
#undef TYPE
#undef TNAME
#undef EMPTY
#undef NO_ID
#undef NO_EXPR
#undef FDEF
#undef ELLIPSIS
#undef AGGR
#undef MEM
#undef MEMPTR
#undef PR
#undef TSCOPE
#undef DECL_MARKER
#undef REFMUL
#undef LDOUBLE
#undef LINKAGE
#undef LOCAL
#undef TEMPLATE

#undef XVIRT
#undef XNLIST
#undef XILINE
#undef XIA
#undef STATEMENT
#undef EXPRESSION
#undef SM_PARAM
#undef TEMPLATE_TEST
#undef PTNAME
#undef NEW_INIT_KLUDGE

# line 209 "gram.y"
typedef union  {
	char*	s;
	TOK	t;
	int	i;
	loc	l;
	Pname	pn;
	Ptype	pt;
	Pexpr	pe;
	Pstmt	ps;
	Pbase	pb;
	Pnlist	nl;
	Pslist	sl;
	Pelist	el;
	Pbcl	pbc;
	Pptr	pp;
	PP	p;	// fudge: pointer to all class node objects
} YYSTYPE;

# line 227 "gram.y"
extern YYSTYPE yylval, yyval;
extern int yyparse();

// interface to lalex/tlex
extern TOK	la_look();
extern void	la_backup( TOK, YYSTYPE );
extern int	la_cast();
extern int	la_decl();
extern TOK	lalex();

extern int	declTag;	 // !1: inline, virtual mod permitted
Ptype 		in_typedef = 0;  // catch redefinition of TNAME
Pname		in_tag = 0;      // handle complex typedefs: int (*)()
extern int	defer_check;	 // redefinition typedef check delay

extern int 	must_be_id;	 // !0, TNAME => ID, i.e., int X
extern int 	must_be_expr;	 // in constructor base class/const member
				 // expression list.
int 		DECL_TYPE = 0; 	 // lalex() wants this set for global x(*fp)()
int 		in_arg_list=0; 	 // !0 when parsing argument list
int 		in_class_decl=0; // !0 when parsing class definition
int 		in_mem_fct=0;    // !0 when parsing member function definition

#define yylex lalex
#define NEXTTOK() ( (yychar==-1) ? (yychar=yylex(),yychar) : yychar )
#define EXPECT_ID() must_be_id = 1
#define NOT_EXPECT_ID() must_be_id = 0

Pname syn()
{
ll:
	switch (yyparse()) {
	case 0:		return 0;	// EOF
	case 1:		goto ll;	// no action needed
	default:	return yyval.pn;
	}
}

# define EOFTOK 0
# define ASM 1
# define AUTO 2
# define BREAK 3
# define CASE 4
# define CONTINUE 7
# define DEFAULT 8
# define DELETE 9
# define DO 10
# define ELSE 12
# define ENUM 13
# define FOR 16
# define FORTRAN 17
# define FRIEND 18
# define GOTO 19
# define IF 20
# define NEW 23
# define OPERATOR 24
# define RETURN 28
# define SIZEOF 30
# define SWITCH 33
# define THIS 34
# define WHILE 39
# define LP 40
# define RP 41
# define LB 42
# define RB 43
# define REF 44
# define DOT 45
# define NOT 46
# define COMPL 47
# define MUL 50
# define AND 52
# define PLUS 54
# define MINUS 55
# define LT 58
# define GT 60
# define ER 64
# define OR 65
# define ANDAND 66
# define OROR 67
# define QUEST 68
# define COLON 69
# define ASSIGN 70
# define CM 71
# define SM 72
# define LC 73
# define RC 74
# define ID 80
# define STRING 81
# define ICON 82
# define FCON 83
# define CCON 84
# define NAME 85
# define ZERO 86
# define ASOP 90
# define RELOP 91
# define EQUOP 92
# define DIVOP 93
# define SHIFTOP 94
# define ICOP 95
# define TYPE 97
# define TNAME 123
# define EMPTY 124
# define NO_ID 125
# define NO_EXPR 126
# define FDEF 127
# define ELLIPSIS 155
# define AGGR 156
# define MEM 160
# define MEMPTR 173
# define PR 175
# define TSCOPE 178
# define DECL_MARKER 179
# define REFMUL 180
# define LDOUBLE 181
# define LINKAGE 182
# define LOCAL 183
# define TEMPLATE 185
# define XVIRT 200
# define XNLIST 201
# define XILINE 202
# define XIA 203
# define STATEMENT 205
# define EXPRESSION 206
# define SM_PARAM 207
# define TEMPLATE_TEST 208
# define PTNAME 209
# define NEW_INIT_KLUDGE 210
# define XDELETED_NODE 211
# define DUMMY_LAST_NODE 212
# define PATHOF 348
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern short yyerrflag;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256

# line 1917 "gram.y"



static void
check_cast()
/*
	Lookahead to direct parsing of cast
	la_cast() returns 1 if lookahead sees an ambiguous old-style C cast.
*/
{
	switch( NEXTTOK() ) {
	case TYPE: case TNAME:
	    if ( la_look() == LP && la_cast() ) {
		must_be_id = 0;
		yychar = DECL_MARKER;
	    }
	}
}

static void
check_decl()
/*
	Lookahead to direct parsing of local/arg type declarations
	la_decl() returns 1 if lookahead sees a declaration.
*/
{

	switch( NEXTTOK() ) {
	case TYPE: case TNAME:
	    if ( la_look() == LP && la_decl() ) {
		must_be_id = 0;
		DECL_TYPE=yychar;
		yychar = DECL_MARKER;
	    }
	}
}

static void
check_tag()
/*
        Allow the case of inline/virtual/overload as 
        modifiers of return type of form struct/class/union x foo() 
        SM, COLON, LC ==> real class declaration, not return type
*/
{
	switch ( NEXTTOK() ) {
	case SM: case COLON: case LC:
    		declTag = 1;
    		break;
	default:
    		declTag = 0;
    		break;
        }
}

short yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 26,
	40, 48,
	42, 48,
	46, 48,
	-2, 53,
-1, 51,
	71, 38,
	72, 38,
	-2, 37,
-1, 67,
	155, 359,
	-2, 294,
-1, 72,
	13, 353,
	97, 353,
	123, 353,
	155, 353,
	156, 353,
	179, 353,
	182, 353,
	-2, 294,
-1, 126,
	73, 95,
	-2, 91,
-1, 277,
	13, 344,
	97, 344,
	123, 344,
	156, 344,
	179, 344,
	182, 344,
	-2, 294,
-1, 299,
	1, 194,
	3, 194,
	4, 194,
	7, 194,
	8, 194,
	9, 194,
	10, 194,
	13, 194,
	16, 194,
	19, 194,
	20, 194,
	23, 194,
	24, 194,
	28, 194,
	30, 194,
	33, 194,
	34, 194,
	39, 194,
	40, 194,
	46, 194,
	47, 194,
	50, 194,
	52, 194,
	54, 194,
	55, 194,
	72, 194,
	73, 194,
	80, 194,
	81, 194,
	82, 194,
	83, 194,
	84, 194,
	85, 194,
	86, 194,
	95, 194,
	97, 194,
	123, 194,
	156, 194,
	160, 194,
	178, 194,
	179, 194,
	182, 194,
	207, 194,
	209, 194,
	-2, 0,
-1, 324,
	40, 49,
	42, 49,
	46, 49,
	-2, 54,
-1, 353,
	60, 20,
	71, 20,
	-2, 106,
-1, 354,
	60, 19,
	71, 19,
	-2, 105,
-1, 385,
	13, 344,
	97, 344,
	123, 344,
	156, 344,
	179, 344,
	182, 344,
	-2, 294,
	};
# define YYNPROD 374
# define YYLAST 3034
short yyact[]={

 188, 506, 148, 547, 498, 485, 175,   9, 205,  16,
  48, 339,  68, 150,  64, 505,  10,  11, 301, 395,
 182, 356, 233, 161, 327, 227, 202, 203,  65,  89,
 315,  90,  73, 404, 185, 226, 122, 159, 186, 123,
  74,  24, 324,  60,  20, 310, 400,  49,  71,  88,
 397, 225,  34, 174,  35, 211, 303,  24,  67, 201,
  34, 462,  35, 145,  24,  24, 139,  78,  73, 302,
 192, 610, 123, 177, 129, 292, 190, 122,  85,  22,
 131, 354, 357, 190,  71, 322, 204, 130, 204, 514,
  50, 307,  67, 194, 214,  73, 135, 124, 293,  83,
  38, 121,  80,  36,  12, 120, 136,  83, 126, 304,
  34,  71,  35, 144,  30, 573, 228, 486, 457,  36,
 197, 129,  67, 414, 353,  67,  36,  36, 130, 311,
 134, 130, 217, 544,  16, 345, 204, 489, 436, 204,
 316, 218, 299, 219, 244, 204, 236, 206, 177, 264,
 132, 558,  61, 279, 280, 281, 282, 283, 284, 285,
 286, 287, 289, 275, 169,  33,  24, 296,  32, 249,
 290, 127, 288, 278, 134,  37, 298, 276, 170, 241,
 128,  33,  24,  37, 337, 242, 133,  76,  33,  33,
  28,  31,  17, 240, 564, 230, 280,  27, 239, 229,
 294,  45, 295, 345, 245, 222, 344,  57, 546,  51,
 313,  44, 255, 397,  56, 405,  81,  84,  24,  44,
 213, 141, 142,  34, 198,  35, 204, 128,  36, 326,
 220, 318, 306,  37, 168, 442, 304,  24, 427,  30,
 325,  30, 360, 426,  36, 352, 355, 362, 363, 364,
 365, 366, 367, 368, 369, 370, 371, 372, 373, 374,
 375, 376, 377, 378, 379, 347, 380, 336, 330,  44,
 381, 386, 359, 348,  32, 389, 349,  61, 291,  61,
  36, 340, 383, 325,  67, 343, 333, 290, 361, 332,
  33, 279, 278, 213, 428, 392, 384,  31, 393,  36,
 304, 350, 329, 406, 312,  30,  33, 204, 213, 387,
 346, 390, 351, 325,  43, 213, 580, 401, 402, 190,
 579, 554, 398, 407, 399, 552, 204,  38, 415,  69,
  77, 432,  42,  70, 243,  66, 334,  69, 224, 213,
 424,  70,  33,  61, 416, 411,  37, 435, 419, 420,
  86, 413, 423, 425,  75, 138, 137, 417, 318, 318,
 236,  33, 304,  44,  67, 140, 409,  30,  57, 439,
 243, 434,  87, 335, 438,  56,  41, 199, 143, 342,
 441,  57,  44, 445,  75, 440, 433,  76,  56, 323,
 208, 624,  34, 213,  35,  66,  57,  69, 429, 431,
  69,  70, 488,  56,  70,  61, 446, 274, 450, 270,
  43, 271, 273,  66, 548,  69, 452, 453, 481,  70,
 213, 213, 459, 455, 454, 458,  23,  57,  42, 460,
 449, 213, 415, 415,  56,  38, 464,  69, 424,  83,
 467,  70, 448, 421, 478,  63, 476, 479, 416, 416,
 465, 466, 461, 471, 439, 472, 463, 341, 410,  44,
  25, 213, 269, 482, 321, 450, 450, 304, 308, 231,
 440, 207,  30, 278,  66, 422,  69, 483,  24, 181,
  70,  57, 575, 493, 430, 340, 180, 468,  56, 469,
 522, 550,  38, 408, 504, 494,  16, 497, 296, 213,
 213, 523, 524, 545, 297, 278,  46, 139, 623, 495,
  61, 268, 549, 496, 551,  37, 578,  24,  67,  40,
  66, 200,  69, 576, 616,  38,  70,  69, 590, 553,
 268,  70, 274,  67, 270, 588, 271, 273, 484,  69,
  36, 586,  29,  70, 212, 179, 526, 272, 582, 584,
  34,  44,  35, 583, 589, 585, 574, 587, 522, 522,
 522, 522, 522, 522, 522, 522, 522, 522, 522, 522,
 522, 522, 522, 522, 522, 522, 172,  19, 611,  36,
 609, 612, 522, 522, 614,  30, 504, 269,  16, 403,
 176, 491, 618,  55, 619, 490, 621, 209, 267, 558,
  82,  19,  33, 556, 557, 451,  69, 437, 232, 119,
  70,  47, 268,   8, 626,   7, 338, 317,  72, 629,
  69, 223, 628,  61,  70, 522, 630, 632, 633, 558,
 477, 235, 328, 556, 557, 473, 637, 636,  41, 212,
 309,  33, 564, 562, 639, 591, 592, 593, 594, 595,
 596, 597, 598, 599, 600, 601, 602, 603, 604, 605,
 606, 607, 608, 358, 470,  38, 183,  57, 187, 492,
 615, 117, 564,  37,  56,  34, 160,  35,  32, 184,
 149, 170, 499, 487, 456,  52, 216, 158, 558, 125,
  41, 167, 556, 557, 210,  39, 567, 173, 566,  18,
   1,  31,  19, 155, 156, 316, 300,   2,   0,  44,
  30,  38, 631,   0,   0,  41,   0, 396,  19,   0,
   0,  34,  54,  35,   0,   0,   0,   0,   0, 565,
 563, 564, 562,   0,  77,   0,   0,   0, 165, 163,
 164, 166,  30, 162, 317, 317, 178, 119,  61,   0,
   0, 316, 157, 305,  55, 328,  30, 519,   0, 515,
 512,  41,   0, 516, 513, 520, 518, 314,  83,  41,
   0,   0, 509,  19,  25, 517, 507,  79,   0, 149,
 170,  40, 314,   0, 502, 358, 158, 249, 173, 510,
 167, 247, 248,   0,  61, 508, 173,   0,  37,  25,
 180, 305, 155, 156,  58,   0, 151,   0, 152,   0,
 154, 153,   0, 314,  43,   0,   0, 266,  41,   0,
   0,   0, 249, 396, 396, 180, 247, 248, 500, 299,
 255, 253,  42,  40,  44,  42, 511, 165, 163, 164,
 166,  30, 162,   0,  37,  25,   0,   0, 388,   0,
 391, 157,   0, 503,   0,   0,  29,   0, 234, 179,
   0,   0,   0,  44,   0, 255,  44, 314, 146, 119,
   0, 180,  41,   0,   0,  32,   0,   0,   0,  26,
  44,  29, 149, 170, 179,   0,   0,   0,  41, 158,
   0,  38,   0, 167, 418,   0,   0,   0,  31, 173,
   0,  34,  25,  35,  40, 155, 156, 237, 238, 151,
   0, 152,  40, 154, 153, 385, 521,   0, 305, 305,
  62,   0,   0,   0,   0,   0,  41,  29, 180,   0,
 179,  59, 189,   0,  42,  29,  30,   0, 179, 168,
 165, 163, 164, 166,  30, 162,   0,   0,   0,   0,
   0,   0,   0, 277, 157,   0, 191,   0,   0,   0,
 412,  40,   0, 501,   0,  44,   0,   0,   0,   0,
   0,   0,  25,   0,  61, 146,   0,   0,   0,  41,
   0,   0,  26, 305,  29,   0,   0, 179,   0, 149,
 170,   0,   0,   0,   0,   0, 158,   0, 180,   0,
 167,   0,   0,   0,   0, 305, 173, 305,   0, 305,
  25,  43, 155, 156,  19,  40, 151,   0, 152, 147,
 154, 153,   0,   0,  37,   0,   0,   0,   0,  42,
   0,  40,   0,   0,   0,   0, 180,  42,  29,   0,
   0, 179,   0,   0,   0,   0, 168, 165, 163, 164,
 166,  30, 162,  55,  29,   0,   0, 179,   0,   0,
  44, 157,   0, 191,   0, 146,   0,   0,  44,  40,
   0,   0,   0, 558,   0, 559,   0, 556, 557, 149,
 170, 567,   0, 566,   0,   0, 158, 561, 560,  26,
 167,   0,  29,  41,   0, 179, 173,   0,   0,   0,
   0,   0, 155, 156,   0,   0, 151,   0, 152,   0,
 154, 153,   0,   0, 565, 563, 564, 562,   0,   0,
 397,   0,  40,   0,   0,   0, 147,   0,   0, 189,
  34,   0,  35,   0,   0, 146, 168, 165, 163, 164,
 166,  30, 162,   0,  42,  29,   0,   0, 179, 149,
 170, 157,   0, 171,  41,   0, 158,   0,   0,   0,
 167,   0,   0,   0,   0,  30, 173, 195,   0,   0,
   0,   0, 155, 156,   0,  44, 193,  54, 152,  61,
 154, 153,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  34,   0,  35,   0,   0,   0,   0,   0, 189,
   0,   0,   0,  61, 146,   0, 168, 165, 163, 164,
 166,  30, 162,   0,   0,   0, 147,   0, 149, 170,
   0, 157,   0,   0,   0, 158,  30,   0,   0, 167,
   0,   0,   0,   0,  42, 173,  40,   0,  54,   0,
   0, 155, 156,   0,   0, 151,   0, 152,   0, 154,
 153,   0,   0,  37,   0,   0,   0,   0,   0,  58,
   0,   0,   0,   0,  61,  44,   0,   0,   0,   0,
 520,   0,   0,   0,   0, 168, 165, 163, 164, 166,
  30, 162,   0,   0, 149, 170, 147,   0,   0,  44,
 157, 158, 171,   0,   0, 167,   0,  40,   0, 196,
   0, 173,   0,   0,  42,   0,   0, 155, 156,   0,
   0, 151,   0, 152,  37, 154, 153,   0,  61, 249,
  58, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251,  44,   0,   0,   0,   0,
   0, 168, 165, 163, 164, 166,  30, 162,   0,   0,
  44,   0,   0,   0,   0, 147, 157,   0, 171,   0,
 256, 254, 255, 253,   0,   0,  41,   0, 149, 170,
   0,   0, 558,  42, 559, 158, 556, 557,   0, 167,
 567,   0, 566,   0,  61, 173, 561, 613,   0,   0,
   0, 155, 156,   0,   0, 151,   0, 152,   0, 154,
 153,   0,   0,  34,  44,  35,   0,   0,   0,   0,
   0,   0,   0, 565, 563, 564, 562,   0,   0,   0,
   0, 521,   0,   0,   0, 168, 165, 163, 164, 166,
  30, 162,   0, 357, 149, 170,   0,   0,  30,  42,
 157, 158, 171,   0,   0, 167,   0,   0,   0,   0,
  54, 173,   0, 577,   0,   0,   0, 155, 156,   0,
   0, 151,   0, 152,   0, 154, 153,   0,  61, 558,
  44, 559,   0, 556, 557,   0,  61, 567,   0, 566,
   0,   0,   0, 561, 560, 568, 569, 572,   0,   0,
   0, 168, 165, 163, 164, 166,  30, 162,   0,   0,
   0,   0,   0,   0,   0, 266, 157,   0, 171,  40,
 565, 563, 564, 562,   0,   0,   0,   0, 149, 170,
   0,   0,   0,  42,   0, 158,  37,   0,   0, 167,
   0,   0,  58,   0,  61, 173,   0, 382,   0,   0,
   0, 155, 156,   0,   0, 151,   0, 152,   0, 154,
 153,   0,   0,   0,  44, 249,   0, 250,   0, 247,
 248,   0,  44, 257,   0, 258,   0,   0,   0, 252,
   0, 266,   0,   0,   0, 168, 165, 163, 164, 166,
  30, 162,   0,   0, 149, 170,   0,   0,   0,  42,
 157, 158, 171,   0,   0, 167, 256, 254, 255, 253,
   0, 173,   0, 265,   0,   0,   0, 155, 156,   0,
 638, 151,   0, 152,   0, 154, 153,   0,  61, 249,
  44, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263,   0, 246,
 262, 168, 165, 163, 164, 166,  30, 162,   0,   0,
   0,   0,   0,   0,   0, 266, 157,   0, 171, 261,
 256, 254, 255, 253,   0,   0,   0,   0, 149, 170,
   0,   0, 249,  42, 250, 158, 247, 248,   0, 167,
 257,   0, 258,   0,  61, 173, 252, 251, 259, 260,
 263, 155, 156,   0,   0, 151,   0, 152,   0, 154,
 153,   0,   0,   0,  44,   0,   0,   0,   0,   0,
   0,   0,   0, 256, 254, 255, 253,   0,   0,   0,
 146, 266,   0,   0,   0, 168, 165, 163, 164, 166,
  30, 162,   0,   0, 149, 170,   0,  41,   0,  42,
 157, 158, 171,   0,   0, 167,   0,   0,  32,   0,
   0, 173,   0,   0,   0,   0,   0, 155, 156,   0,
   0, 151,   0, 152,  38, 154, 153,   0,  61,   0,
  44,  31,   0, 558,  34, 559,  35, 556, 557,   0,
   0, 567,   0, 566, 189,   0,   0, 561, 560, 568,
   0, 168, 165, 163, 164, 166,  30, 162,   4,  13,
   0, 149, 170,   0,  21, 266, 157,   0, 158,  30,
   0,  41, 167,   0, 565, 563, 564, 562, 173,   0,
   0,  25,  32,  42, 155, 156,   0,   0, 151,   0,
 152,   0, 154, 153,   0,   0,   0,   0,  38,   0,
   0,   0,   0,   0,   0,  31,   0,  26,  34,   0,
  35,   0,   0,   0,  44,   0,   0,   0, 320, 165,
 163, 164, 166,  30, 162,   0,   0,   0,   0,   0,
   3, 147,   6, 157,   0, 171,   0,   0,  21,   0,
  40,   0,   0,  30,  43,  41,   0,   0,   0,  42,
   0,   0,   0,   0,   0,  25,  32,  37,   0,   0,
   0,  61,  42,  29,   0,   0, 179,   0,   0,   0,
   0,   0,  38,   0,  41,   0,   0,   0,   0,  31,
  44,  26,  34,   0,  35,  32,   0,   0,   0, 474,
 475,   0,   0,  44,   0,   0,   0,   0, 266,   0,
   0,  38,   0,   0,   0,   0, 215,   0,  31,   0,
   0,  34,  21,  35,  40,  41,  42,  30,  43,   0,
   0,   0,   0,   0,   0,   0,  32,   0,   0,  25,
  62,  37,   0,  53,   0,   0,  42,  29,   0,   0,
   5,  59,  38,  14,   0,   0,  30,  44,  32,  31,
   0,   0,  34,   0,  35,  26,   0,   0,  54,   0,
   0,   0,   0,   0,  38,   0,  15,  44,   0,   0,
  32,  31,   0,   0,  34, 558,  35,   0,   0, 556,
 557,   0,  21, 567,  61, 566,  38,  30,  40,   0,
   0,   0,  43,  31,   0,   0,  34,   0,  35,  54,
   0,   0,   0,   0,  21,  37,   0, 221,   0,  30,
  42,  29,   0,   0, 179,   0, 565,  40, 564, 562,
   0,  43,   0,   0,   0,  61,  21,   0,   0,   0,
   0,  30,   0,   0,  37,   0,   0,   0,   0,  42,
  58,  44,   0,  83,   0,   0,   0,  61,   0, 249,
   0, 250,   0, 247, 248,   0,   0, 257,  40, 258,
   0,   0,  43, 252, 251, 259,   0,   0,   0,  61,
  44,   0,   0,   0,   0,  37,   0,   0,   0,   0,
  42,  58,   0,   0,  43, 113,   0,   0,   0,   0,
 256, 254, 255, 253,   0,   0,   0,  37,   0, 112,
   0,   0,  42,   0,   0,   0,  43,   0,   0,   0,
   0,  44,   0,   0,   0,   0, 105,   0, 106,  37,
 114,   0, 107, 108,  42,   0,  93,   0,  94,   0,
  91,  92,   0,  44, 101,   0, 102,   0,   0,   0,
  96,  95, 103, 104,   0,   0, 111, 115,   0,   0,
   0,   0,   0,   0, 558,  44, 559,   0, 556, 557,
   0,  30, 567,   0, 566,   0, 110, 100,  98,  99,
  97, 109,   0, 118, 542,   0, 532, 538,   0,   0,
 533, 539,   0, 531,   0,   0,   0,   0,   0, 529,
   0,   0, 534, 527,   0, 565, 563, 564, 562,  61,
 249, 535,   0,   0, 247, 248, 528,   0, 257,   0,
 258,   0, 530,   0,   0,   0,   0, 249,   0, 250,
   0, 247, 248,   0,   0, 257,   0, 258,   0,   0,
   0, 252, 251, 259, 260, 263,   0, 246, 262, 635,
   0, 256, 543, 255, 253, 525,   0, 537,   0,   0,
   0,   0,   0, 536,   0,   0, 116, 261, 256, 254,
 255, 253, 634,   0,   0,   0,   0,   0,   0, 249,
 540, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263,   0, 246,
 262,   0,   0,   0,   0,   0, 541, 249,   0, 250,
   0, 247, 248,   0,   0, 257,   0, 258,   0, 261,
 256, 254, 255, 253, 558,   0, 559,   0, 556, 557,
   0,   0, 567,   0, 566,   0,   0,   0, 561, 560,
 568, 569, 572,   0, 555, 571, 627,   0, 256, 254,
 255, 253,   0, 249,   0,   0,   0, 247, 248,   0,
   0, 257, 625, 258, 570, 565, 563, 564, 562, 249,
   0, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263,   0, 246,
 262,   0,   0,   0, 256, 254, 255, 253,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 261,
 256, 254, 255, 253, 558,   0, 559,   0, 556, 557,
   0,   0, 567,   0, 566,   0,   0,   0, 561, 560,
 568, 569, 572, 622, 555, 571,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 570, 565, 563, 564, 562, 249,
   0, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263, 620, 246,
 262,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 617,   0,   0,   0, 261,
 256, 254, 255, 253, 249,   0, 250,   0, 247, 248,
   0,   0, 257,   0, 258,   0,   0,   0, 252, 251,
 259, 260, 263,   0, 246, 262,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 261, 256, 254, 255, 253, 249,
   0, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263,   0, 246,
 262, 581,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 480,   0, 261,
 256, 254, 255, 253, 249,   0, 250,   0, 247, 248,
   0,   0, 257,   0, 258,   0,   0,   0, 252, 251,
 259, 260, 263,   0, 246, 262,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 447,   0, 261, 256, 254, 255, 253, 249,
   0, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263,   0, 246,
 262,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 444,   0, 261,
 256, 254, 255, 253, 249,   0, 250,   0, 247, 248,
   0,   0, 257,   0, 258,   0,   0,   0, 252, 251,
 259, 260, 263,   0, 246, 262,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 261, 256, 254, 255, 253, 249,
   0, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263, 443, 246,
 262,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 394,   0,   0,   0, 261,
 256, 254, 255, 253, 249,   0, 250,   0, 247, 248,
   0,   0, 257,   0, 258,   0,   0,   0, 252, 251,
 259, 260, 263,   0, 246, 262,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 319,   0, 261, 256, 254, 255, 253, 249,
   0, 250,   0, 247, 248,   0,   0, 257,   0, 258,
   0,   0,   0, 252, 251, 259, 260, 263,   0, 246,
 262,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 261,
 256, 254, 255, 253, 558,   0, 559,   0, 556, 557,
   0,   0, 567,   0, 566,   0,   0,   0, 561, 560,
 568, 569, 572,   0, 555, 571,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 570, 565, 563, 564, 562, 558,
   0, 559,   0, 556, 557,   0,   0, 567,   0, 566,
   0,   0,   0, 561, 560, 568, 569, 572, 249, 555,
 250,   0, 247, 248,   0,   0, 257,   0, 258,   0,
   0,   0, 252, 251, 259, 260, 263,   0, 246, 570,
 565, 563, 564, 562,   0,   0,   0,   0,   0, 249,
   0, 250,   0, 247, 248,   0,   0, 257, 261, 256,
 254, 255, 253, 252, 251, 259, 260, 263,   0, 246,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 261,
 256, 254, 255, 253 };
short yypact[]={

1798,-1000,-1000,-1000,-1000, 128,-1000,-1000,-1000,-1000,
-1000,-1000,-1000, 466,-1000, -33,1901, 373,-1000, 578,
-1000, 339, 654,1986,1964,-1000, 292,-1000,-1000,-1000,
 314, -74,2116,-1000,   8,   4,-101,   0,-1000,-1000,
  48,   7,-1000,-1000, 292,-1000,  25, 298, 297,-1000,
-1000, 295, 150,-1000,-1000, 578,-1000,-1000,-1000, 309,
-1000, 292,1195,-1000, 677,-1000, 438, 859,-1000,1195,
-1000,-1000,1126,-1000, 363, 144,-1000, 332,-1000,-1000,
-142, 355, 578,-1000, 480, 966,-1000, 966,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000, 430, 347,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, 500,-1000,-1000,
-1000,-1000,-1000,  -3,-1000,1872, 269, 292,-1000,-1000,
-1000,  36, 126,-1000,-1000, 966, 428, 702, 966, 677,
1056, 851,-1000,1195, 966,2908,1561, 589, 367, 913,
1645,1645,1645,1645,1645,1645,1645,1645,1645,-1000,
-1000, 966,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  51,
2116, 458, 464,-1000,  69,-1000,  29,1901,-1000,-1000,
 292,  -6, 427, -26, 233,-1000,-1000,-1000,2908,1056,
 625, 458,2799,1778, 423, -12,1964,-1000,-1000,-1000,
-1000, 169,-1000,-1000,2939,1141, 242,-1000,-1000,-1000,
-1000,-1000, 342,-134,-1000,-1000,-1000,-1000, 217, 214,
-1000, 267, 250, 111, 282, 966, 132,-1000, 240,  36,
 169, 204, 241,-1000,   1, -33,1353,-1000,-1000, 212,
  69,-1000,-1000, 295,2908, 169,1195,1195,1195,1195,
1195,1195,1195,1195,1195,1195,1195,1195,1195,1195,
1195,1195,1195,1195, 367,1195, 488,1495, 875,-1000,
1195, 154,1645, 154,1056,-1000,-1000,1711, 363, 492,
 367, 367, 367, 367, 492, 492, 492, 492, 657,2754,
1080,-1000,2116, -77,-1000,-1000,1056,1056,-1000, -41,
 232,-1000,1056, 453,-1000,-1000, 966,-1000,-1000, 417,
 805,-1000,1056,  49,-1000, 287,-1000, 671,  60,-1000,
 402,-1000,-1000, 434,-1000, 966,-1000, 358, 342,-1000,
-1000,-1000,-1000,-1000,-1000, 171, 166,-1000, 223,-1000,
-1000, 387, 156, 169,-1000,  36,1195,  64,-1000,-1000,
-1000, 702,-1000, 292,-1000,-1000, 485,-1000,   2, 163,
-1000,-1000,2908, 119, 119,-1000,2333,1505,2287, 772,
2190,-1000, 737, 737, 737,1269,2039,2908,2908,2709,
2664, 367,1195,-1000,-1000,1711,2619,-1000,-1000, 492,
-1000,-1000, 401, 389,-1000, 564,  10, 173,-1000,-1000,
-1000, 383, 382,-1000,-1000,  44,  29, 381,1056, 169,
 -36,-1000,-1000,-1000,-1000,-1000,-1000,1056,-1000, 485,
 395, 452, 452,-1000,-1000, 358,-1000,-1000, 282,-1000,
 220,-1000, 220,-1000,-1000,2908,-1000,1724,-1000,-1000,
-1000, 485,-1000,1195,1645,2574, 377,-1000,-1000, 748,
-1000,-1000, 358, 497,-1000,-1000,  43,-1000,-1000,-1000,
 361,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,  65,-1000,-1000,1942, 355,1622, 367,
1645, 748,-1000,-1000, 485,-1000,-1000, 756,-1000,-1000,
 -33, -33, 355, 367,-1000,-1000,-1000,-1000,-1000,2213,
-1000,  61,1195, 127,-1000,-1000,-1000, 374, 374, 451,
 374, 256,-1000, 252,2844,-1000,-1000,  35,-1000, 442,
1411, 507, 367, 251, 247,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,2529,  69,-1000,1195,-1000,
-1000,-1000,-1000,1195,-1000,1261,1261,1261,1261,1261,
1261,1261,1261,1261,1261,1261,1261,1261,1261,1261,
1261,1261,1261,-1000,-1000, -10, 367,1195,1345, 756,
1261,-1000,-1000, 512,2484,-1000,-1000,-1000,-1000,2439,
-1000,2889, 101, 101,-1000, 638,1322,2144, 579,1965,
-1000, 549, 549, 549,1023,1723,2889,2889,2394, 469,
 350,2349, 367,1195,-1000,2304,-1000,-1000,1195,-1000,
-1000,-1000,1261, 374,-1000,1645,2259,-1000,-1000,2207,
-1000,1419,-1000, 367,1645,1195, 367,1569,-1000,-1000 };
short yypgo[]={

   0, 707, 104,  17,  15,  14,  53, 706,  18,   6,
 700,  12, 426,   8, 699, 190,  35,  25, 108,  56,
 695, 197, 689, 686,  43, 685,  44, 192,  38, 684,
   5, 683,   1,   4, 682, 679,  20,   0,  89,   2,
  37, 676,  19,  13,  55,  31, 671,  30,  21,  34,
 668,  28, 666,  24,  27,   3, 164, 576, 102,  79,
 664,  29, 640, 631,  10, 621, 616,  11,  26,  59,
 615, 613, 611, 608, 607, 595, 591, 590,  51,  42,
  22,  40, 589, 556, 546, 541, 535, 529, 528,  23 };
short yyr1[]={

   0,  10,  10,  10,  10,  10,  10,  10,  71,  72,
  74,  70,  60,  60,  60,  75,  60,  76,  60,  64,
  64,   1,   1,   1,   1,   1,   2,   4,   3,  77,
   6,   6,   7,   7,   8,   8,   5,   5,  24,  24,
  24,  24,  25,  25,   9,   9,  78,  79,  57,  57,
  57,  14,  14,  14,  14,  14,  14,  14,  13,  13,
  13,  13,  13,  13,  69,  69,  68,  68,  15,  15,
  15,  15,  16,  16,  73,  73,  73,  63,  63,  80,
  80,  80,  48,  48,  48,  48,  17,  17,  17,  21,
  21,  21,  21,  21,  65,  65,  66,  66,  67,  67,
  67,  67,  67,  20,  20,  18,  18,  19,  19,  22,
  22,  23,  23,  23,  23,  23,  23,  23,  23,  23,
  26,  26,  26,  26,  61,  61,  61,  61,  61,  61,
  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
  59,  59,  59,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  47,  47,  47,  47,  47,  47,  47,  53,
  53,  53,  42,  42,  42,  42,  42,  44,  44,  29,
  29,  30,  31,  55,  82,  32,  32,  32,  34,  34,
  34,  34,  83,  34,  34,  84,  84,  84,  84,  84,
  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,
  84,  84,  33,  33,  33,  33,  33,  33,  33,  33,
  33,  33,  33,  33,  85,  33,  33,  86,  33,  87,
  33,  88,  33,  36,  35,  35,  28,  28,  38,  38,
  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,
  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,
  38,  37,  37,  37,  37,  37,  37,  37,  37,  37,
  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,
  37,  37,  37,  37,  37,  39,  39,  39,  39,  39,
  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,
  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,
  39,  39,  39,  39,  39,  41,  41,  41,  41,  41,
  41,  41,  58,  56,  56,  56,  40,  40,  40,  40,
  40,  40,  40,  43,  89,  46,  46,  46,  46,  45,
  54,  50,  50,  81,  51,  51,  52,  52,  49,  49,
  62,  62,  62,  12,  12,  12,  12,  12,  12,  12,
  12,  12,  11,  11 };
short yyr2[]={

   0,   1,   1,   1,   2,   1,   1,   1,   6,   0,
   0,   7,   1,   1,   2,   0,   5,   0,   6,   1,
   1,   1,   1,   1,   1,   5,   2,   5,   4,   1,
   2,   0,   1,   3,   3,   4,   2,   0,   1,   3,
   2,   3,   1,   3,   3,   2,   1,   1,   1,   4,
   4,   1,   1,   1,   4,   1,   1,   1,   1,   2,
   2,   2,   2,   2,   3,   1,   1,   1,   4,   5,
   2,   2,   1,   3,   3,   1,   0,   1,   1,   2,
   2,   2,   1,   2,   2,   2,   1,   3,   0,   3,
   4,   2,   5,   2,   2,   0,   1,   3,   1,   2,
   2,   3,   3,   2,   4,   1,   1,   1,   1,   2,
   0,   1,   2,   2,   1,   1,   1,   2,   3,   3,
   1,   2,   2,   2,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   2,   3,   2,   3,   4,   2,   4,   6,   4,
   3,   4,   6,   1,   3,   2,   2,   2,   2,   2,
   2,   3,   1,   2,   0,   2,   2,   2,   3,   0,
   2,   2,   0,   2,   2,   4,   4,   0,   2,   0,
   2,   2,   0,   3,   0,   4,   2,   3,   1,   1,
   1,   2,   0,   5,   4,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   2,   2,   1,   2,   3,   3,   1,   1,
   1,   3,   5,   3,   0,   9,   3,   0,   4,   0,
   5,   0,   4,   1,   1,   3,   1,   3,   3,   3,
   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
   3,   3,   3,   3,   3,   5,   2,   5,   3,   6,
   1,   3,   3,   3,   3,   3,   3,   3,   3,   3,
   3,   3,   3,   3,   3,   3,   3,   3,   5,   2,
   5,   3,   6,   1,   0,   2,   2,   3,   3,   2,
   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
   4,   3,   3,   3,   3,   3,   1,   1,   3,   1,
   1,   1,   1,   1,   1,   4,   4,   5,   5,   6,
   6,   4,   4,   1,   1,   2,   1,   2,   2,   3,
   2,   3,   3,   4,   1,   1,   1,   2,   2,   2,
   2,   2,   4,   1,   4,   5,   3,   1,   1,   0,
   0,   1,   2,   1,   1,   2,   2,   2,   2,   1,
   3,   2,   3,   1 };
short yychk[]={

-1000, -10,  -1,  72,   0, 182,  74, -70, -71,  -9,
  -4,  -3,  -2,   1, 185, 208, -13, -27, -14, -57,
 -26,  80, -59, -12, -81,  97, 123, -21, -15, 179,
  85,  47,  24, -56,  50,  52, -58, 173,  40, -20,
 156,  13, 178, 160, 209,  73,  40, -72, -64,  80,
 123, -27, -25,  72,  97, -57, -21, -15, 179,  80,
 -24, 123,  69,  72,  -5, -51,  40, -81, -11,  42,
  46, -51,  40, -11, -81,  45, -56,  80, -26, 123,
 -58, -27, -57,  97, -27, -78,  58,  58, 123, -61,
 -45,  54,  55,  50,  52,  65,  64,  94,  92,  93,
  91,  58,  60,  66,  67,  40,  42,  46,  47,  95,
  90,  70,  23,   9,  44,  71, 180, -46,  97, -57,
  97,  97, 178, 173,  97, -22, -18, 123, 179,  73,
  80,  73, -18, 179, 123, -78,  81,  58,  58,  -5,
  70,  71,  72,  69, -78, -37,   9, 160, -39,  23,
 -43,  50,  52,  55,  54,  46,  47,  95,  30, -40,
 -41, -89,  86,  82,  83,  81,  84,  34,  80, -56,
  24,  97, -57,  40,  -6,  -9, -77, -13,  69, 182,
 123,  41, -36, -52, -35, -49, -28, -50, -37,  73,
 -13,  97, -37,  50, -36,  41, 173, -26,  80,  45,
  41, -69, -68, -54, -37, -13, -69,  41,  43,  97,
 -57, -44, -12, -58,  97,  74, -23,  -9,  -4,  -3,
  -2, 175, -59, -65,  69, -78, -16, -17,  80,  73,
 -69,  41, -73, -80, 156, -63, -13, 205, 206, -69,
  -6, -28, -24, -27, -37, -69,  70,  54,  55,  50,
  52,  65,  64,  94,  92,  93,  91,  58,  60,  66,
  67,  90,  71,  68, -39,  42, 160,   9,  23,  95,
  42,  44, 180,  45,  40, -43, -54,  40, -89, -39,
 -39, -39, -39, -39, -39, -39, -39, -39, -43, -37,
 -13, -18,  24,  47, -61, -45,  40,  40, -32,  73,
  -7,  -8,  40, -19,  80, -57, -78,  97,  41, -62,
  71, 155,  71, -36, -57, -47,  80, -12, -81,  43,
  80,  41,  97, -27, -79,  71,  60, -53, -12,  60,
 -44,  97,  72,  72,  69, 123, -26,  73, -66, -67,
 -19, 175,  97, -69,  74,  71,  70, -16, -79,  72,
  60,  71, -64, 123,  80, -64, -48,  80, -12,  60,
 -32, -79, -37, -37, -37, -37, -37, -37, -37, -37,
 -37, -37, -37, -37, -37, -37, -37, -37, -37, -37,
 -37, -39,  42, -43, -54,  40, -37, -40, -57, -39,
 -40, -57, -36, -36,  41, -42, -12,  40, -61, -45,
 123, -36, -36, -82,  74, 256,  71, -36,  40, -69,
  41, -49, 155, -28,  74, -11, -51,  70, -57, -47,
 -47,  41,  41, -68, -11, -53,  72,  72,  71, -19,
  97, -19, 175, -79, -17, -37,  74, -74, -80, -11,
 -51, -48,  72,  69,  43, -37, -36,  43,  41,  41,
 -11,  41, -42, -42,  41,  41, -29,  74,  -8,  41,
 -36, -79,  97, -28,  41, -51, -51, -67, -19, -19,
 -60,  -4,  -3, -21, 205, 206, -13, -27, -37, -39,
  43,  41, -43, -54,  41, -30,  74, -31,  41,  72,
 -75, -76, -27, -39, -43, -54, -51, -11, -33, -34,
  72, 207,  28,  97,  -9,  -4, -32,  20,  39,  16,
  33,  80,   4,   8, -38,   3,   7,  19,  10,   1,
   9, 160, -39, -64, -64,  72, -84,  20,  33,  16,
  39,  10,   3,   7,  19,  28,  80,  74,   4,   8,
  97, 123,   1,  69,  72, -37,  81, -55,  40, -55,
  40, -55,  69, -87,  69,  70,  54,  55,  50,  52,
  65,  64,  94,  92,  93,  91,  60,  58,  66,  67,
  90,  71,  68,  80, -83,  40, -39,  42,   9,  69,
  69,  72, -32, -30, -37, -30, -85, -30, -86, -37,
 -88, -38, -38, -38, -38, -38, -38, -38, -38, -38,
 -38, -38, -38, -38, -38, -38, -38, -38, -38, -30,
  81, -37, -39,  42, -33, -38,  12,  41, -30, -30,
  69, -30,  69,  39,  41,  43, -37,  72, -30, -37,
 -30, -38, -55, -39,  43,  72, -39, -37,  41, -30 };
short yydef[]={

   0,  -2,   1,   2,   3,  52,   5,   6,   7,  21,
  22,  23,  24,   0,   9,   0,   0,  37,  58,   0,
 163, 120,   0,   0,   0,  51,  -2,  55,  56,  57,
   0,   0,   0, 150, 363, 364,   0, 369, 353, 110,
   0,   0, 333, 334,   0,   4,   0,   0,   0,  19,
  20,  -2,   0,  45,  59,  60,  61,  62,  63, 120,
  42,  48, 294,  26,  31, 153, 353,  -2, 170, 294,
 373, 156,  -2, 169, 359,   0, 151, 120, 165, 166,
   0, 167, 168, 366,   0, 294,  46, 294, 121, 122,
 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,
 133, 134, 135, 136, 137,   0,   0, 140, 141, 142,
 143, 144, 145, 146, 147, 148, 149, 187, 345, 346,
 365, 367, 335, 368, 371,   0,  -2, 106,  93, 103,
 105,  88,  70,  71, 106, 294,   0,  76, 294,  31,
 294,   0,  44, 294, 294,  40,   0, 334, 293,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 316,
 317, 294, 319, 320, 321, 322, 323, 324, 336,   0,
   0,   0,   0, 344,   0,  36,   0,   0,  29,  52,
  53, 154,   0, 360, 243, 357, 244, 358, 246, 294,
 174,  51,   0,   0,   0, 160,   0, 164, 120, 152,
 171,   0,  65,  66,  67, 179,   0, 138, 139, 347,
 348, 349, 187,   0, 370,  89, 109, 111, 115, 114,
 116,   0,   0,   0,   0, 294,   0,  72,  86,  88,
   0,   0,   0,  75,   0,   0,   0,  77,  78,   0,
   0,  41,  43,  38,  39,   0, 294, 294, 294, 294,
 294, 294, 294, 294, 294, 294, 294, 294, 294, 294,
 294, 294, 294, 294, 289, 294, 334,   0,   0, 299,
 294,   0,   0,   0, 294, 295, 296,  -2,   0, 300,
 301, 302, 303, 304, 305, 306, 307, 308, 309,   0,
 182, 337,   0,   0, 338, 340, 294, 294,  28,  -2,
  30,  32, 294,   0, 107, 108, 294, 155, 157,   0,
 359, 361, 294,   0,  60, 351, 172, 174, 174, 372,
 336, 159, 161,   0,  -2, 294,  47, 350, 179,  50,
 188,  90, 112, 113, 117, 166, 165, 104,  94,  96,
  98,   0,   0,   0,  68,  88, 294,   0, 332,  25,
  10,   0,  79,  -2,  -2,  80,  81,  82,   0,   0,
  27,  49, 271, 272, 273, 274, 275, 276, 277, 278,
 279, 280, 281, 282, 283, 284, 285, 286, 287,   0,
   0, 291, 294, 297, 298,  -2,   0, 311, 313, 312,
 314, 315,   0,   0, 318,   0, 182, 182, 339, 341,
 342,   0,   0, 189, 196,   0,   0,   0, 294,   0,
 354, 356, 362, 245, 247, 176, 177, 294, 173, 175,
   0,   0,   0,  64, 181, 180, 118, 119,   0,  99,
   0, 100,   0,  92,  73,  87,  69,   0,  74,  84,
  85,  83,   8, 294,   0,   0,   0, 310, 331,   0,
 184, 343, 183,   0, 325, 326, 192, 197,  33,  34,
   0,  54, 355, 352, 178, 158, 162,  97, 101, 102,
  11,  12,  13,  55,  15,  17,   0,  37, 288, 290,
   0,   0, 327, 328,   0, 190, 195,   0,  35,  14,
   0,   0,  37, 292, 329, 330, 185, 186, 191,   0,
 224,   0, 294,  51, 228, 229, 230,   0,   0,   0,
   0, 336, 239,   0, 198, 199, 200,   0, 202,   0,
   0, 334, 270,   0,   0, 222, 223, 205, 206, 207,
 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,
 218, 219, 220, 221, 225,   0,   0, 192, 294, 192,
 234, 192, 237, 294, 241,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 201, 192,   0, 266, 294,   0,   0,
   0, 226, 227, 231,   0, 233, 192, 236, 192,   0,
 192, 248, 249, 250, 251, 252, 253, 254, 255, 256,
 257, 258, 259, 260, 261, 262, 263, 264,   0,   0,
   0,   0, 268, 294,  16,   0, 192, 193, 294, 238,
 192, 242,   0,   0, 204,   0,   0,  18, 232,   0,
 240, 265, 203, 267,   0, 294, 269,   0, 192, 235 };
# ifdef YYDEBUG
# include "y.debug"
# endif

# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

/*	parser for yacc output	*/

#ifdef YYDEBUG
int yydebug = 0; /* 1 for debugging */
#endif
YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

yyparse()
{	short yys[YYMAXDEPTH];
	int yyj, yym;
	register YYSTYPE *yypvt;
	register int yystate, yyn;
	register short *yyps;
	register YYSTYPE *yypv;
	register short *yyxi;

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */
#ifdef YYDEBUG
	if(yydebug >= 3)
		if(yychar < 0 || yytoknames[yychar] == 0)
			printf("char %d in %s", yychar, yystates[yystate]);
		else
			printf("%s in %s", yytoknames[yychar], yystates[yystate]);
#endif
	if( ++yyps >= &yys[YYMAXDEPTH] ) { 
		yyerror( "yacc stack overflow" ); 
		return(1); 
	}
	*yyps = yystate;
	++yypv;
	*yypv = yyval;
yynewstate:
	yyn = yypact[yystate];
	if(yyn <= YYFLAG) goto yydefault; /* simple state */
	if(yychar<0) {
		yychar = yylex();
#ifdef YYDEBUG
		if(yydebug >= 2) {
			if(yychar <= 0)
				printf("lex EOF\n");
			else if(yytoknames[yychar])
				printf("lex %s\n", yytoknames[yychar]);
			else
				printf("lex (%c)\n", yychar);
		}
#endif
		if(yychar < 0)
			yychar = 0;
	}
	if((yyn += yychar) < 0 || yyn >= YYLAST)
		goto yydefault;
	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
		yychar = -1;
		yyval = yylval;
		yystate = yyn;
		if( yyerrflag > 0 ) --yyerrflag;
		goto yystack;
	}
yydefault:
	/* default state action */
	if( (yyn=yydef[yystate]) == -2 ) {
		if(yychar < 0) {
			yychar = yylex();
#ifdef YYDEBUG
			if(yydebug >= 2)
				if(yychar < 0)
					printf("lex EOF\n");
				else
					printf("lex %s\n", yytoknames[yychar]);
#endif
			if(yychar < 0)
				yychar = 0;
		}
		/* look through exception table */
		for(yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate);
			yyxi += 2 ) ; /* VOID */
		while( *(yyxi+=2) >= 0 ){
			if( *yyxi == yychar ) break;
		}
		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
	}
	if( yyn == 0 ){ /* error */
		/* error ... attempt to resume parsing */
		switch( yyerrflag ){
		case 0:   /* brand new error */
#ifdef YYDEBUG
			yyerror("syntax error\n%s", yystates[yystate]);
			if(yytoknames[yychar])
				yyerror("saw %s\n", yytoknames[yychar]);
			else if(yychar >= ' ' && yychar < '\177')
				yyerror("saw `%c'\n", yychar);
			else if(yychar == 0)
				yyerror("saw EOF\n");
			else
				yyerror("saw char 0%o\n", yychar);
#else
			yyerror( "syntax error" );
#endif
yyerrlab:
			++yynerrs;
		case 1:
		case 2: /* incompletely recovered error ... try again */
			yyerrflag = 3;
			/* find a state where "error" is a legal shift action */
			while ( yyps >= yys ) {
				yyn = yypact[*yyps] + YYERRCODE;
				if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
					yystate = yyact[yyn];  /* simulate a shift of "error" */
					goto yystack;
				}
				yyn = yypact[*yyps];
				/* the current yyps has no shift onn "error", pop stack */
#ifdef YYDEBUG
				if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
#endif
				--yyps;
				--yypv;
			}
			/* there is no state on the stack with an error shift ... abort */
yyabort:
			return(1);
		case 3:  /* no shift yet; clobber input char */
#ifdef YYDEBUG
			if( yydebug ) {
				printf("error recovery discards ");
				if(yytoknames[yychar])
					printf("%s\n", yytoknames[yychar]);
				else if(yychar >= ' ' && yychar < '\177')
					printf("`%c'\n", yychar);
				else if(yychar == 0)
					printf("EOF\n");
				else
					printf("char 0%o\n", yychar);
			}
#endif
			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
			yychar = -1;
			goto yynewstate;   /* try again in the same state */
		}
	}
	/* reduction by production yyn */
#ifdef YYDEBUG
	if(yydebug) {	char *s;
		printf("reduce %d in:\n\t", yyn);
		for(s = yystates[yystate]; *s; s++) {
			putchar(*s);
			if(*s == '\n' && *(s+1))
				putchar('\t');
		}
	}
#endif
	yyps -= yyr2[yyn];
	yypvt = yypv;
	yypv -= yyr2[yyn];
	yyval = yypv[1];
	yym=yyn;
	/* consult goto table to find next state */
	yyn = yyr1[yyn];
	yyj = yypgo[yyn] + *yyps + 1;
	if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
	switch(yym){
		
case 1:
# line 440 "gram.y"
{	return 2; } break;
case 2:
# line 441 "gram.y"
{	return 1; } break;
case 3:
# line 442 "gram.y"
{	return 0; } break;
case 4:
# line 444 "gram.y"
{
				set_linkage(yypvt[-1].s);
				bl_level--;
				return 1;
			} break;
case 5:
# line 450 "gram.y"
{
				set_linkage(0);
				bl_level++;
				return 1;
			} break;
case 6:
# line 455 "gram.y"
{  return 1; } break;
case 7:
# line 456 "gram.y"
{  return 1 ;} break;
case 8:
# line 461 "gram.y"
{ Ptreet t = tree_template::get(yypvt[-4].pn->string) ;
                    Pexpr  e = 0 ;
	            if (t)
		      e = t->expand(expr_unlist(yypvt[-2].el)) ;
	            else error ("%s wasn't an expression template",
		                	yypvt[-4].pn->string)  ;
	           } break;
case 9:
# line 471 "gram.y"
{ templp->start() ; } break;
case 10:
# line 473 "gram.y"
{templp->enter_parameters() ; } break;
case 11:
# line 475 "gram.y"
{templp->end(yypvt[-0].pn);
                  templp->in_progress = false ;
                  goto mod;} break;
case 12:
# line 483 "gram.y"
{ goto mod; } break;
case 13:
# line 485 "gram.y"
{ goto mod; } break;
case 14:
# line 487 "gram.y"
{ Pname pn = yypvt[-1].pb->aggr();
                    /* basetype:aggr() does not return the name for a forward */
		    /* declaration, so extract it directly */
                    yyval.p = (pn ? pn : yypvt[-1].pb->b_name) ;
                    DECL_TYPE = 0;  } break;
case 15:
# line 494 "gram.y"
{templp->curr_tree_template = yypvt[-0].t ; } break;
case 16:
# line 496 "gram.y"
{yypvt[-2].pn->n_initializer = yypvt[-0].pe ; /* actually a stmt */
                    yyval.pn = yypvt[-2].pn; } break;
case 17:
# line 499 "gram.y"
{templp->curr_tree_template = yypvt[-0].t ; } break;
case 18:
# line 501 "gram.y"
{yypvt[-3].pn->n_initializer = yypvt[-1].pe ; /* actually a stmt */
                    yyval.pn = yypvt[-3].pn ; } break;
case 20:
# line 506 "gram.y"
{ yyval.pn = Ncopy(yypvt[-0].pn) ;} break;
case 21:
# line 511 "gram.y"
{	
			/* if function declartion with arguments
			 * need to make sure modified_tn is traversed */
			if ( yypvt[-0].pn != 0 
				&& yypvt[-0].pn->tp->base == FCT 
				&& Pfct(yypvt[-0].pn->tp)->nargs !=0 ) 
					goto mod;
			else {
				modified_tn = 0;
				if (yypvt[-0].pn==0) yyval.i = 1; 
			     }
			} break;
case 22:
# line 524 "gram.y"
{	goto mod; } break;
case 23:
# line 526 "gram.y"
{	goto mod; } break;
case 24:
# line 528 "gram.y"
{ mod:	if (modified_tn) {
					restore();
					modified_tn = 0;
				}
				local_blk = 0;
				if (local_tn) {
					extern void local_restore();
					local_restore();
					local_tn = 0;
				}
			} break;
case 25:
# line 540 "gram.y"
{	Pname n = new name(make_name('A'));
				n->tp = new basetype(ASM,0);
				Pbase(n->tp)->b_name = Pname(yypvt[-2].s);
				yyval.p = n;
			} break;
case 26:
# line 556 "gram.y"
{	
				Ptype t;
		/*	fix: */
				if (err_name == 0) err_name = yypvt[-1].pn;
				if (err_name == 0) {
					error("syntax error:TX");
					yyval.p = Ndata(defa_type,err_name);
				}
				else if ((t=err_name->tp) == 0) {
					error("TX for%n",err_name);
					yyval.p = Ndata(defa_type,err_name);
				}
				else if (t->base==FCT) {
					if (Pfct(t)->returns==0)
						yyval.p = Nfct(defa_type,err_name,0);
					else
						yyval.p = Ndata(0,err_name);
				}
				else {
					error("syntax error:TX for%k%n",t->base,err_name);
					yyval.p = Ndata(defa_type,err_name);
				}
				err_name = 0;
			} break;
case 27:
# line 584 "gram.y"
{	Pname n = Nfct(yypvt[-4].p,yypvt[-3].pn,yypvt[-0].p);
				Fargdcl(n->tp,name_unlist(yypvt[-2].nl),n);
				Finit(n->tp) = yypvt[-1].pn;
				yyval.p = n;
				NOT_EXPECT_ID();
				in_mem_fct = 0;
			} break;
case 28:
# line 594 "gram.y"
{	Pname n = Nfct(defa_type,yypvt[-3].pn,yypvt[-0].p);
				Fargdcl(n->tp,name_unlist(yypvt[-2].nl),n);
				Finit(n->tp) = yypvt[-1].pn;
				yyval.p = n;
				NOT_EXPECT_ID();
				in_mem_fct = 0;
			} break;
case 29:
# line 606 "gram.y"
{ must_be_expr = 1; } break;
case 30:
# line 609 "gram.y"
{	
				yyval.p = yypvt[-0].p; 
				must_be_expr = 0;
			} break;
case 31:
# line 614 "gram.y"
{	yyval.p = 0; } break;
case 32:
# line 618 "gram.y"
{	yyval.p = yypvt[-0].p; } break;
case 33:
# line 620 "gram.y"
{	yyval.pn = yypvt[-0].pn;  yyval.pn->n_list = yypvt[-2].pn; } break;
case 34:
# line 624 "gram.y"
{
				yyval.pn = new name;
				yyval.pn->n_initializer = yypvt[-1].pe;
			} break;
case 35:
# line 629 "gram.y"
{
				Pname n = Ncopy(yypvt[-3].pn);
				n->base = yypvt[-3].pn->base;
				n->n_initializer = yypvt[-1].pe;
				yyval.pn = n;
			} break;
case 36:
# line 652 "gram.y"
{	if (yypvt[-0].pn == 0)
					error("badAD");
				else if (yypvt[-0].pn->tp->base == FCT)
					error("FD inAL (%n)",yypvt[-0].pn);
				else if (yypvt[-1].p)
                                        yypvt[-1].nl->add_list(yypvt[-0].pn);
				else
					yyval.nl = new nlist(yypvt[-0].pn);
			} break;
case 37:
# line 662 "gram.y"
{
                                yyval.p = 0; 
/* error( 'd', "arg_dcl_list: in_class_decl: %d", in_class_decl );
 */
                                if ( in_class_decl ) in_mem_fct = 1;
			} break;
case 39:
# line 672 "gram.y"
{	yyval.p = yypvt[-2].pn;
				yyval.pn->tp = new basetype(FIELD,yypvt[-0].pn);
		 	} break;
case 40:
# line 676 "gram.y"
{	yyval.p = new name;
				yyval.pn->tp = new basetype(FIELD,yypvt[-0].pn);
			} break;
case 41:
# line 680 "gram.y"
{	Pexpr e = yypvt[-0].pe;
				if (e == dummy) error("emptyIr");
				yypvt[-2].pn->n_initializer = e;
				init_seen = 0;
			} break;
case 42:
# line 690 "gram.y"
{	
				if (yypvt[-0].p) yyval.nl = new nlist(yypvt[-0].pn); 
				if ( NEXTTOK() == CM && 
					la_look() == TNAME ) 
					EXPECT_ID();
			} break;
case 43:
# line 697 "gram.y"
{	if (yypvt[-2].p)
					if (yypvt[-0].p)
						yypvt[-2].nl->add(yypvt[-0].pn);
					else
						error("DL syntax");
				else {
					if (yypvt[-0].p) yyval.nl = new nlist(yypvt[-0].pn);
					error("DL syntax");
				}
			} break;
case 44:
# line 711 "gram.y"
{ 
				extern int co_hack;
				co_hack = 1;
				/*$$ = Ndata($1,name_unlist($<nl>2));*/
				Pname n = Ndata(yypvt[-2].p,name_unlist(yypvt[-1].nl)); 
				if ( in_typedef && in_tag ) { 
					if ( n->tp->check( in_tag->tp, 0 ))
    						error("%nredefined: previous: %t now: %t", in_tag, in_tag->tp, n->tp );
				}
				in_typedef = 0;
				in_tag = 0;
				co_hack = 0;
				DECL_TYPE = 0; 
				yyval.p = n;
			} break;
case 45:
# line 729 "gram.y"
{ 
				yyval.p = yypvt[-1].pb->aggr(); 
				DECL_TYPE = 0; 
			
			} break;
case 46:
# line 738 "gram.y"
{ templp->parameters_in_progress++; } break;
case 47:
# line 739 "gram.y"
{ templp->parameters_in_progress--; } break;
case 48:
# line 741 "gram.y"
{ yyval.pn = templp->check_tname(yypvt[-0].pn) ; } break;
case 49:
# line 743 "gram.y"
{ 
		    yyval.pn =parametrized_typename(yypvt[-3].pn,
						  (expr_unlist(yypvt[-1].el))) ; } break;
case 50:
# line 747 "gram.y"
{ extern Pbase any_type;
		    error("%n was not a parametrized type.", yyval.pn) ;
                    yyval.pn= yypvt[-3].pn->tdef() ;
                    yyval.pn->tp = any_type ; } break;
case 51:
# line 755 "gram.y"
{ 
				yyval.p = new basetype(yypvt[-0].t,0); 
				if ( yypvt[-0].t == TYPEDEF ) in_typedef = yyval.pt;
				if (DECL_TYPE == -1) DECL_TYPE = 0;
			} break;
case 52:
# line 761 "gram.y"
{	yyval.p = new basetype(EXTERN,0);
				yyval.pb->b_linkage = yypvt[-0].s;
				if (DECL_TYPE == -1) DECL_TYPE = 0;
			} break;
case 53:
# line 766 "gram.y"
{       templp->check_tname(yypvt[-0].pn) ;
				yyval.p = new basetype(TYPE,yypvt[-0].pn); 
				if (DECL_TYPE == -1) DECL_TYPE = 0;
			} break;
case 54:
# line 771 "gram.y"
{ yyval.pb = parametrized_basetype(yypvt[-3].pn,
 						   (expr_unlist(yypvt[-1].el))) ; } break;
case 57:
# line 776 "gram.y"
{ 
				if (DECL_TYPE == TNAME)
					yyval.p = new basetype(TYPE,yypvt[-0].pn); 
				else
					yyval.p = new basetype(yypvt[-0].t,0); 
				DECL_TYPE = -1;
			} break;
case 59:
# line 789 "gram.y"
{ 
				if ( DECL_TYPE != -1 ) 
					yyval.p = yypvt[-1].pb->type_adj(yypvt[-0].t); 
				DECL_TYPE = 0;
			} break;
case 60:
# line 795 "gram.y"
{ 
				if ( DECL_TYPE != -1 ) 
			 		yyval.p = yypvt[-1].pb->name_adj(yypvt[-0].pn);
				DECL_TYPE = 0;
			} break;
case 61:
# line 800 "gram.y"
{ yyval.p = yypvt[-1].pb->base_adj(yypvt[-0].pb); } break;
case 62:
# line 801 "gram.y"
{ yyval.p = yypvt[-1].pb->base_adj(yypvt[-0].pb); } break;
case 63:
# line 803 "gram.y"
{ 
				if (DECL_TYPE == TYPE)
					yyval.p = yypvt[-1].pb->type_adj(yypvt[-0].t);  
				else
					yyval.p = yypvt[-1].pb->name_adj(yypvt[-0].pn); 
				DECL_TYPE = -1;
			} break;
case 64:
# line 814 "gram.y"
{yypvt[-2].el->add(new expr(ELIST,yypvt[-0].pe,NULL)) ; } break;
case 65:
# line 815 "gram.y"
{ yyval.el =
				     new elist(new expr(ELIST,yypvt[-0].pe,NULL)); } break;
case 66:
# line 819 "gram.y"
{yypvt[-0].pn->n_template_arg = name::template_actual_arg_dummy ;
		   yyval.pe = yypvt[-0].pn; /* keep yacc happy */ } break;
case 67:
# line 822 "gram.y"
{ yyval.pe = yypvt[-0].pe ; } break;
case 68:
# line 828 "gram.y"
{ yyval.p = end_enum(0,yypvt[-1].pn); } break;
case 69:
# line 829 "gram.y"
{ yyval.p = end_enum(yypvt[-3].pn,yypvt[-1].pn); } break;
case 70:
# line 830 "gram.y"
{ yyval.pb = (Pbase)yypvt[-0].pn->tp;} break;
case 71:
# line 831 "gram.y"
{ yyval.pb = (Pbase)yypvt[-0].pn->tp;} break;
case 72:
# line 835 "gram.y"
{	if (yypvt[-0].p) yyval.nl = new nlist(yypvt[-0].pn); } break;
case 73:
# line 837 "gram.y"
{	if( yypvt[-0].p)
					if (yypvt[-2].p)
						yypvt[-2].nl->add(yypvt[-0].pn);
					else
						yyval.nl = new nlist(yypvt[-0].pn);
			} break;
case 76:
# line 847 "gram.y"
{ yyval.pn = NULL ;} break;
case 79:
# line 855 "gram.y"
{ templp->collect(yypvt[-1].t, yypvt[-0].pn) ; } break;
case 80:
# line 857 "gram.y"
{ templp->collect(yypvt[-1].t, yypvt[-0].pn) ; } break;
case 81:
# line 859 "gram.y"
{templp->collect(Ndata(yypvt[-1].p,yypvt[-0].pn)); } break;
case 82:
# line 865 "gram.y"
{	yyval.p = yypvt[-0].pn; } break;
case 83:
# line 867 "gram.y"
{	Ptyp(yypvt[-1].p) = yypvt[-0].pn->tp;
				yypvt[-0].pn->tp = (Ptype)yypvt[-1].p;
				yyval.p = yypvt[-0].p;
			} break;
case 84:
# line 872 "gram.y"
{	Vtype(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = (Ptype)yypvt[-0].p;
			} break;
case 85:
# line 876 "gram.y"
{	Freturns(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = (Ptype)yypvt[-0].p;
			} break;
case 86:
# line 883 "gram.y"
{	yyval.p = yypvt[-0].pn; yyval.pn->tp = moe_type; } break;
case 87:
# line 885 "gram.y"
{	yyval.p = yypvt[-2].pn;
				yyval.pn->tp = moe_type;
				yyval.pn->n_initializer = yypvt[-0].pe;
			} break;
case 88:
# line 890 "gram.y"
{	yyval.p = 0; } break;
case 89:
# line 894 "gram.y"
{	
				ccl->mem_list = name_unlist(yypvt[-1].nl);
				end_cl();
				--in_class_decl;
				declTag = 1;
			} break;
case 90:
# line 901 "gram.y"
{	
				ccl->mem_list = name_unlist(yypvt[-2].nl);
				end_cl();
				--in_class_decl;
				error("`;' or declaratorX afterCD");
				lex_unget(yypvt[-0].t);
				/* lex_unget($4); but only one unget, sorry */
				declTag = 1;
			} break;
case 91:
# line 911 "gram.y"
{ 
				yyval.pb = (Pbase)yypvt[-0].pn->tp; 
				check_tag();
			} break;
case 92:
# line 916 "gram.y"
{ 
		    Pname p = parametrized_typename(yypvt[-3].pn,
						  (expr_unlist(yypvt[-1].el))) ;
                    yyval.pb = (Pbase)p->tp; 
                    check_tag(); } break;
case 93:
# line 923 "gram.y"
{
				 yyval.pb = (Pbase)yypvt[-0].pn->tp; 
				check_tag();
			
			} break;
case 94:
# line 930 "gram.y"
{ yyval.pbc = yypvt[-0].pbc; } break;
case 95:
# line 931 "gram.y"
{ yyval.pbc = 0; } break;
case 97:
# line 936 "gram.y"
{	if (yypvt[-0].pbc) { yyval.pbc = yypvt[-0].pbc; yyval.pbc->next = yypvt[-2].pbc; } } break;
case 98:
# line 939 "gram.y"
{ yyval.pbc = dobase(0,yypvt[-0].pn); } break;
case 99:
# line 940 "gram.y"
{ yyval.pbc = dobase(yypvt[-1].t,yypvt[-0].pn); } break;
case 100:
# line 941 "gram.y"
{ yyval.pbc = dobase(0,yypvt[-0].pn,yypvt[-1].t); } break;
case 101:
# line 942 "gram.y"
{ yyval.pbc = dobase(yypvt[-2].t,yypvt[-0].pn,yypvt[-1].t); } break;
case 102:
# line 943 "gram.y"
{ yyval.pbc = dobase(yypvt[-1].t,yypvt[-0].pn,yypvt[-2].t); } break;
case 103:
# line 947 "gram.y"
{	
				yyval.p = start_cl(yypvt[-1].t,0,0); 
				++in_class_decl;
			} break;
case 104:
# line 953 "gram.y"
{	
				yyval.p = start_cl(yypvt[-3].t,yypvt[-2].pn,yypvt[-1].pbc);
				++in_class_decl;
			} break;
case 105:
# line 959 "gram.y"
{	yyval.p = yypvt[-0].pn; } break;
case 107:
# line 965 "gram.y"
{  yyval.p = yypvt[-0].pn ; } break;
case 109:
# line 969 "gram.y"
{ extern void restore_fn_modified_tn(Pname) ;
				if (yypvt[-0].p) {
					if (yypvt[-1].p)
						yypvt[-1].nl->add_list(yypvt[-0].pn);
					else
						yyval.nl = new nlist(yypvt[-0].pn);
				        restore_fn_modified_tn(yypvt[-0].pn) ;
				}

			} break;
case 110:
# line 980 "gram.y"
{	extern void note_fn_modified_tn() ;
 				note_fn_modified_tn() ;
 				yyval.p = 0; } break;
case 117:
# line 992 "gram.y"
{	yyval.p = new name;
				yyval.pn->base = yypvt[-1].t;
			} break;
case 118:
# line 996 "gram.y"
{	Pname n = Ncopy(yypvt[-1].pn);
				n->n_qualifier = yypvt[-2].pn;
				n->base = PR;
				yyval.p = n;
			} break;
case 119:
# line 1002 "gram.y"
{	Pname n = Ncopy(yypvt[-1].pn);
				if (n->n_oper == TYPE) {
					error('s',"visibilityD for conversion operator");
					n->tp = Ptype(n->n_initializer);
					n->n_initializer = 0;
					n->n_oper = 0;
					sig_name(n);
				}
				n->n_qualifier = yypvt[-2].pn;
				n->base = PR;
				yyval.p = n;
			} break;
case 120:
# line 1031 "gram.y"
{	yyval.p = yypvt[-0].pn; } break;
case 121:
# line 1033 "gram.y"
{	yyval.p = Ncopy(yypvt[-0].pn);
				yyval.pn->n_oper = DTOR;
			} break;
case 122:
# line 1037 "gram.y"
{	yyval.p = new name(oper_name(yypvt[-0].t));
				yyval.pn->n_oper = yypvt[-0].t;
			} break;
case 123:
# line 1041 "gram.y"
{	Pname n = yypvt[-0].pn;
				n->string = "_type";
				n->n_oper = TYPE;
				n->n_initializer = Pexpr(n->tp);
				n->tp = 0;
				yyval.p = n;
			} break;
case 138:
# line 1064 "gram.y"
{	yyval.t = CALL; } break;
case 139:
# line 1065 "gram.y"
{	yyval.t = DEREF; } break;
case 145:
# line 1071 "gram.y"
{	yyval.t = NEW; } break;
case 146:
# line 1072 "gram.y"
{	yyval.t = DELETE; } break;
case 147:
# line 1073 "gram.y"
{	yyval.t = REF; } break;
case 148:
# line 1074 "gram.y"
{	yyval.t = CM; } break;
case 149:
# line 1075 "gram.y"
{	yyval.t = REFMUL;
					if (yypvt[-0].t == DOT) error(".* cannot be overloaded");
				} break;
case 150:
# line 1080 "gram.y"
{ yyval.pn = yypvt[-0].pn; } break;
case 151:
# line 1081 "gram.y"
{	error("CNs do not nest"); } break;
case 152:
# line 1082 "gram.y"
{	error("CNs do not nest"); } break;
case 153:
# line 1086 "gram.y"
{	Freturns(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = yypvt[-0].pt;
			} break;
case 154:
# line 1090 "gram.y"
{	yypvt[-2].pn->tp = new fct(yypvt[-2].pn->tp,0,1);
 			} break;
case 155:
# line 1094 "gram.y"
{	yypvt[-3].pn->tp = new fct(yypvt[-3].pn->tp,0,1);
 				Pfct(yypvt[-3].pn->tp)->f_const = 1;
 			} break;
case 156:
# line 1098 "gram.y"
{	Pname n = yypvt[-1].pn;
				yyval.p = Ncopy(n);
				if (ccl && strcmp(n->string,ccl->string)) n->hide();
				yyval.pn->n_oper = TNAME;
				Freturns(yypvt[-0].p) = yyval.pn->tp;
				yyval.pn->tp = yypvt[-0].pt;
			} break;
case 157:
# line 1110 "gram.y"
{	
				yypvt[-3].pn->tp = new fct(yypvt[-3].pn->tp,yypvt[-1].pn,1); 
 				in_arg_list = 0;
			} break;
case 158:
# line 1115 "gram.y"
{ 
				Pptr p = new ptr( PTR, 0 );
				Ptyp(p) = yypvt[-2].pn->tp;
				Freturns( yypvt[-0].p ) = Ptype(p);
				yypvt[-2].pn->tp = yypvt[-0].pt;
				yyval.p = yypvt[-2].pn;
				if (DECL_TYPE == -1) DECL_TYPE = 0;
			} break;
case 159:
# line 1124 "gram.y"
{	yyval.p = Ncopy(yypvt[-3].pn);
				yyval.pn->n_oper = TNAME;
				yyval.pn->tp = new fct(0,yypvt[-1].pn,1);
			} break;
case 160:
# line 1129 "gram.y"
{	yyval.p = Ncopy(yypvt[-2].pn);
 				yyval.pn->n_oper = TNAME;
				yyval.pn->tp = new fct(0,0,1);
			} break;
case 161:
# line 1135 "gram.y"
{	yyval.p = Ncopy(yypvt[-3].pn);
 				yyval.pn->n_oper = TNAME;
 				yyval.pn->tp = new fct(0,0,1);
 				Pfct(yypvt[-3].pn->tp)->f_const = 1;
			} break;
case 162:
# line 1141 "gram.y"
{	memptrdcl(yypvt[-3].pn,yypvt[-5].pn,yypvt[-0].pt,yypvt[-2].pn);
				yyval.p = yypvt[-2].p;
			} break;
case 164:
# line 1146 "gram.y"
{	yyval.p = Ncopy(yypvt[-0].pn);
				yyval.pn->n_qualifier = yypvt[-2].pn;
				error(ansi_opt?0:'w',"anachronism `.' used for qualification; please use `::'");
			} break;
case 165:
# line 1151 "gram.y"
{	yyval.p = yypvt[-0].p;
				if ( yypvt[-1].pn != sta_name ) {
    					set_scope(yypvt[-1].pn); 
    					yyval.pn->n_qualifier = yypvt[-1].pn;
				}
			} break;
case 166:
# line 1158 "gram.y"
{	
				if ( yypvt[-1].pn == sta_name ) 
     					error( ":: applied to CN%n", yypvt[-0].pn );
				yyval.p = Ncopy(yypvt[-0].pn);
				set_scope(yypvt[-1].pn);
				yyval.pn->n_oper = TNAME;
				yyval.pn->n_qualifier = yypvt[-1].pn;
			} break;
case 167:
# line 1167 "gram.y"
{	Ptyp(yypvt[-1].p) = yypvt[-0].pn->tp;
				yypvt[-0].pn->tp = yypvt[-1].pt;
				yyval.p = yypvt[-0].p;
			} break;
case 168:
# line 1172 "gram.y"
{	yyval.p = Ncopy(yypvt[-0].pn);
				yyval.pn->n_oper = TNAME;
				// cannot evaluate at this point: defer until data_dcl
				if ( in_typedef ) {
					defer_check = 1;
					in_tag = yypvt[-0].pn;
				}
				yypvt[-0].pn->hide();
				defer_check = 0;
				yyval.pn->tp = yypvt[-1].pt;
			} break;
case 169:
# line 1184 "gram.y"
{	yyval.p = Ncopy(yypvt[-1].pn);
				yyval.pn->n_oper = TNAME;
				if ( in_typedef ) {
     					defer_check = 1;
     					in_tag = yypvt[-0].pn;
				}
				yypvt[-1].pn->hide();
				defer_check = 0;
				yyval.pn->tp = yypvt[-0].pt;
			} break;
case 170:
# line 1195 "gram.y"
{	Vtype(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = yypvt[-0].pt;
			} break;
case 171:
# line 1212 "gram.y"
{ 
				yyval.p = yypvt[-1].p; 
				in_arg_list = 0;
			} break;
case 172:
# line 1219 "gram.y"
{	yyval.p = yypvt[-0].pn; } break;
case 173:
# line 1221 "gram.y"
{	yyval.p = Ncopy(yypvt[-0].pn);
				yyval.pn->n_oper = TNAME;
				yypvt[-0].pn->hide();
				yyval.pn->tp = yypvt[-1].pt;
			} break;
case 174:
# line 1227 "gram.y"
{	
				yyval.p = new name; 
				NOT_EXPECT_ID();
			} break;
case 175:
# line 1232 "gram.y"
{	Ptyp(yypvt[-1].p) = yypvt[-0].pn->tp;
				yypvt[-0].pn->tp = (Ptype)yypvt[-1].p;
				yyval.p = yypvt[-0].p;
			} break;
case 176:
# line 1237 "gram.y"
{	Vtype(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = (Ptype)yypvt[-0].p;
			} break;
case 177:
# line 1241 "gram.y"
{	Freturns(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = (Ptype)yypvt[-0].p;
			} break;
case 178:
# line 1257 "gram.y"
{ 
// error('d', "arg_lp arg_decl rp in_arg_list: %d", in_arg_list );
				yyval.p = yypvt[-1].p; 
				in_arg_list = 0;
			} break;
case 179:
# line 1265 "gram.y"
{	yyval.p = new name; } break;
case 180:
# line 1267 "gram.y"
{	Ptyp(yypvt[-1].p) = yypvt[-0].pn->tp;
				yypvt[-0].pn->tp = (Ptype)yypvt[-1].p;
				yyval.p = yypvt[-0].p;
                                NOT_EXPECT_ID();
			} break;
case 181:
# line 1273 "gram.y"
{	Vtype(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = (Ptype)yypvt[-0].p;
			} break;
case 182:
# line 1278 "gram.y"
{ yyval.p = new name; } break;
case 183:
# line 1280 "gram.y"
{	Ptyp(yypvt[-1].p) = yypvt[-0].pn->tp;
				yypvt[-0].pn->tp = (Ptype)yypvt[-1].p;
				yyval.p = yypvt[-0].p;
				NOT_EXPECT_ID();
			} break;
case 184:
# line 1286 "gram.y"
{	Vtype(yypvt[-0].p) = yypvt[-1].pn->tp;
				yypvt[-1].pn->tp = (Ptype)yypvt[-0].p;
			} break;
case 185:
# line 1290 "gram.y"
{	Freturns(yypvt[-0].p) = yypvt[-2].pn->tp;
				yypvt[-2].pn->tp = yypvt[-0].pt;
				yyval.p = yypvt[-2].p;
			} break;
case 186:
# line 1295 "gram.y"
{	Vtype(yypvt[-0].p) = yypvt[-2].pn->tp;
				yypvt[-2].pn->tp = yypvt[-0].pt;
				yyval.p = yypvt[-2].p;
			} break;
case 187:
# line 1302 "gram.y"
{	yyval.p = new name; } break;
case 188:
# line 1304 "gram.y"
{	Ptyp(yypvt[-1].p) = yypvt[-0].pn->tp;
				yypvt[-0].pn->tp = (Ptype)yypvt[-1].p;
				yyval.p = yypvt[-0].p;
			} break;
case 189:
# line 1314 "gram.y"
{
				yyval.p = 0; 
			} break;
case 190:
# line 1318 "gram.y"
{	
				if (yypvt[-0].p)
					if (yypvt[-1].p)
						yypvt[-1].sl->add(yypvt[-0].ps);
					else {
						yyval.sl =  new slist(yypvt[-0].ps);
						stmt_seen = 1;
					}
			} break;
case 191:
# line 1329 "gram.y"
{
				yyval.p = yypvt[-0].p;
				if (yypvt[-0].p)	stmt_seen = 1;
			} break;
case 192:
# line 1336 "gram.y"
{
				yyval.p = 0;
				check_decl();
			} break;
case 193:
# line 1343 "gram.y"
{	yyval.p = yypvt[-1].p;
			/*	if ($<pe>$ == dummy) error("empty condition");*/
				stmt_seen = 1;
			} break;
case 194:
# line 1350 "gram.y"
{	cd_vec[cdi] = cd;
				stmt_vec[cdi] = stmt_seen;
				tn_vec[cdi] = modified_tn;
				lcl_blk_vec[cdi++] = local_blk;
				lcl_tn_vec[cdi] = local_tn;
				local_blk = 0;
				local_tn = 0;
				cd = 0;
				stmt_seen = 0;
				modified_tn = 0;
			} break;
case 195:
# line 1362 "gram.y"
{	Pname n = name_unlist(cd);
				Pstmt ss = stmt_unlist(yypvt[-1].sl);
				yyval.p = new block(yypvt[-3].l,n,ss);
				if ( local_tn ) local_restore();
				if ( local_blk ) local_name();
				if (modified_tn) restore();
				cd = cd_vec[--cdi];
				stmt_seen = stmt_vec[cdi];
				modified_tn = tn_vec[cdi];
				local_tn = lcl_tn_vec[cdi];
				local_blk = lcl_blk_vec[cdi];
				if (cdi < 0) error('i',"block level(%d)",cdi);
				NOT_EXPECT_ID();
			} break;
case 196:
# line 1377 "gram.y"
{	yyval.p = new block(yypvt[-1].l,0,0); NOT_EXPECT_ID();} break;
case 197:
# line 1379 "gram.y"
{	yyval.p = new block(yypvt[-2].l,0,0); NOT_EXPECT_ID();} break;
case 198:
# line 1383 "gram.y"
{	yyval.p = new estmt(SM,curloc,yypvt[-0].pe,0);	} break;
case 199:
# line 1385 "gram.y"
{	yyval.p = new stmt(BREAK,yypvt[-0].l,0); } break;
case 200:
# line 1387 "gram.y"
{	yyval.p = new stmt(CONTINUE,yypvt[-0].l,0); } break;
case 201:
# line 1389 "gram.y"
{	yyval.p = new lstmt(GOTO,yypvt[-1].l,yypvt[-0].pn,0); } break;
case 202:
# line 1390 "gram.y"
{ stmt_seen=1; } break;
case 203:
# line 1391 "gram.y"
{	yyval.p = new estmt(DO,yypvt[-4].l,yypvt[-0].pe,yypvt[-2].ps); } break;
case 204:
# line 1393 "gram.y"
{	
				if (stmt_seen)
					yyval.p = new estmt(ASM,curloc,(Pexpr)yypvt[-1].s,0);
				else {
					Pname n = new name(make_name('A'));
					n->tp = new basetype(ASM,(Pname)yypvt[-1].s);
					if (cd)
						cd->add_list(n);
					else
						cd = new nlist(n);
					yyval.p = 0;
				}
			} break;
case 223:
# line 1429 "gram.y"
{ error("`;' missing afterS"); } break;
case 224:
# line 1431 "gram.y"
{	yyval.p = new estmt(SM,curloc,dummy,0); } break;
case 225:
# line 1433 "gram.y"
{/* $1 is the formal parameter name */
			 yyval.p = new estmt(SM_PARAM,curloc,yypvt[-1].pe,0);	} break;
case 226:
# line 1436 "gram.y"
{	yyval.p = new estmt(RETURN,yypvt[-2].l,yypvt[-1].pe,0); } break;
case 227:
# line 1438 "gram.y"
{
				error("local linkage specification");
				yyval.p = yypvt[-0].pn;
			} break;
case 228:
# line 1443 "gram.y"
{	Pname n = yypvt[-0].pn;
				if (n)
					if (stmt_seen) {
						yyval.p = new block(n->where,n,0);
						yyval.ps->base = DCL;
					}
					else {
						if (cd)
							cd->add_list(n);
						else
							cd = new nlist(n);
						yyval.p = 0;
					}
			} break;
case 229:
# line 1458 "gram.y"
{
				Pname n = yypvt[-0].pn;
				lex_unget(RC);
				error(&n->where,"%n's definition is nested (did you forget a ``}''?)",n);
				if (cd)
					cd->add_list(n);
				else
					cd = new nlist(n);
				yyval.p = 0;
			} break;
case 231:
# line 1470 "gram.y"
{	yyval.p = new ifstmt(yypvt[-2].l,yypvt[-1].pe,yypvt[-0].ps,0); } break;
case 232:
# line 1472 "gram.y"
{	yyval.p = new ifstmt(yypvt[-4].l,yypvt[-3].pe,yypvt[-2].ps,yypvt[-0].ps); } break;
case 233:
# line 1474 "gram.y"
{	yyval.p = new estmt(WHILE,yypvt[-2].l,yypvt[-1].pe,yypvt[-0].ps); } break;
case 234:
# line 1475 "gram.y"
{ stmt_seen=1; } break;
case 235:
# line 1476 "gram.y"
{	yyval.p = new forstmt(yypvt[-8].l,yypvt[-5].ps,yypvt[-4].pe,yypvt[-2].pe,yypvt[-0].ps); } break;
case 236:
# line 1478 "gram.y"
{	yyval.p = new estmt(SWITCH,yypvt[-2].l,yypvt[-1].pe,yypvt[-0].ps); } break;
case 237:
# line 1479 "gram.y"
{  yyval.pn = yypvt[-1].pn; stmt_seen=1; } break;
case 238:
# line 1480 "gram.y"
{	Pname n = yypvt[-1].pn;
				yyval.p = new lstmt(LABEL,n->where,n,yypvt[-0].ps);
			} break;
case 239:
# line 1483 "gram.y"
{ stmt_seen=1; } break;
case 240:
# line 1484 "gram.y"
{	if (yypvt[-2].pe == dummy) error("empty case label");
				yyval.p = new estmt(CASE,yypvt[-4].l,yypvt[-2].pe,yypvt[-0].ps);
			} break;
case 241:
# line 1487 "gram.y"
{ stmt_seen=1; } break;
case 242:
# line 1488 "gram.y"
{	yyval.p = new stmt(DEFAULT,yypvt[-3].l,yypvt[-0].ps); } break;
case 243:
# line 1493 "gram.y"
{	Pexpr e = expr_unlist(yypvt[-0].el);
				while (e && e->e1==dummy) {
					register Pexpr ee2 = e->e2;
					if (ee2) error("EX inEL");
					delete e;
					e = ee2;
				}
				yyval.p = e;
			} break;
case 244:
# line 1504 "gram.y"
{	yyval.el = new elist(new expr(ELIST,yypvt[-0].pe,0)); } break;
case 245:
# line 1506 "gram.y"
{	yypvt[-2].el->add(new expr(ELIST,yypvt[-0].pe,0)); } break;
case 247:
# line 1511 "gram.y"
{
  			  	if ( in_arg_list ) 
       			  		error( "syntax error: IrL not permitted in AL" );
  			  	else 
					init_seen = 1;
				Pexpr e;
				if (yypvt[-1].p)
					e = yypvt[-1].pe;
				else
					e = new expr(ELIST,dummy,0);
				yyval.p = new expr(ILIST,e,0);
			} break;
case 248:
# line 1526 "gram.y"
{	bbinop:	yyval.p = new expr(yypvt[-1].t,yypvt[-2].pe,yypvt[-0].pe); } break;
case 249:
# line 1527 "gram.y"
{	goto bbinop; } break;
case 250:
# line 1528 "gram.y"
{	goto bbinop; } break;
case 251:
# line 1529 "gram.y"
{	goto bbinop; } break;
case 252:
# line 1530 "gram.y"
{	goto bbinop; } break;
case 253:
# line 1531 "gram.y"
{	goto bbinop; } break;
case 254:
# line 1532 "gram.y"
{	goto bbinop; } break;
case 255:
# line 1533 "gram.y"
{ 	goto bbinop; } break;
case 256:
# line 1534 "gram.y"
{	goto bbinop; } break;
case 257:
# line 1535 "gram.y"
{	goto bbinop; } break;
case 258:
# line 1536 "gram.y"
{	goto bbinop; } break;
case 259:
# line 1537 "gram.y"
{	goto bbinop; } break;
case 260:
# line 1538 "gram.y"
{	goto bbinop; } break;
case 261:
# line 1539 "gram.y"
{	goto bbinop; } break;
case 262:
# line 1540 "gram.y"
{	goto bbinop; } break;
case 263:
# line 1541 "gram.y"
{	goto bbinop; } break;
case 264:
# line 1542 "gram.y"
{	goto bbinop; } break;
case 265:
# line 1544 "gram.y"
{	yyval.p = new qexpr(yypvt[-4].pe,yypvt[-2].pe,yypvt[-0].pe); } break;
case 266:
# line 1546 "gram.y"
{	yyval.p = new expr(DELETE,yypvt[-0].pe,0); } break;
case 267:
# line 1548 "gram.y"
{	yyval.p = new expr(DELETE,yypvt[-0].pe,yypvt[-2].pe); } break;
case 268:
# line 1550 "gram.y"
{	yyval.p = new expr(GDELETE,yypvt[-0].pe,0); } break;
case 269:
# line 1552 "gram.y"
{	yyval.p = new expr(GDELETE,yypvt[-0].pe,yypvt[-2].pe); } break;
case 271:
# line 1557 "gram.y"
{	binop:	yyval.p = new expr(yypvt[-1].t,yypvt[-2].pe,yypvt[-0].pe); } break;
case 272:
# line 1558 "gram.y"
{	goto binop; } break;
case 273:
# line 1559 "gram.y"
{	goto binop; } break;
case 274:
# line 1560 "gram.y"
{	goto binop; } break;
case 275:
# line 1561 "gram.y"
{	goto binop; } break;
case 276:
# line 1562 "gram.y"
{	goto binop; } break;
case 277:
# line 1563 "gram.y"
{	goto binop; } break;
case 278:
# line 1564 "gram.y"
{ 	goto binop; } break;
case 279:
# line 1565 "gram.y"
{	goto binop; } break;
case 280:
# line 1566 "gram.y"
{	goto binop; } break;
case 281:
# line 1567 "gram.y"
{	goto binop; } break;
case 282:
# line 1568 "gram.y"
{	goto binop; } break;
case 283:
# line 1569 "gram.y"
{	goto binop; } break;
case 284:
# line 1570 "gram.y"
{	goto binop; } break;
case 285:
# line 1571 "gram.y"
{	goto binop; } break;
case 286:
# line 1572 "gram.y"
{	goto binop; } break;
case 287:
# line 1573 "gram.y"
{	goto binop; } break;
case 288:
# line 1575 "gram.y"
{	yyval.p = new qexpr(yypvt[-4].pe,yypvt[-2].pe,yypvt[-0].pe); } break;
case 289:
# line 1577 "gram.y"
{	yyval.p = new expr(DELETE,yypvt[-0].pe,0); } break;
case 290:
# line 1579 "gram.y"
{	yyval.p = new expr(DELETE,yypvt[-0].pe,yypvt[-2].pe); } break;
case 291:
# line 1581 "gram.y"
{	yyval.p = new expr(GDELETE,yypvt[-0].pe,0); } break;
case 292:
# line 1583 "gram.y"
{	yyval.p = new expr(GDELETE,yypvt[-0].pe,yypvt[-2].pe); } break;
case 293:
# line 1584 "gram.y"
{ 
			init_seen = 0; 
			} break;
case 294:
# line 1588 "gram.y"
{	yyval.p = dummy; } break;
case 295:
# line 1591 "gram.y"
{ goto new1; } break;
case 296:
# line 1593 "gram.y"
{	new1:
				Ptype t = yypvt[-0].pn->tp;
				yyval.p = new texpr(NEW,t,0);
			} break;
case 297:
# line 1597 "gram.y"
{ goto new3; } break;
case 298:
# line 1599 "gram.y"
{	new3:
				Ptype t = yypvt[-0].pn->tp;
 				yyval.p = new texpr(GNEW,t,0);
 			} break;
case 299:
# line 1604 "gram.y"
{	yyval.p = new expr(yypvt[-0].t,yypvt[-1].pe,0); } break;
case 300:
# line 1606 "gram.y"
{	yyval.p = new texpr(CAST,yypvt[-1].pn->tp,yypvt[-0].pe); } break;
case 301:
# line 1608 "gram.y"
{	yyval.p = new expr(DEREF,yypvt[-0].pe,0); } break;
case 302:
# line 1610 "gram.y"
{	yyval.p = new expr(ADDROF,0,yypvt[-0].pe); } break;
case 303:
# line 1612 "gram.y"
{	yyval.p = new expr(UMINUS,0,yypvt[-0].pe); } break;
case 304:
# line 1614 "gram.y"
{	yyval.p = new expr(UPLUS,0,yypvt[-0].pe); } break;
case 305:
# line 1616 "gram.y"
{	yyval.p = new expr(NOT,0,yypvt[-0].pe); } break;
case 306:
# line 1618 "gram.y"
{	yyval.p = new expr(COMPL,0,yypvt[-0].pe); } break;
case 307:
# line 1620 "gram.y"
{	yyval.p = new expr(yypvt[-1].t,0,yypvt[-0].pe); } break;
case 308:
# line 1622 "gram.y"
{	yyval.p = new texpr(SIZEOF,0,yypvt[-0].pe); } break;
case 309:
# line 1624 "gram.y"
{	yyval.p = new texpr(SIZEOF,yypvt[-0].pn->tp,0); } break;
case 310:
# line 1626 "gram.y"
{	
 			yyval.p = new expr(DEREF,yypvt[-3].pe,yypvt[-1].pe);
			} break;
case 311:
# line 1630 "gram.y"
{	yyval.p = new ref(REF,yypvt[-2].pe,yypvt[-0].pn); } break;
case 312:
# line 1632 "gram.y"
{	yyval.p = new expr(yypvt[-1].t,yypvt[-2].pe,yypvt[-0].pe); } break;
case 313:
# line 1634 "gram.y"
{	yyval.p = new ref(REF,yypvt[-2].pe,Ncopy(yypvt[-0].pn)); } break;
case 314:
# line 1636 "gram.y"
{	yyval.p = new ref(DOT,yypvt[-2].pe,yypvt[-0].pn); } break;
case 315:
# line 1638 "gram.y"
{	yyval.p = new ref(DOT,yypvt[-2].pe,Ncopy(yypvt[-0].pn)); } break;
case 317:
# line 1641 "gram.y"
{
			if ( init_seen )
     				error( "syntax error:IrL illegal within ()");
			} break;
case 318:
# line 1647 "gram.y"
{	yyval.p = yypvt[-1].p; } break;
case 319:
# line 1649 "gram.y"
{	yyval.p = zero; } break;
case 320:
# line 1651 "gram.y"
{	yyval.p = new expr(ICON,0,0);
				yyval.pe->string = copy_if_need_be(yypvt[-0].s);
			} break;
case 321:
# line 1655 "gram.y"
{	yyval.p = new expr(FCON,0,0);
				yyval.pe->string = copy_if_need_be(yypvt[-0].s);
			} break;
case 322:
# line 1659 "gram.y"
{	yyval.p = new expr(STRING,0,0);
				yyval.pe->string = copy_if_need_be(yypvt[-0].s);
			} break;
case 323:
# line 1663 "gram.y"
{	yyval.p = new expr(CCON,0,0);
				yyval.pe->string = copy_if_need_be(yypvt[-0].s);
			} break;
case 324:
# line 1667 "gram.y"
{	yyval.p = new expr(THIS,0,0); } break;
case 325:
# line 1671 "gram.y"
{ 	yyval.p = new texpr(VALUE,tok_to_type(yypvt[-3].t),yypvt[-1].pe); } break;
case 326:
# line 1673 "gram.y"
{	yyval.p = new texpr(VALUE,yypvt[-3].pn->tp,yypvt[-1].pe); } break;
case 327:
# line 1674 "gram.y"
{ goto new2; } break;
case 328:
# line 1676 "gram.y"
{	new2:
				Ptype t = yypvt[-0].pn->tp;
				yyval.p=new texpr(NEW,t,0);
				yyval.pe->e2 = yypvt[-2].pe;
			} break;
case 329:
# line 1681 "gram.y"
{ goto new4; } break;
case 330:
# line 1683 "gram.y"
{	new4:
				Ptype t = yypvt[-0].pn->tp;
				yyval.p = new texpr(GNEW,t,0);
				yyval.pe->e2 = yypvt[-2].pe;
			} break;
case 331:
# line 1689 "gram.y"
{	
				Pexpr ee = yypvt[-1].pe;
				Pexpr e = yypvt[-3].pe;
				if (e->base==NEW || e->base==GNEW)
					e->e1 = ee;
				else
					yyval.p = new call(e,ee);
			} break;
case 332:
# line 1701 "gram.y"
{
		    yyval.pn =parametrized_typename(yypvt[-3].pn,
						  (expr_unlist(yypvt[-1].el))) ; } break;
case 333:
# line 1709 "gram.y"
{       yyval.pn = yypvt[-0].pn; } break;
case 334:
# line 1711 "gram.y"
{       yyval.pn = sta_name; } break;
case 335:
# line 1713 "gram.y"
{yyval.pn = yypvt[-1].pn ; } break;
case 336:
# line 1716 "gram.y"
{	yyval.p = yypvt[-0].pn; } break;
case 337:
# line 1718 "gram.y"
{	yyval.p = Ncopy(yypvt[-0].pn);
				yyval.pn->n_qualifier = yypvt[-1].pn;
			} break;
case 338:
# line 1722 "gram.y"
{	yyval.p = new name(oper_name(yypvt[-0].t));
				yyval.pn->n_oper = yypvt[-0].t;
			} break;
case 339:
# line 1726 "gram.y"
{	yyval.p = new name(oper_name(yypvt[-0].t));
				yyval.pn->n_oper = yypvt[-0].t;
				yyval.pn->n_qualifier = yypvt[-2].pn;
			} break;
case 340:
# line 1731 "gram.y"
{	yyval.p = yypvt[-0].p;
				sig_name(yyval.pn);
			} break;
case 341:
# line 1735 "gram.y"
{	yyval.p = yypvt[-0].p;
				sig_name(yyval.pn);
				yyval.pn->n_qualifier = yypvt[-2].pn;
			} break;
case 342:
# line 1740 "gram.y"
{	
				if (strcmp(yypvt[-2].pn->string,yypvt[-0].pn->string)) error("syntax error: inconsistent destructor notation");
				yyval.p = new name(oper_name(DTOR));
				yyval.pn->n_oper = DTOR;
				yyval.pn->n_qualifier = yypvt[-2].pn;
			} break;
case 343:
# line 1752 "gram.y"
{ yyval.p = Ncast(yypvt[-2].p,yypvt[-1].pn); } break;
case 344:
# line 1755 "gram.y"
{ check_cast(); } break;
case 345:
# line 1759 "gram.y"
{
				TOK t = yypvt[-0].t;

				switch (t) {
				case FRIEND:
				case OVERLOAD:
				case REGISTER:
				case STATIC:
				case EXTERN:
				case AUTO:
				case VIRTUAL:
					error("%k in operatorT",t);
					t = INT;
					
				}

				yyval.p = new basetype(t,0);

			} break;
case 346:
# line 1778 "gram.y"
{ yyval.p = new basetype(TYPE,yypvt[-0].pn); } break;
case 347:
# line 1780 "gram.y"
{ 
				if ( DECL_TYPE != -1 ) 
					yyval.p = yypvt[-1].pb->type_adj(yypvt[-0].t); 
				DECL_TYPE = 0;
			} break;
case 348:
# line 1786 "gram.y"
{ 
				if ( DECL_TYPE != -1 ) 
			 		yyval.p = yypvt[-1].pb->name_adj(yypvt[-0].pn);
				DECL_TYPE = 0;
			} break;
case 349:
# line 1793 "gram.y"
{ yyval.p = Ncast(yypvt[-1].p,yypvt[-0].pn); } break;
case 350:
# line 1796 "gram.y"
{ yyval.p = Ncast(yypvt[-1].p,yypvt[-0].pn); } break;
case 351:
# line 1799 "gram.y"
{	yyval.p = Ndata(yypvt[-1].p,yypvt[-0].pn); } break;
case 352:
# line 1801 "gram.y"
{	yyval.p = Ndata(yypvt[-3].p,yypvt[-2].pn);
				yyval.pn->n_initializer = yypvt[-0].pe;
			} break;
case 353:
# line 1807 "gram.y"
{ 
				check_decl(); 
				in_arg_list=1; 
				if ( in_class_decl ) in_mem_fct = 1; 
			} break;
case 354:
# line 1815 "gram.y"
{ 
			yyval.p = new fct(0,name_unlist(yypvt[-2].nl),yypvt[-1].t); 
			in_arg_list=0;
		    } break;
case 355:
# line 1820 "gram.y"
{ 
			yyval.p = new fct(0,name_unlist(yypvt[-3].nl),yypvt[-2].t); 
			in_arg_list=0;
			if (yypvt[-0].t != CONST)
			if ( la_look() != SM ) {
				error("syntax error: unexpected%k (did you forget a `;'?)",yypvt[-0].t);
                        	{ YYSTYPE y; y.t = SM; la_backup(SM,y); }
                        	lex_unget(yypvt[-0].t);
 			}
				else error("syntax error: unexpected%k",yypvt[-0].t);
			Pfct(yyval.pt)->f_const = 1;
		    } break;
case 356:
# line 1835 "gram.y"
{
				if (yypvt[-0].p)
					if (yypvt[-2].p)
						yypvt[-2].nl->add(yypvt[-0].pn);
					else {
						error("AD syntax");
						yyval.nl = new nlist(yypvt[-0].pn); 
					}
				else
					error("AD syntax");
			} break;
case 357:
# line 1847 "gram.y"
{
				if (yypvt[-0].p) yyval.nl = new nlist(yypvt[-0].pn); 
			} break;
case 359:
# line 1853 "gram.y"
{	yyval.p = 0; } break;
case 360:
# line 1857 "gram.y"
{	yyval.t = 1; } break;
case 361:
# line 1859 "gram.y"
{	yyval.t = ELLIPSIS; } break;
case 362:
# line 1861 "gram.y"
{	yyval.t = ELLIPSIS; } break;
case 363:
# line 1865 "gram.y"
{
			yyval.p = new ptr(PTR,0); 
			EXPECT_ID();
			} break;
case 364:
# line 1870 "gram.y"
{
			yyval.p = new ptr(RPTR,0); 
			EXPECT_ID();
			} break;
case 365:
# line 1875 "gram.y"
{	yyval.p = doptr(PTR,yypvt[-0].t); } break;
case 366:
# line 1877 "gram.y"
{	
				switch ( yypvt[-0].t ) {
				case CONST:
                                     yypvt[-1].pp->rdo = 1; break;
				case VOLATILE:
				     error('w',"\"volatile\" not implemented (ignored)");
				     break;
				default:
				    error( "syntax error: *%k", yypvt[-0].t );
				}
				yyval.p = yypvt[-1].pp; 
			} break;
case 367:
# line 1890 "gram.y"
{	yyval.p = doptr(RPTR,yypvt[-0].t); } break;
case 368:
# line 1892 "gram.y"
{ goto memptr1 ;
                   } break;
case 369:
# line 1896 "gram.y"
{
                        memptr1:
			yyval.p = new ptr(PTR,0);
			yyval.pp->memof = Pclass(Pbase(yypvt[-0].pn->tp)->b_name->tp);
			EXPECT_ID();
			} break;
case 370:
# line 1903 "gram.y"
{
	            yypvt[-1].t = yypvt[-0].t ;
                    goto memptr2 ;
                   } break;
case 371:
# line 1908 "gram.y"
{	memptr2:
				yyval.p = doptr(PTR,yypvt[-0].t);
				yyval.pp->memof = Pclass(Pbase(yypvt[-1].pn->tp)->b_name->tp);
			} break;
case 372:
# line 1914 "gram.y"
{ yyval.p = new vec(0,yypvt[-1].pe!=dummy?yypvt[-1].pe:0 ); } break;
case 373:
# line 1915 "gram.y"
{ yyval.p = new vec(0,0); } break;
	}
	goto yystack;  /* stack new state and value */
}
