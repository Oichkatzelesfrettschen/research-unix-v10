#
#	BASIC MAKEFILE
#
#	"@(#) makefile: V 1.49 11/10/83"
#

CC=cc
HOSTCC=/bin/cc
LD=ld
PPFLAGS=-DDFSIZ=8192
REL=1
CFLAGS= -c -O
LDFLAGS=
FFLAG=
YACCFLAGS=-d
LIBM=-lm
LIBPW=-lPW
LIBLD=
LINT=lint
LINTFLAGS=-lm
XREF=cxref
XREFFLAGS=-c -t -s
PRINTER=lp

BINDIR=../bin
INSTALLDIR=../bin

OFILES=aputvars.o atof1.o basic.o bed.o bedutil.o bfiles.o binops.o\
	breakpoint.o bsys.o call.o class.o copy.o def.o delete.o dim.o encode.o \
	error.o eval.o fetch.o for.o getdims.o go.o if.o input.o \
	let.o lex.o list.o load.o npredefs.o on.o option.o path.o pathopen.o print.o \
	prnt_using.o putvars.o read.o reseq.o run.o \
	save.o sigcatch.o sing.o spredefs.o \
        strspace.o sub.o symtab.o sys.o while.o write.o

CFILES=aputvars.c atof1.c basic.c bed.c bedutil.c bfiles.c binops.c\
	breakpoint.c bsys.c call.c class.c copy.c def.c delete.c dim.c encode.c \
	error.c fetch.c for.c getdims.c go.c if.c input.c \
	let.c lex.c list.c load.c npredefs.c on.c option.c path.c pathopen.c print.c \
	prnt_using.c putvars.c read.c reseq.c run.c \
	save.c sigcatch.c sing.c spredefs.c\
	strspace.c sub.c symtab.c sys.c while.c write.c

HFILES=bas.h tokens.h


all		: $(OFILES)
		$(CC) $(LDFLAGS) -o basic $(OFILES) $(LIBM) $(LIBLD) $(LIBPW)

basic.tmp	: $(OFILES) update.c
		$(HOSTCC) -o throw update.c
		echo "$(INSTALLDIR)/basic" | ./throw
		rm -f throw
		$(CC) $(CFLAGS) path.c
		$(LD) -r -o basic.tmp $(OFILES)

aputvars.o	: aputvars.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. aputvars.c

atof1.o		: atof1.c
		$(CC) $(CFLAGS) $(PPFLAGS) -I. atof1.c

basic.o		: basic.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. basic.c

bed.o		: bed.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. bed.c

bedutil.o	: bedutil.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. bedutil.c

bfiles.o	: bfiles.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. bfiles.c

binops.o	: binops.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. binops.c

breakpoint.o	: breakpoint.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. breakpoint.c

bsys.o		: bsys.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. bsys.c

call.o		: call.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. call.c

class.o		: class.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. class.c

copy.o		: copy.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. copy.c

def.o		: def.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. def.c

delete.o	: delete.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. delete.c

dim.o		: dim.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. dim.c

encode.o	: encode.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. encode.c

error.o		: error.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. error.c

eval.o		: eval.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. eval.c

eval.c tokens.h	: eval.y
		yacc $(YACCFLAGS) eval.y

#		************ IMPORTANT NOTE *********************
#		*						*
#		*   The yacc generated parser may call		*
#		*   itself recursively, hence it is necessary	*
#		*   that all of the writable global data be	*
#		*   made local to yyparse().  The eval.edit	*
#		*   edit script accomplishes this but it is	*
#		*   HIGHLY DEPENDANT UPON THE SKELETON PARSER	*
#		*   GENERATED BY YACC.  The final four lines	*
#		*   of the edit script make the parser tables	*
#		*   arrays of shorts rather than ints.		*
#		*						*
#		*************************************************
		@echo "/global variables/-1" 	>  eval.edit
		@echo ".,.+15m/{/" 		>> eval.edit
		@echo "/typedef int yytabelem/" >> eval.edit
		@echo ".s/int/short/" 		>> eval.edit
		@echo "/register int \*yyxi/" 	>> eval.edit
		@echo ".s/int/yytabelem/" 	>> eval.edit
		@echo "w" >> eval.edit
		@echo "q" >> eval.edit
		ed y.tab.c < eval.edit > /dev/null
		@rm -f eval.edit
		mv y.tab.c eval.c
		mv y.tab.h tokens.h

fetch.o		: fetch.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. fetch.c

for.o		: for.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. for.c

getdims.o	: getdims.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. getdims.c

go.o		: go.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. go.c

if.o		: if.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. if.c

input.o		: input.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. input.c

let.o		: let.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. let.c

lex.o		: lex.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. lex.c

list.o		: list.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. list.c

load.o		: load.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. load.c

npredefs.o	: npredefs.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. npredefs.c

on.o		: on.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. on.c

option.o	: option.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. option.c

path.o		: path.c
		$(CC) $(CFLAGS) $(PPFLAGS) -I. path.c

pathopen.o	: pathopen.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. pathopen.c

print.o		: print.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. print.c

prnt_using.o	: prnt_using.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. prnt_using.c

putvars.o	: putvars.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. putvars.c

read.o		: read.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. read.c

reseq.o		: reseq.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. reseq.c

run.o		: run.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. run.c

save.o		: save.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. save.c

sigcatch.o	: sigcatch.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. sigcatch.c

sing.o		: sing.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. sing.c

spredefs.o	: spredefs.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. spredefs.c

strspace.o	: strspace.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. strspace.c

sub.o		: sub.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. sub.c

symtab.o	: symtab.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. symtab.c

sys.o		: sys.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. sys.c

while.o		: while.c bas.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. while.c

write.o		: write.c bas.h tokens.h
		$(CC) $(CFLAGS) $(PPFLAGS) -I. write.c

#
#
lint.out	: $(CFILES) eval.c $(HFILES)
		$(LINT) $(LINTFLAGS) -I. $(CFILES) eval.c > lint.out
		wc -l lint.out
#
#
xref.out	: $(CFILES) eval.c $(HFILES)
		$(XREF) $(XREFFLAGS) -I. $(CFILES) eval.c > xref.out
#
#
install		: basic.tmp expunge
		./expunge 1
		$(CC) $(FFLAG) $(LDFLAGS) -o basic basic.tmp $(LIBM) $(LIBLD) $(LIBPW)
		./expunge 2
		-rm -f expunge
		-rm -f $(BINDIR)/basic
		cp basic $(BINDIR)/basic

expunge		: expunge.c
		$(HOSTCC) -o expunge -DREL$(REL) -O expunge.c -lld

$(BINDIR)/basic	: basic
		-rm -f $(BINDIR)/basic
		cp basic $(BINDIR)/basic

save		: $(BINDIR)/basic
		-rm -f $(BINDIR)/basic.back
		cp $(BINDIR)/basic $(BINDIR)/basic.back

uninstall	: $(BINDIR)/basic.back
		-rm -f $(BINDIR)/basic
		cp $(BINDIR)/basic.back $(BINDIR)/basic

shrink		:
		-rm -f $(OFILES) ./basic.tmp ./expunge
		-rm -f basic

listing		: $(HFILES) $(CFILES) eval.y
		pr -f $(HFILES) $(CFILES) eval.y makefile | $(PRINTER)
