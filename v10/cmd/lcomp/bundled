# To unbundle, sh this file
echo 3binstr.c 1>&2
sed 's/.//' >3binstr.c <<'//GO.SYSIN DD 3binstr.c'
-From research!whuxld!bjb Thu Mar  8 13:23 EST 1984*
-To: research!seki!pjw
-
-/*
- *	static char *ID_opsout = "@(#) ops.out: 1.5 4/26/83";
- */
-{"mcomb",	IS25|INSTRB,	DYAOP1-256,	8,	0x8bL},
-{"mcomh",	IS25|INSTRH,	DYAOP1-256,	8,	0x8aL},
-{"mcomw",	IS25|INSTRW,	DYAOP1-256,	8,	0x88L},
-{"movzbh",	IS25|INSTRBH,	DYAOP7-256,	8,	0x87L},
-{"movzbw",	IS25|INSTRBW,	DYAOP7-256,	8,	0x87L},
-{"movzhw",	IS25|INSTRHW,	DYAOP7-256,	8,	0x86L},
-{"pushzb",	IS25|INSTRB,	PUSHOP1-256,	8,	0x87L},
-{"pushzh",	IS25|INSTRHW,	PUSHOP1-256,	8,	0x84L},
-{"movaw",	IS25|INSTRW,	DYAOP2-256,	8,	0x4L},
-{"pushaw",	IS25|INSTRW,	MONOP2-256,	8,	0xe0L},
-{"andb2",	IS25|INSTRB,	DYAOP1-256,	8,	0xbbL},
-{"andh2",	IS25|INSTRH,	DYAOP1-256,	8,	0xbaL},
-{"andw2",	IS25|INSTRW,	DYAOP1-256,	8,	0xb8L},
-{"andb3",	IS25|INSTRB,	TRIOP1-256,	8,	0xfbL},
-{"andh3",	IS25|INSTRH,	TRIOP1-256,	8,	0xfaL},
-{"andw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xf8L},
-{"orb2",	IS25|INSTRB,	DYAOP1-256,	8,	0xb3L},
-{"orh2",	IS25|INSTRH,	DYAOP1-256,	8,	0xb2L},
-{"orw2",	IS25|INSTRW,	DYAOP1-256,	8,	0xb0L},
-{"orb3",	IS25|INSTRB,	TRIOP1-256,	8,	0xf3L},
-{"orh3",	IS25|INSTRH,	TRIOP1-256,	8,	0xf2L},
-{"orw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xf0L},
-{"xorb2",	IS25|INSTRB,	DYAOP1-256,	8,	0xb7L},
-{"xorh2",	IS25|INSTRH,	DYAOP1-256,	8,	0xb6L},
-{"xorw2",	IS25|INSTRW,	DYAOP1-256,	8,	0xb4L},
-{"xorb3",	IS25|INSTRB,	TRIOP1-256,	8,	0xf7L},
-{"xorh3",	IS25|INSTRH,	TRIOP1-256,	8,	0xf6L},
-{"xorw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xf4L},
-{"bitb",	IS25|INSTRB,	CMPOP2-256,	8,	0x3bL},
-{"bith",	IS25|INSTRH,	CMPOP2-256,	8,	0x3aL},
-{"bitw",	IS25|INSTRW,	CMPOP2-256,	8,	0x38L},
-{"llsw2",	IS25|INSTRW,	DYAOP3-256,	16,	0xd0L},
-{"llsw3",	IS25|INSTRW,	SHFTOP1-256,	16,	0xd0L},
-{"lrsw2",	IS25|INSTRBW,	DYAOP3-256,	16,	0xd4L},
-{"lrsw3",	IS25|INSTRBW,	SHFTOP1-256,	16,	0xd4L},
-{"movb",	IS25|INSTRB,	DYAOP4-256,	16,	0x8387L},
-{"movh",	IS25|INSTRH,	DYAOP4-256,	16,	0x8286L},
-{"movw",	IS25|INSTRW,	DYAOP4-256,	16,	0x8084L},
-{"movbbh",	IS25|INSTRBH,	DYAOP5-256,	16,	0x87E7L},
-{"movbbw",	IS25|INSTRBW,	DYAOP5-256,	16,	0x87E7L},
-{"movbhw",	IS25|INSTRHW,	DYAOP5-256,	8,	0x86L},
-{"movthb",	IS25|INSTRHB,	DYAOP5-256,	8,	0x86L},
-{"movtwb",	IS25|INSTRWB,	DYAOP5-256,	8,	0x84L},
-{"movtwh",	IS25|INSTRWH,	DYAOP5-256,	8,	0x84L},
-{"mnegh",	IS25|INSTRH,	DYAOP1-256,	8,	0x8eL},
-{"mnegw",	IS25|INSTRW,	DYAOP1-256,	8,	0x8cL},
-{"pushbb",	IS25|INSTRBW,	PUSHOP1-256,	8,	0x87L},
-{"pushbh",	IS25|INSTRH,	PUSHOP1-256,	8,	0x86L},
-{"pushw",	IS25|INSTRW,	MONOP1-256,	8,	0xa0L},
-{"addb2",	IS25|INSTRB,	DYAOP6-256,	16,	0x939fL},
-{"addh2",	IS25|INSTRH,	DYAOP6-256,	16,	0x929eL},
-{"addw2",	IS25|INSTRW,	DYAOP6-256,	16,	0x909cL},
-{"addb3",	IS25|INSTRB,	TRIOP1-256,	8,	0xdfL},
-{"addh3",	IS25|INSTRH,	TRIOP1-256,	8,	0xdeL},
-{"addw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xdcL},
-{"subb2",	IS25|INSTRB,	DYAOP6-256,	16,	0x97bfL},
-{"subh2",	IS25|INSTRH,	DYAOP6-256,	16,	0x96beL},
-{"subw2",	IS25|INSTRW,	DYAOP6-256,	16,	0x94bcL},
-{"subb3",	IS25|INSTRB,	TRIOP1-256,	8,	0xffL},
-{"subh3",	IS25|INSTRH,	TRIOP1-256,	8,	0xfeL},
-{"subw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xfcL},
-{"mulw2",	IS25|INSTRW,	DYAOP1-256,	8,	0xa8L},
-{"umulw2",	IS25|INSTRW,	DYAOP8-256,	8,	0xa8L},
-{"mulw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xe8L},
-{"umulw3",	IS25|INSTRW,	TRIOP2-256,	8,	0xe8L},
-{"divw2",	IS25|INSTRW,	DYAOP1-256,	8,	0xacL},
-{"udivw2",	IS25|INSTRW,	DYAOP8-256,	8,	0xacL},
-{"divw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xecL},
-{"udivw3",	IS25|INSTRW,	TRIOP2-256,	8,	0xecL},
-{"modw2",	IS25|INSTRW,	DYAOP1-256,	8,	0xa4L},
-{"umodw2",	IS25|INSTRW,	DYAOP8-256,	8,	0xa4L},
-{"modw3",	IS25|INSTRW,	TRIOP1-256,	8,	0xe4L},
-{"umodw3",	IS25|INSTRW,	TRIOP2-256,	8,	0xe4L},
-#if	FLOAT
-{"fadds2",	INSTRW,		FPDYAOP1-256,	8,	0x31L},
-{"fsubs2",	INSTRW,		FPDYAOP1-256,	8,	0x41L},
-{"fmuls2",	INSTRW,		FPDYAOP1-256,	8,	0x51L},
-{"fdivs2",	INSTRW,		FPDYAOP1-256,	8,	0x61L},
-{"movhs",	INSTRHW,		FPDYAOP2-256,	8,	0x71L},
-{"movws",	INSTRW,		FPDYAOP2-256,	8,	0x81L},
-{"movss",	INSTRW,		FPDYAOP1-256,	8,	0x91L},
-{"movsd",	INSTRW,		FPDYAOP1-256,	8,	0xa1L},
-{"movsh",	INSTRW,		FPDYAOP1-256,	8,	0xb1L},
-{"movtsh",	INSTRW,		FPDYAOP1-256,	8,	0xc1L},
-{"movsw",	INSTRW,		FPDYAOP1-256,	8,	0xd1L},
-{"movtsw",	INSTRW,		FPDYAOP1-256,	8,	0xe1L},
-{"fcmps",	INSTRW,		FPCMPOP1-256,	8,	0xf1L},
-{"faddd2",	INSTRD,		FPDYAOP1-256,	8,	0x35L},
-{"fsubd2",	INSTRD,		FPDYAOP1-256,	8,	0x45L},
-{"fmuld2",	INSTRD,		FPDYAOP1-256,	8,	0x55L},
-{"fdivd2",	INSTRD,		FPDYAOP1-256,	8,	0x65L},
-{"movhd",	INSTRH,		FPDYAOP2-256,	8,	0x75L},
-{"movwd",	INSTRW,		FPDYAOP2-256,	8,	0x85L},
-{"movds",	INSTRD,		FPDYAOP1-256,	8,	0x95L},
-{"movdd",	INSTRD,		FPDYAOP1-256,	8,	0xa5L},
-{"movdh",	INSTRD,		FPDYAOP1-256,	8,	0xb5},
-{"movtdh",	INSTRD,		FPDYAOP1-256,	8,	0xc5},
-{"movdw",	INSTRD,		FPDYAOP1-256,	8,	0xd5L},
-{"movtdw",	INSTRD,		FPDYAOP1-256,	8,	0xe5L},
-{"fcmpd",	INSTRD,		FPCMPOP1-256,	8,	0xf5L},
-{"fadds3",	INSTRW,		FPTRIOP1-256,	8,	0x39L},
-{"fsubs3",	INSTRW,		FPTRIOP1-256,	8,	0x49L},
-{"fmuls3",	INSTRW,		FPTRIOP1-256,	8,	0x59L},
-{"fdivs3",	INSTRW,		FPTRIOP1-256,	8,	0x69L},
-{"faddd3",	INSTRD,		FPTRIOP1-256,	8,	0x79L},
-{"fsubd3",	INSTRD,		FPTRIOP1-256,	8,	0x89L},
-{"fmuld3",	INSTRD,		FPTRIOP1-256,	8,	0x99L},
-{"fdivd3",	INSTRD,		FPTRIOP1-256,	8,	0xa9L},
-#endif
-{"alsw2",	IS25|INSTRBW,	DYAOP3-256,	16,	0xc0L},
-{"alsw3",	IS25|INSTRBW,	SHFTOP1-256,	16,	0xc0L},
-{"arsw2",	IS25|INSTRW,	DYAOP3-256,	16,	0xc4L},
-{"arsw3",	IS25|INSTRW,	SHFTOP1-256,	16,	0xc4L},
-{"cmpb",	IS25|INSTRB,	CMPOP1-256,	16,	0x2b3fL},
-{"cmph",	IS25|INSTRH,	CMPOP1-256,	16,	0x2a3eL},
-{"cmpw",	IS25|INSTRW,	CMPOP1-256,	16,	0x283cL},
-{"jbc",		IS25|INSTRW,	JMBOP1-256,	8,	0x38L},
-{"jbs",		IS25|INSTRW,	JMBOP1-256,	8,	0x38L},
-{"rsb",		IS25|INSTRW,	ZEROP1-256,	8,	0x78L},
-{"acjl",	IS25|INSTRW,	LOOPOP1-256,	24,	0xb83c4bL},
-{"acjlu",	IS25|INSTRW,	LOOPOP1-256,	24,	0xb83c5bL},
-{"acjle",	IS25|INSTRW,	LOOPOP1-256,	24,	0xb83c4fL},
-{"acjleu",	IS25|INSTRW,	LOOPOP1-256,	24,	0xb83c5fL},
-{"atjnzb",	IS25|INSTRW,	LOOPOP2-256,	8,	0x2bL},
-{"atjnzh",	IS25|INSTRW,	LOOPOP2-256,	8,	0x2aL},
-{"atjnzw",	IS25|INSTRW,	LOOPOP2-256,	8,	0x28L},
-{"movblb",	IS25|INSTRB,	BLOCKOP-256,	8,	0x87L},
-{"movblh",	IS25|INSTRH,	BLOCKOP-256,	8,	0x86L},
-{"movblw",	IS25|INSTRW,	ZEROP1-256,	16,	0x3019L},
-{"call",	IS25|INSTRW,	CALOP1-256,	8,	0x2cL},
-{"save",	IS25|INSTRW,	SAVOP1-256,	8,	0x10L},
-{"ret",		IS25|INSTRW,	RETOP1-256,	16,	0x0818L},
-{"insv",	IS25|INSTRW,	FLDOP1-256,	8,	0xc8L},
-{"extzv",	IS25|INSTRW,	FLDOP2-256,	8,	0xccL},
-{"jz",		IS25|INSTRW,	JMPOP1-256,	16,	0x777fL},
-{"jnz",		IS25|INSTRW,	JMPOP1-256,	16,	0x7f77L},
-{"jpos",	IS25|INSTRW,	JMPOP1-256,	16,	0x4f47L},
-{"jnpos",	IS25|INSTRW,	JMPOP1-256,	16,	0x474fL},
-{"jneg",	IS25|INSTRW,	JMPOP1-256,	16,	0x434bL},
-{"jnneg",	IS25|INSTRW,	JMPOP1-256,	16,	0x4b43L},
-{"je",		IS25|INSTRW,	JMPOP1-256,	16,	0x777fL},
-{"jne",		IS25|INSTRW,	JMPOP1-256,	16,	0x7f77L},
-{"jl",		IS25|INSTRW,	JMPOP1-256,	16,	0x434bL},
-{"jle",		IS25|INSTRW,	JMPOP1-256,	16,	0x474fL},
-{"jg",		IS25|INSTRW,	JMPOP1-256,	16,	0x4f47L},
-{"jge",		IS25|INSTRW,	JMPOP1-256,	16,	0x4b43L},
-{"jlu",		IS25|INSTRW,	JMPOP1-256,	16,	0x535bL},
-{"jleu",	IS25|INSTRW,	JMPOP1-256,	16,	0x575fL},
-{"jgu",		IS25|INSTRW,	JMPOP1-256,	16,	0x5f57L},
-{"jgeu",	IS25|INSTRW,	JMPOP1-256,	16,	0x5b53L},
-{"jmp",		IS25|INSTRW,	JMPOP1-256,	8,	0x7bL},
-{"jsb",		IS25|INSTRW,	JSBOP1-256,	16,	0x3437L},
-{"BEB",		INSTRB,		JMPOP1-256,	8,	0x7fL},
-{"BNEB",	INSTRB,		JMPOP1-256,	8,	0x77L},
-{"BLB",		INSTRB,		JMPOP1-256,	8,	0x4bL},
-{"BLEB",	INSTRB,		JMPOP1-256,	8,	0x4fL},
-{"BGB",		INSTRB,		JMPOP1-256,	8,	0x47L},
-{"BGEB",	INSTRB,		JMPOP1-256,	8,	0x43L},
-{"BLUB",	INSTRB,		JMPOP1-256,	8,	0x5bL},
-{"BLEUB",	INSTRB,		JMPOP1-256,	8,	0x5fL},
-{"BGUB",	INSTRB,		JMPOP1-256,	8,	0x57L},
-{"BGEUB",	INSTRB,		JMPOP1-256,	8,	0x53L},
-{"BRB",		INSTRB,		JMPOP1-256,	8,	0x7bL},
-{"BSBB",	INSTRB,		BSBOP1-256,	8,	0x37L},
-{"BEH",		INSTRH,		JMPOP1-256,	8,	0x7eL},
-{"BNEH",	INSTRH,		JMPOP1-256,	8,	0x76L},
-{"BLH",		INSTRH,		JMPOP1-256,	8,	0x4aL},
-{"BLEH",	INSTRH,		JMPOP1-256,	8,	0x4eL},
-{"BGH",		INSTRH,		JMPOP1-256,	8,	0x46L},
-{"BGEH",	INSTRH,		JMPOP1-256,	8,	0x42L},
-{"BLUH",	INSTRH,		JMPOP1-256,	8,	0x5aL},
-{"BLEUH",	INSTRH,		JMPOP1-256,	8,	0x5eL},
-{"BGUH",	INSTRH,		JMPOP1-256,	8,	0x56L},
-{"BGEUH",	INSTRH,		JMPOP1-256,	8,	0x52L},
-{"BRH",		INSTRH,		JMPOP1-256,	8,	0x7aL},
-{"BSBH",	INSTRH,		BSBOP1-256,	8,	0x36L},
-{"CALL",	INSTRW,		CALOP2-256,	8,	0x2cL},
-{"SAVE",	INSTRW,		SAVOP2-256,	8,	0x10L},
-{"RESTORE",	INSTRW,		SAVOP2-256,	8,	0x18L},
-{"RET",		INSTRW, 	ZEROP1-256,	8,	0x08L},
-{"GATE",	INSTRW,		ZEROP1-256,	16,	0x3061L},
-{"RETG",	INSTRW,		ZEROP1-256,	16,	0x3045L},
-{"CALLPS",	INSTRW,		ZEROP1-256,	16,	0x30acL},
-{"RETPS",	INSTRW,		ZEROP1-256,	16,	0x30c8L},
-{"MVERNO",	INSTRW,		ZEROP1-256,	16,	0x3009L}, /* 12 */
-{"DISVJMP",	INSTRW,		ZEROP1-256,	16,	0x3013L},
-{"ENBVJMP",	INSTRW,		ZEROP1-256,	16,	0x300dL},
-{"STREND",	INSTRW,		ZEROP1-256,	16,	0x301fL},
-{"STRCPY",	INSTRW,		ZEROP1-256,	16,	0x3035L},
-{"SLFTST",	INSTRW,		ZEROP1-256,	16,	0x303cL},
-{"WAIT",	INSTRW,		ZEROP1-256,	8,	0x2fL},
-{"BPT",		INSTRW, 	ZEROP1-256,	8,	0x2eL},
-{"SWAPWI",	INSTRW,		MONOP1-256,	8,	0x1cL},
-{"SWAPHI",	INSTRH,		MONOP1-256,	8,	0x1eL},
-{"SWAPBI",	INSTRB,		MONOP1-256,	8,	0x1fL},
-{"POPW",	INSTRW,		MONOP3-256,	8,	0x20L},
-{"TSTW",	INSTRW,		MONOP1-256,	8,	0x28L},
-{"TSTH",	INSTRH,		MONOP1-256,	8,	0x2aL},
-{"TSTB",	INSTRB,		MONOP1-256,	8,	0x2bL},
-{"RGEQ",	INSTRW,		ZEROP1-256,	8,	0x40L},
-{"RGEQU",	INSTRW,		ZEROP1-256,	8,	0x50L},
-{"RGTR",	INSTRW,		ZEROP1-256,	8,	0x44L},
-{"RLSS",	INSTRW,		ZEROP1-256,	8,	0x48L},
-{"RLSSU",	INSTRW,		ZEROP1-256,	8,	0x58L},
-{"RLEQ",	INSTRW,		ZEROP1-256,	8,	0x4cL},
-{"RCC",		INSTRW,		ZEROP1-256,	8,	0x50L},
-{"RGTRU",	INSTRW,		ZEROP1-256,	8,	0x54L},
-{"RCS",		INSTRW,		ZEROP1-256,	8,	0x58L},
-{"RLEQU",	INSTRW,		ZEROP1-256,	8,	0x5cL},
-{"RVC",		INSTRW,		ZEROP1-256,	8,	0x60L},
-{"BVCH",	INSTRH,		JMPOP1-256,	8,	0x62L},
-{"BVCB",	INSTRB,		JMPOP1-256,	8,	0x63L},
-{"RVS",		INSTRW,		ZEROP1-256,	8,	0x68L},
-{"BVSH",	INSTRH,		JMPOP1-256,	8,	0x6aL},
-{"BVSB",	INSTRB,		JMPOP1-256,	8,	0x6bL},
-{"BCCB",	INSTRB,		JMPOP1-256,	8,	0x53L},
-{"BCSB",	INSTRB,		JMPOP1-256,	8,	0x5bL},
-{"BCCH",	INSTRH,		JMPOP1-256,	8,	0x52L},
-{"BCSH",	INSTRH,		JMPOP1-256,	8,	0x5aL},
-{"BEQLBX",	INSTRB,		JMPOP1-256,	8,	0x6fL},
-{"BEQLHX",	INSTRH,		JMPOP1-256,	8,	0x6eL},
-{"BNEQBX",	INSTRB,		JMPOP1-256,	8,	0x67L},
-{"BNEQHX",	INSTRH,		JMPOP1-256,	8,	0x66L},
-{"JMP",		INSTRW,		JMPOP1-256,	8,	0x24L},
-{"JSB",		INSTRW,		JSBOP2-256,	8,	0x34L},
-{"RNEQ",	INSTRW,		ZEROP1-256,	8,	0x74L},
-{"RNEQU",	INSTRW,		ZEROP1-256,	8,	0x64L},
-{"NOP",		INSTRW,		ZEROP1-256,	8,	0x70L},
-{"NOP3",	INSTRW,		ZEROP1-256,	24,	0x720000L},
-{"NOP2",	INSTRW,		ZEROP1-256,	16,	0x7300L},
-{"REQL",	INSTRW,		ZEROP1-256,	8,	0x7cL},
-{"REQLU",	INSTRW,		ZEROP1-256,	8,	0x6cL},
-{"CLRW",	INSTRW,		MONOP1-256,	8,	0x80L},
-{"CLRH",	INSTRH,		MONOP1-256,	8,	0x82L},
-{"CLRB",	INSTRB,		MONOP1-256,	8,	0x83L},
-{"MNEGB",	INSTRB,		DYAOP1-256,	8,	0x8fL},
-{"INCW",	INSTRW,		MONOP1-256,	8,	0x90L},
-{"INCH",	INSTRH,		MONOP1-256,	8,	0x92L},
-{"INCB",	INSTRB,		MONOP1-256,	8,	0x93L},
-{"DECW",	INSTRW,		MONOP1-256,	8,	0x94L},
-{"DECH",	INSTRH,		MONOP1-256,	8,	0x96L},
-{"DECB",	INSTRB,		MONOP1-256,	8,	0x97L},
-{"MODH2",	INSTRH,		DYAOP1-256,	8,	0xa6L},
-{"MODB2",	INSTRB,		DYAOP1-256,	8,	0xa7L},
-{"MULH2",	INSTRH,		DYAOP1-256,	8,	0xaaL},
-{"MULB2",	INSTRB,		DYAOP1-256,	8,	0xabL},
-{"DIVH2",	INSTRH,		DYAOP1-256,	8,	0xaeL},
-{"DIVB2",	INSTRB,		DYAOP1-256,	8,	0xafL},
-{"ALSW3",	INSTRW,		TRIOP1-256,	8,	0xc0L},
-{"ARSW3",	INSTRW,		TRIOP1-256,	8,	0xc4L},
-{"ARSH3",	INSTRH,		TRIOP1-256,	8,	0xc6L},
-{"ARSB3",	INSTRB,		TRIOP1-256,	8,	0xc7L},
-{"LLSW3",	INSTRW,		TRIOP1-256,	8,	0xd0L},
-{"LLSH3",	INSTRH,		TRIOP1-256,	8,	0xd2L},
-{"LLSB3",	INSTRB,		TRIOP1-256,	8,	0xd3L},
-{"LRSW3",	INSTRW,		TRIOP1-256,	8,	0xd4L},
-{"ROTW",	INSTRW,		TRIOP1-256,	8,	0xd8L},
-{"MODH3",	INSTRH,		TRIOP1-256,	8,	0xe6L},
-{"MODB3",	INSTRB,		TRIOP1-256,	8,	0xe7L},
-{"MULH3",	INSTRH,		TRIOP1-256,	8,	0xeaL},
-{"MULB3",	INSTRB,		TRIOP1-256,	8,	0xebL},
-{"DIVH3",	INSTRH,		TRIOP1-256,	8,	0xeeL},
-{"DIVB3",	INSTRB,		TRIOP1-256,	8,	0xefL},
-{"MCOMB",	INSTRB,		DYAOP1-256,	8,	0x8bL},
-{"MCOMH",	INSTRH,		DYAOP1-256,	8,	0x8aL},
-{"MCOMW",	INSTRW,		DYAOP1-256,	8,	0x88L},
-{"MOVTRW",	INSTRW,		DYAOP2-256,	8,	0xcL},
-{"MOVAW",	INSTRW,		DYAOP2-256,	8,	0x4L},
-{"PUSHAW",	INSTRW,		MONOP2-256,	8,	0xe0L},
-{"ANDB2",	INSTRB,		DYAOP1-256,	8,	0xbbL},
-{"ANDH2",	INSTRH,		DYAOP1-256,	8,	0xbaL},
-{"ANDW2",	INSTRW,		DYAOP1-256,	8,	0xb8L},
-{"ANDB3",	INSTRB,		TRIOP1-256,	8,	0xfbL},
-{"ANDH3",	INSTRH,		TRIOP1-256,	8,	0xfaL},
-{"ANDW3",	INSTRW,		TRIOP1-256,	8,	0xf8L},
-{"ORB2",	INSTRB,		DYAOP1-256,	8,	0xb3L},
-{"ORH2",	INSTRH,		DYAOP1-256,	8,	0xb2L},
-{"ORW2",	INSTRW,		DYAOP1-256,	8,	0xb0L},
-{"ORB3",	INSTRB,		TRIOP1-256,	8,	0xf3L},
-{"ORH3",	INSTRH,		TRIOP1-256,	8,	0xf2L},
-{"ORW3",	INSTRW,		TRIOP1-256,	8,	0xf0L},
-{"XORB2",	INSTRB,		DYAOP1-256,	8,	0xb7L},
-{"XORH2",	INSTRH,		DYAOP1-256,	8,	0xb6L},
-{"XORW2",	INSTRW,		DYAOP1-256,	8,	0xb4L},
-{"XORB3",	INSTRB,		TRIOP1-256,	8,	0xf7L},
-{"XORH3",	INSTRH,		TRIOP1-256,	8,	0xf6L},
-{"XORW3",	INSTRW,		TRIOP1-256,	8,	0xf4L},
-{"BITB",	INSTRB,		CMPOP2-256,	8,	0x3bL},
-{"BITH",	INSTRH,		CMPOP2-256,	8,	0x3aL},
-{"BITW",	INSTRW,		CMPOP2-256,	8,	0x38L},
-{"MOVB",	INSTRB,		DYAOP4-256,	8,	0x87L},
-{"MOVH",	INSTRH,		DYAOP4-256,	8,	0x86L},
-{"MOVW",	INSTRW,		DYAOP4-256,	8,	0x84L},
-{"MNEGH",	INSTRH,		DYAOP1-256,	8,	0x8eL},
-{"MNEGW",	INSTRW,		DYAOP1-256,	8,	0x8cL},
-{"PUSHW",	INSTRW,		MONOP1-256,	8,	0xa0L},
-{"ADDB2",	INSTRB,		DYAOP6-256,	8,	0x9fL},
-{"ADDH2",	INSTRH,		DYAOP6-256,	8,	0x9eL},
-{"ADDW2",	INSTRW,		DYAOP6-256,	8,	0x9cL},
-{"ADDB3",	INSTRB,		TRIOP1-256,	8,	0xdfL},
-{"ADDH3",	INSTRH,		TRIOP1-256,	8,	0xdeL},
-{"ADDW3",	INSTRW,		TRIOP1-256,	8,	0xdcL},
-{"SUBB2",	INSTRB,		DYAOP6-256,	8,	0xbfL},
-{"SUBH2",	INSTRH,		DYAOP6-256,	8,	0xbeL},
-{"SUBW2",	INSTRW,		DYAOP6-256,	8,	0xbcL},
-{"SUBB3",	INSTRB,		TRIOP1-256,	8,	0xffL},
-{"SUBH3",	INSTRH,		TRIOP1-256,	8,	0xfeL},
-{"SUBW3",	INSTRW,		TRIOP1-256,	8,	0xfcL},
-{"MULW2",	INSTRW,		DYAOP1-256,	8,	0xa8L},
-{"MULW3",	INSTRW,		TRIOP1-256,	8,	0xe8L},
-{"DIVW2",	INSTRW,		DYAOP1-256,	8,	0xacL},
-{"DIVW3",	INSTRW,		TRIOP1-256,	8,	0xecL},
-{"MODW2",	INSTRW,		DYAOP1-256,	8,	0xa4L},
-{"MODW3",	INSTRW,		TRIOP1-256,	8,	0xe4L},
-{"CMPB",	INSTRB,		CMPOP1-256,	8,	0x3fL},
-{"CMPH",	INSTRH,		CMPOP1-256,	8,	0x3eL},
-{"CMPW",	INSTRW,		CMPOP1-256,	8,	0x3cL},
-{"RSB",		INSTRW,		ZEROP1-256,	8,	0x78L},
-{"MOVBLW",	INSTRW,		ZEROP1-256,	16,	0x3019L},
-{"INSFW",	INSTRW,		FLDOP4-256,	8,	0xc8L},
-{"INSFH",	INSTRH,		FLDOP4-256,	8,	0xcaL},
-{"INSFB",	INSTRB,		FLDOP4-256,	8,	0xcbL},
-{"EXTFW",	INSTRW,		FLDOP4-256,	8,	0xccL},
-{"EXTFH",	INSTRH,		FLDOP4-256,	8,	0xceL},
-{"EXTFB",	INSTRB,		FLDOP4-256,	8,	0xcfL},
-{"EXTOP",	INSTRX,		SIMOP-256,	8,	0x14L},
-{"getsm",	INSTRX,		ZEROP1-256,	8,	0x1L},
-{"putsm",	INSTRX,		ZEROP1-256,	8,	0x11L},
-{"ungetsm",	INSTRX,		ZEROP1-256,	8,	0x21L},
-{"r0",		DUMMY,		REGISTER-256,	4,	0x0L},
-{"r1",		DUMMY,		REGISTER-256,	4,	0x1L},
-{"r2",		DUMMY,		REGISTER-256,	4,	0x2L},
-{"r3",		DUMMY,		REGISTER-256,	4,	0x3L},
-{"r4",		DUMMY,		REGISTER-256,	4,	0x4L},
-{"r5",		DUMMY,		REGISTER-256,	4,	0x5L},
-{"r6",		DUMMY,		REGISTER-256,	4,	0x6L},
-{"r7",		DUMMY,		REGISTER-256,	4,	0x7L},
-{"r8",		DUMMY,		REGISTER-256,	4,	0x8L},
-{"fp",		DUMMY,		REGISTER-256,	4,	0x9L},
-{"ap",		DUMMY,		REGISTER-256,	4,	0xaL},
-{"psw",		DUMMY,		REGISTER-256,	4,	0xbL},
-{"sp",		DUMMY,		REGISTER-256,	4,	0xcL},
-{"pcbp",	DUMMY,		REGISTER-256,	4,	0xdL},
-{"isp",		DUMMY,		REGISTER-256,	4,	0xeL},
-{".globl",	PSEUDO,		PSGLOBAL-256,	0,	0x0L},
-{".comm",	PSEUDO, 	PSCOMM-256,	0,	0x0L},
-{".set",	PSEUDO,		PSSET-256,	0,	0x0L},
-{".zero",	PSEUDO,		PSZERO-256,	0,	0x0L},
-{".bss",	BSS,		PSBSS-256,	0,	0x0L},
-{".file",	PSEUDO,		PSFILE-256,	0,	0x0L},
-{".align",	PSEUDO,		PSALIGN-256,	0,	0x0L},
-{".byte",	PSEUDO,		PSBYTE-256,	0,	0x0L},
-{".half",	PSEUDO,		PSHALF-256,	0,	0x0L},
-{".word",	PSEUDO,		PSWORD-256,	0,	0x0L},
-#if	FLOAT
-{".float",	PSEUDO,		PSFLOAT-256,	0,	0x0L},
-{".double",	PSEUDO,		PSDOUBLE-256,	0,	0x0L},
-#endif
-{".def",	PSEUDO,		PSDEF-256,	0,	0x0L},
-{".val",	PSEUDO,		PSVAL-256,	0,	0x0L},
-{".scl",	PSEUDO,		PSSCL-256,	0,	0x0L},
-{".type",	PSEUDO,		PSTYPE-256,	0,	0x0L},
-{".tag",	PSEUDO,		PSTAG-256,	0,	0x0L},
-{".line",	PSEUDO,		PSLINE-256,	0,	0x0L},
-{".size",	PSEUDO,		PSSIZE-256,	0,	0x0L},
-{".dim",	PSEUDO,		PSDIM-256,	0,	0x0L},
-{".endef",	PSEUDO,		PSENDEF-256,	0,	0x0L},
-{".ln",		PSEUDO,		PSLN-256,	0,	0x0L},
-{".text",	TXT,		SECTIONN-256,	0,	0x0L},
-{".data",	DAT,		SECTIONN-256,	0,	0x0L},
-{"sbyte",	DUMMY,		EXPTYPE-256,	8,	0x7L},
-{"ubyte",	DUMMY,		EXPTYPE-256,	8,	0x3L},
-{"byte",	DUMMY,		EXPTYPE-256,	8,	0x7L},
-{"shalf",	DUMMY,		EXPTYPE-256,	8,	0x6L},
-{"half",	DUMMY,		EXPTYPE-256,	8,	0x6L},
-{"uhalf",	DUMMY,		EXPTYPE-256,	8,	0x2L},
-{"sword",	DUMMY,		EXPTYPE-256,	8,	0x4L},
-{"word",	DUMMY,		EXPTYPE-256,	8,	0x4L},
-{"uword",	DUMMY,		EXPTYPE-256,	8,	0x0L},
-
//GO.SYSIN DD 3binstr.c
echo 5bb.c 1>&2
sed 's/.//' >5bb.c <<'//GO.SYSIN DD 5bb.c'
-#define unsafe 1	/* pretend killing all but C is as good as killing
-			 * all condition codes */
-#ifdef unsafe
-#define E	(C|K)
-#else
-#define E	K
-#endif
-#include "stdio.h"
-#include "instr.c"
-#include "ctype.h"
-struct inst *index[128];
-
-#define SBBLK	1	/* looking for the start of a basic block */
-#define SINST	2	/* thinking about generating a tally */
-#define SPRO	3	/* thinking about generating prolog code */
-#define SMAYBE	4	/* seen _, thinking about SPRO */
-
-#define MAXLA	5	/* max no. of lines that can be read for lookahead */
-
-FILE *outs, *fd, *outl;	/* outs goes to assembler, outl is for listing */
-extern FILE *popen();
-char line[256], fname[256];	/* file names must fit in fname */
-
-char labuf[5][256];		/* look ahead needed for 5.0 stab entries */
-int lastla, lookahead;
-char begfcn[] = "	.def	.bf";	/* 5.0 stab entry */
-
-int lineno, lastline;
-int base=0;
-
-int cnt;
-int state = SBBLK;
-char *ptr, *curarg;
-char curdir[256];
-
-main(argc, argv)
-char **argv;
-{	int i;
-	if(argc <= 1) {
-		fprintf(stderr, "no files given\n");
-		exit(1);
-	}
-	for(i = 0; insts[i].iname; i++)
-		;
-	for(; i >= 0; i--)
-		index[insts[i].iname[0]] = insts + i;
-	fd = popen("pwd", "r");
-	for(i = 0; i < sizeof(curdir) && !feof(fd); i++)
-		curdir[i] = getc(fd);
-	curdir[i-2] = 0;	/* thisdir\n */
-	fclose(fd);
-	for(i = 1; i < argc; i++) {
-		if(setfd(argv[i]))	/* fix fd, outs, outl */
-			doarg();	/* do the work */
-	}
-	exit(0);
-}
-
-setfd(s)
-char *s;
-{	char outnams[24], outnaml[24];
-	fname[0] = 0;
-	cnt = 3;
-	if(fd != NULL)
-		fclose(fd);
-	if(outs != NULL)
-		fclose(outs);
-	if(outl != NULL)
-		fclose(outl);
-	sprintf(outnams, "X%s", s);
-	sprintf(outnaml, "%sL", s);
-	lastline = lineno = 0;
-	fd = fopen(s, "r");
-	if(fd == NULL) {
-		perror(s);
-		return(0);
-	}
-	outs = fopen(outnams, "w");
-	if(outs == NULL) {
-		perror(outnams);
-		return(0);
-	}
-	outl = fopen(outnaml, "w");
-	if(outl == NULL) {
-		perror(outnaml);
-		return(0);
-	}
-	curarg = s;
-	return(1);
-}
-
-doarg()
-{	struct inst *x, *firstword();
-
-	state = SBBLK;
-	lookahead = 0;		/* empty buffer */
-	lastla = 0;
-	for(;;) {
-		if (lookahead != lastla){
-			strcpy(line,labuf[ (lookahead++) % MAXLA ] );
-			if (lookahead == lastla) lookahead = lastla = 0;
-		}
-		else
-			(void) fgets(line, sizeof(line), fd);
-		if(feof(fd))
-			break;
-		for(ptr = line; isspace(*ptr); *ptr++)
-			;
-		if(*ptr == 0 || *ptr == '#')
-			continue;
-		testlabel();
-		/* deal with symbol table info */
-		if(*ptr == '.') {
-			stab();
-			fprintf(outs, "	%s", ptr);
-			continue;
-		}
-		if(*ptr == 0 || *ptr == '\n')
-			continue;
-		x = firstword();
-		if(x == 0){
-			printf("unknown inst: %s\n",ptr);
-			continue;
-		}
-#ifdef u3b
-		if ((state == SMAYBE) && !strncmp(ptr,"save",4)){
-			state = SPRO;
-			getlnum();	/* 5.0 true line # */
-		}
-#endif
-		if(state == SPRO)
-			prolog(x);
-		if(state == SINST)
-			tally(x);
-		if(state == SBBLK && (x->type & JUMP))
-			state = SINST;
-		outinstr();
-		if(x->type & BYTE)
-			fixinstr(x);
-		fprintf(outs, "	%s", ptr);
-	}
-	finish();
-}
-
-
-getlnum(){	/* get true line number from 5.0 sdb info */
-	char *la;
-	int l;
-
-	/* get true line number by looking ahead */
-	/* this is necessary for 5.0 sdb output  */
-	do
-		(void) fgets(labuf[l = ((lastla++)%MAXLA)], sizeof(line), fd);
-	while (!feof(fd) && strncmp(begfcn, labuf[l],
-			9) && (lookahead != (lastla)%MAXLA ));
-	if ( strncmp(begfcn, labuf[l], 9) ) 
-		return;		/* bad input  or not 5.0 */
-	la = labuf[l];
-	while ( *la != '\0' ){
-		while ( *la != ';' && *la != '\0') la++;
-		if ( *la == ';' ) la++;
-		while ( isspace(*la) ) la++;
-		if ( !strncmp(la, ".line" , 5) ){
-			lineno = base = atoi( la + 5 );
-			return;
-		}
-	}
-}
-
-
-/* unbelievable variability in sdb info */
-stab()
-{	char buf[128];
-	int i, j, k;
-
-#ifndef u3b
-	if(state == SMAYBE && strncmp(ptr, ".word", 5) == 0) {
-		state = SPRO;
-		getlnum();
-		return;
-	}
-#endif
-
-	if((i = *(ptr + 1)) != 's' && i != 'f' && i != 'l')
-		return;
-	/* real compiler output */
-	if(sscanf(ptr, ".stabs \"%[^\"]\", %o", buf, &i) == 2 && i == 0144)
-		strcat(fname, buf);
-	else if(sscanf(ptr, ".stabd %o,%o,%o", &i, &j, &k) == 3 && i == 0104)
-		lineno = k;
-	/* pwb 3.0 */
-	else if(sscanf(ptr, ".stab %[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%d",
-		buf, buf+2, buf+4, buf+6, buf+8, buf+10, buf+12, buf+14, &i)
-		== 9 && i == 144) {
-			for(i = k = 0; buf[i] ; i++)
-				if(buf[i] == '\'')
-					buf[k++] = buf[++i];
-			buf[k] = 0;
-			strcat(fname, buf);
-		}
-	else if(sscanf(ptr, ".stab %[0,]%d,%d,%d", buf,&i, &j, &k) == 4
-		&& i == 104)
-		lineno = k;
-	/* pwb 5.0 */
- 	else if(sscanf(ptr," .file \"%[^\"]\"", buf) == 1)
-		strcat(fname, buf);
- 	else if(sscanf(ptr, " .ln %d",&k) == 1)
-		lineno = k + base - 1;
-}
-
-testlabel()
-{	char *p;
-	int i;
-
-for(;;){
-	for(p = ptr; *p; p++) {
-		if(*p == ':')
-			break;
-		if(!isalnum(*p) && *p != '_' && *p != '.')
-			return;
-	}
-	if(*p == 0)
-		return;
-	*p++ = 0;	/* that is overwriting the : */
-	fprintf(outs, "%s:\n", ptr);
-	if (lineno != lastline){
-		for (i=lastline+1; i < lineno ; i++)	/* allign label with right inst */
-			fprintf(outl, "0 %s: %d\n", fname, i);
-		lastline = lineno - 1;
-	}
-	fprintf(outl, "%d %s:\n", 4*(cnt - 1), ptr);
-#ifdef u3b
-	if(*ptr != '.')
-#else
-	if(*ptr == '_' )
-#endif
-		state = SMAYBE;
-	else
-		if(state != SPRO)
-			state = SINST;
-	for(ptr = p; isspace(*ptr); ptr++)
-		;
-	}	/* L68:L70: ... */
-}
-
-struct inst *
-firstword()
-{	char buf[sizeof(line)], *p, *q;
-	struct inst *x;
-	for(p = buf, q = ptr; isalnum(*q); )
-		*p++ = *q++;
-	if(p == buf)
-		return((struct inst *)0);
-	*p = 0;
-	for(x = index[buf[0]]; x && x->iname[0] == buf[0]; x++)
-		if(strcmp(buf, x->iname) == 0)
-			return(x);
-	return(0);
-}
-
-outinstr()
-{	int i;
-	for(i = lastline + 1; i < lineno; i++)
-		fprintf(outl, "0 %s: %d\n", fname, i);
-	if (lastline != lineno){
-		fprintf(outl, "%d %s: %d\n", 4*(cnt - 1), fname, lineno);
-		lastline = lineno;
-	}
-	fprintf(outl, "%d	%s", 4*(cnt - 1), ptr);
-}
-
-#ifdef u3b
-
-/* 3b code  ***********************************/
-tally(x)
-struct inst *x;
-{
-	if(x->type & E)
-		fprintf(outs, "	addw2 &1,locprof+%d\n", 4*cnt++);
-	else {
-		fprintf(outs, "	stsm &1,savecc\n");
-		fprintf(outs, "	gcc %%r0\n");
-		fprintf(outs, "	addw2 &1,locprof+%d\n", 4*cnt++);
-		fprintf(outs, "	scc %%r0\n");
-		fprintf(outs, "	lsm &1,savecc\n");
-	}
-	state = SBBLK;
-}
-
-prolog(x)	/* no liveness test, presumes can't get here by jump */
-struct inst *x;
-{	int i;
-	fprintf(outs, "	.data\n");
-	fprintf(outs, "	.globl proFptr\n");	/* the global chain */
-	fprintf(outs, "	.globl savecc\n");
-	fprintf(outs, "	.text\n");
-	fprintf(outs, "	cmpw &0,locprof+4\n");
-	fprintf(outs, "	jne L%da\n", i = cnt);
-	fprintf(outs, "	movw proFptr,locprof+4\n");
-	fprintf(outs, "	movaw locprof,proFptr\n");
-	fprintf(outs, "L%da: addw2 &1,locprof+%d\n", i, 4*cnt++);
-	state = SBBLK;
-}
-
-finish()
-{	int i;
-	fprintf(outs, "	.data\n");
-	fprintf(outs, "	.align	4\n");
-	fprintf(outs, "locprof:\n");
-	fprintf(outs, "	.word	%d\n", cnt);
-	fprintf(outs, "	.word 0\n");
-	fprintf(outs, "	.word L%db\n", cnt);
-	fprintf(outs, "	.zero %d\n", 4 * cnt);
-	fprintf(outs, "L%db: .byte ", cnt);
-	for(i = 0; curdir[i]; i++)
-		fprintf(outs, "	0x%x,", curdir[i]);
-	fprintf(outs, "	0x%x\n", '/');
-	fprintf(outs, "	.byte ");
-	if(fname[0])
-		for(i = 0; fname[i]; i++)
-			fprintf(outs, "	0x%x,", fname[i]);
-	else
-		for(i = 0; curarg[i]; i++)
-			fprintf(outs, "	0x%x,", curarg[i]);
-	fprintf(outs, "0\n");
-}
-
-#else
-
-/*  Vax code  **************************/
-tally(x)
-struct inst *x;
-{
-	if(x->type & E)
-		fprintf(outs, "	incl locprof+%d\n", 4*cnt++);
-	else {
-		fprintf(outs, "	movpsl -(sp)\n");
-		fprintf(outs, "	incl locprof+%d\n", 4*cnt++);
-		fprintf(outs, "	movw (sp)+,(sp)\n");
-		fprintf(outs, "	bicpsw $0xff\n");
-		fprintf(outs, "	bispsw (sp)+\n");
-		/* thanks to kirk mckusick */
-	}
-	state = SBBLK;
-}
-
-
-prolog(x)	/* no liveness test, presumes can't get here by jump */
-struct inst *x;
-{	int i;
-	fprintf(outs, "	.data\n");
-	fprintf(outs, "	.comm _proFptr,4\n");	/* the global chain */
-	fprintf(outs, "	.text\n");
-	/*if(!(x->type & E))
-		fprintf(outs, "	movpsl -(sp)\n");*/
-	fprintf(outs, "	tstl locprof+4\n");
-	fprintf(outs, "	bneq L%da\n", i = cnt);
-	fprintf(outs, "	movl _proFptr,locprof+4\n");
-	fprintf(outs, "	moval locprof,_proFptr\n");
-	fprintf(outs, "L%da: incl locprof+%d\n", i, 4*cnt++);
-	/*if(!(x->type & E)) {
-		fprintf(outs, "	movw (sp)+,(sp)\n");
-		fprintf(outs, "	bicpsw $0xff\n");
-		fprintf(outs, "	bispsw (sp)+\n");
-	}*/
-	state = SBBLK;
-}
-
-finish()
-{	int i;
-	fprintf(outs, "	.data\n");
-	fprintf(outs, "locprof: .long %d\n", cnt);
-	fprintf(outs, "	.long 0\n");
-	fprintf(outs, "	.long L%db\n", cnt);
-	fprintf(outs, "	.space %d\n", 4 * cnt);
-	fprintf(outs, "L%db: .byte ", cnt);
-	for(i = 0; curdir[i]; i++)
-		fprintf(outs, "0x%x,", curdir[i]);
-	fprintf(outs, "0x%x\n", '/');
-	fprintf(outs, "	.byte ");
-	if(fname[0])
-		for(i = 0; fname[i]; i++)
-			fprintf(outs, "0x%x,", fname[i]);
-	else
-		for(i = 0; curarg[i]; i++)
-			fprintf(outs, "0x%x,", curarg[i]);
-	fprintf(outs, "0\n");
-}
-
-#endif
-
-
-fixinstr(x)
-struct inst *x;
-{
-#ifndef u3b
-	if(x->iname[0] == 'b')
-		*ptr = 'j';	/* let assembler worry about branches */
-	/* this is where the code for aob and sob goes */
-#endif
-}
-
-
-
-
-
//GO.SYSIN DD 5bb.c
echo 68k-instr.c 1>&2
sed 's/.//' >68k-instr.c <<'//GO.SYSIN DD 68k-instr.c'
-#define K	1	/* kills all condition codes */
-#define JUMP	2	/* ends a basic block */
-#define BYTE	4	/* target is byte offset */
-#define C	8	/* kills all condition codes but for C bit*/
-/* if((p->type & EXPAND) && p->iname[0] == 'b') replace first char with j */
-/* aob and sob get replaced by two instructions */
-
-struct inst {
-	char *iname;
-	short type;
-} insts[] = {
-{ "abcd", K},
-{ "add", K},
-{ "addx", K},
-{ "and", K},
-{ "asl", K},
-{ "asr", K},
-{ "bcc", 0},
-{ "bchg", 0},
-{ "bclr", 0},
-{ "bcs", 0},
-{ "beq", 0},
-{ "bge", 0},
-{ "bgt", 0},
-{ "bhi", 0},
-{ "bhs", 0},
-{ "ble", 0},
-{ "blo", 0},
-{ "bls", 0},
-{ "blt", 0},
-{ "bmi", 0},
-{ "bne", 0},
-{ "bpl", 0},
-{ "br", 0},
-{ "bra", 0},
-{ "bset", 0},
-{ "bsr", 0},
-{ "btst", 0},
-{ "bvc", 0},
-{ "bvs", 0},
-{ "chk", K},
-{ "clr", K},
-{ "cmp", K},
-{ "dbcc", 0},
-{ "dbcs", 0},
-{ "dbeq", 0},
-{ "dbge", 0},
-{ "dbgt", 0},
-{ "dbhi", 0},
-{ "dbhs", 0},
-{ "dble", 0},
-{ "dblo", 0},
-{ "dbls", 0},
-{ "dblt", 0},
-{ "dbmi", 0},
-{ "dbne", 0},
-{ "dbpl", 0},
-{ "dbr", 0},
-{ "dbra", 0},
-{ "dbvc", 0},
-{ "dbvs", 0},
-{ "divs", K},
-{ "divu", K},
-{ "eor", K},
-{ "exg", 0},
-{ "ext", K},
-{ "jmp", 0},
-{ "jsr", 0},
-{ "lea", 0},
-{ "link", 0},
-{ "lsl", K},
-{ "lsr", K},
-{ "mov", K},
-{ "movea", 0},
-{ "movm", 0},
-{ "muls", K},
-{ "mulu", K},
-{ "nbcd", K},
-{ "neg", K},
-{ "negx", K},
-{ "nop", 0},
-{ "not", K},
-{ "or", K},
-{ "pea", 0},
-{ "reset", 0},
-{ "rol", K},
-{ "ror", K},
-{ "roxl", K},
-{ "roxr", K},
-{ "rte", K},
-{ "rtr", K},
-{ "rts", 0},
-{ "sbcd", K},
-{ "scc", 0},
-{ "scs", 0},
-{ "seq", 0},
-{ "sf", 0},
-{ "sge", 0},
-{ "sgt", 0},
-{ "shi", 0},
-{ "shs", 0},
-{ "sle", 0},
-{ "slo", 0},
-{ "sls", 0},
-{ "slt", 0},
-{ "smi", 0},
-{ "sne", 0},
-{ "spl", 0},
-{ "st", 0},
-{ "stop", K},
-{ "sub", K},
-{ "suba", 0},
-{ "subx", K},
-{ "svc", 0},
-{ "svs", 0},
-{ "swap", K},
-{ "tas", K},
-{ "trap", 0},
-{ "trapv", 0},
-{ "tst", K},
-{ "unlk", 0},
-{ 0, 0},
-};
//GO.SYSIN DD 68k-instr.c
echo README 1>&2
sed 's/.//' >README <<'//GO.SYSIN DD README'
-There's no makefile.  Compile bb.c (or 5bb.c if you've unix V) and put
-the output in bb.  fix the shell scripts lcomp, lcc.  good luck. [instr.c is
-included in bb.c, so doesn't get compiled.
-cc -c nexit.c -o nexit.o; cc -o lprint lprint.c, and that's it]
-.
//GO.SYSIN DD README
echo bb.c 1>&2
sed 's/.//' >bb.c <<'//GO.SYSIN DD bb.c'
-#define unsafe 1	/* pretend killing all but C is as good as killing
-			 * all condition codes */
-#ifdef unsafe
-#define E	(C|K)
-#else
-#define E	K
-#endif
-#include "stdio.h"
-#include "instr.c"
-#include "ctype.h"
-struct inst *index[128];
-
-#define SBBLK	1	/* looking for the start of a basic block */
-#define SINST	2	/* thinking about generating a tally */
-#define SPRO	3	/* thinking about generating prolog code */
-#define SMAYBE	4	/* seen _, thinking about SPRO */
-
-FILE *outs, *fd, *outl;	/* outs goes to assembler, outl is for listing */
-extern FILE *popen();
-char line[256], fname[256];	/* file names must fit in fname */
-char curfunc[256];
-int lineno, lastline;
-int cnt;
-int state = SBBLK;
-char *ptr, *curarg;
-char curdir[256];
-
-main(argc, argv)
-char **argv;
-{	int i;
-	if(argc <= 1) {
-		fprintf(stderr, "no files given\n");
-		exit(1);
-	}
-	for(i = 0; insts[i].iname; i++)
-		;
-	for(; i >= 0; i--)
-		index[insts[i].iname[0]] = insts + i;
-	fd = popen("pwd", "r");
-	for(i = 0; i < sizeof(curdir) && !feof(fd); i++)
-		curdir[i] = getc(fd);
-	curdir[i-2] = 0;	/* thisdir\n */
-	fclose(fd);
-	for(i = 1; i < argc; i++) {
-		if(setfd(argv[i]))	/* fix fd, outs, outl */
-			doarg();	/* do the work */
-	}
-	exit(0);
-}
-
-setfd(s)
-char *s;
-{	char outnams[24], outnaml[24];
-	fname[0] = 0;
-	cnt = 3;
-	if(fd != NULL)
-		fclose(fd);
-	if(outs != NULL)
-		fclose(outs);
-	if(outl != NULL)
-		fclose(outl);
-	sprintf(outnams, "X%s", s);
-	sprintf(outnaml, "%sL", s);
-	lastline = lineno = 0;
-	fd = fopen(s, "r");
-	if(fd == NULL) {
-		perror(s);
-		return(0);
-	}
-	outs = fopen(outnams, "w");
-	if(outs == NULL) {
-		perror(outnams);
-		return(0);
-	}
-	outl = fopen(outnaml, "w");
-	if(outl == NULL) {
-		perror(outnaml);
-		return(0);
-	}
-	curarg = s;
-	return(1);
-}
-
-doarg()
-{	struct inst *x, *firstword();
-	state = SBBLK;
-	for(;;) {
-		(void) fgets(line, sizeof(line), fd);
-		if(feof(fd))
-			break;
-		for(ptr = line; isspace(*ptr); *ptr++)
-			;
-		if(*ptr == 0 || *ptr == '#')
-			continue;
-		testlabel();
-		/* deal with symbol table info */
-		if(*ptr == '.') {
-			stab();
-			fprintf(outs, "%s", ptr);
-			continue;
-		}
-		if(*ptr == 0 || *ptr == '\n')
-			continue;
-		x = firstword();
-		if(x == 0)
-			continue;
-		if(state == SPRO)
-			prolog(x);
-		if(state == SINST)
-			tally(x);
-		if(state == SBBLK && (x->type & JUMP))
-			state = SINST;
-		outinstr();
-		if(x->type & BYTE)
-			fixinstr(x);
-		fprintf(outs, "%s", ptr);
-	}
-	finish();
-}
-/* unbelievable variability in sdb info */
-stab()
-{	char buf[128];
-	int i, j, k;
-	if(state == SMAYBE && strncmp(ptr, ".word", 5) == 0) {
-		state = SPRO;
-		return;
-	}
-	if((i = *(ptr + 1)) != 's' && i != 'f' && i != 'l')
-		return;
-	/* real compiler output */
-	if(sscanf(ptr, ".stabs \"%[^\"]\", %o", buf, &i) == 2 && i == 0144)
-		strcat(fname, buf);
-	else if(sscanf(ptr, ".stabs \"%[^\"]\", 0x%x", buf, &i) == 2 && i == 0x64)
-		strcat(fname, buf);
-	else if(sscanf(ptr, ".stabd %o,%o,%o", &i, &j, &k) == 3 && i == 0104)
-		lineno = k;
-	else if(sscanf(ptr, ".stabd 0x%x,0,%d", &i, &k) == 2 && i == 0x44)
-		lineno = k;
-	/* pwb 3.0 */
-	else if(sscanf(ptr, ".stab %[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%d",
-		buf, buf+2, buf+4, buf+6, buf+8, buf+10, buf+12, buf+14, &i)
-		== 9 && i == 144) {
-			for(i = k = 0; buf[i] ; i++)
-				if(buf[i] == '\'')
-					buf[k++] = buf[++i];
-			buf[k] = 0;
-			strcat(fname, buf);
-		}
-	else if(sscanf(ptr, ".stab %[0,]%d,%d,%d", buf,&i, &j, &k) == 4
-		&& i == 104)
-		lineno = k;
-	/* pwb 5.0 */
- 	else if(sscanf(ptr," .file \"%[^\"]\"", buf) == 1)
-		strcat(fname, buf);
- 	else if(sscanf(ptr, " .ln %d",&k) == 1)
-		lineno = k;
-}
-
-testlabel()
-{	char *p;
-again:
-	for(p = ptr; *p; p++) {
-		if(*p == ':')
-			break;
-		if(isalnum(*p) || *p == '_')
-			continue;
-		if(p > ptr && *p == '.')	/* f77 */
-			continue;
-		return;
-	}
-	if(*p == 0)
-		return;
-	*p++ = 0;	/* that is overwriting the : */
-	fprintf(outs, "%s:\n", ptr);
-	if(*ptr == '_') {
-		state = SMAYBE;
-		strcpy(curfunc, ptr);
-	}
-	else
-		if(state != SPRO)
-			state = SINST;
-	for(ptr = p; isspace(*ptr); ptr++)
-		;
-	goto again;	/* L68:L70: ... */
-}
-
-struct inst *
-firstword()
-{	char buf[sizeof(line)], *p, *q;
-	struct inst *x;
-	for(p = buf, q = ptr; isalnum(*q); )
-		*p++ = *q++;
-	if(p == buf)
-		return((struct inst *)0);
-	*p = 0;
-	for(x = index[buf[0]]; x && x->iname[0] == buf[0]; x++)
-		if(strcmp(buf, x->iname) == 0)
-			return(x);
-	return(0);
-}
-
-tally(x)
-struct inst *x;
-{
-	if(x->type & E)
-		fprintf(outs, "incl locprof+%d\n", 4*cnt++);
-	else {
-		fprintf(outs, "movpsl -(sp)\n");
-		fprintf(outs, "incl locprof+%d\n", 4*cnt++);
-		fprintf(outs, "movw (sp)+,(sp)\n");
-		fprintf(outs, "bicpsw $0xff\n");
-		fprintf(outs, "bispsw (sp)+\n");
-		/* thanks to kirk mckusick */
-	}
-	state = SBBLK;
-}
-
-outinstr()
-{	int i;
-	for(i = lastline + 1; i <= lineno; i++)
-		fprintf(outl, "%d %s: %d\n", 4*(cnt - 1), fname, i);
-	lastline = lineno;
-	fprintf(outl, "%d %s", 4*(cnt - 1), ptr);
-}
-
-prolog(x)	/* no liveness test, presumes can't get here by jump */
-struct inst *x;
-{	int i;
-	fprintf(outs, ".data\n");
-	fprintf(outs, ".comm _proFptr,4\n");	/* the global chain */
-	fprintf(outs, ".text\n");
-	fprintf(outs, "tstl locprof+4\n");
-	fprintf(outs, "bneq L%da\n", i = cnt);
-	fprintf(outs, "movl _proFptr,locprof+4\n");
-	fprintf(outs, "moval locprof,_proFptr\n");
-	fprintf(outs, "L%da: incl locprof+%d\n", i, 4*cnt++);
-	state = SBBLK;
-	fprintf(outl, "%d %s: %s\n", 4*(cnt-1), fname, curfunc);
-}
-
-finish()
-{	int i;
-	fprintf(outs, ".data\n");
-	fprintf(outs, "locprof: .long %d\n", cnt);
-	fprintf(outs, ".long 0\n");
-	fprintf(outs, ".long L%db\n", cnt);
-	fprintf(outs, ".space %d\n", 4 * cnt);
-	fprintf(outs, "L%db: .byte ", cnt);
-	for(i = 0; curdir[i]; i++)
-		fprintf(outs, "0x%x,", curdir[i]);
-	fprintf(outs, "0x%x\n", '/');
-	fprintf(outs, ".byte ");
-	if(fname[0])
-		for(i = 0; fname[i]; i++)
-			fprintf(outs, "0x%x,", fname[i]);
-	else
-		for(i = 0; curarg[i]; i++)
-			fprintf(outs, "0x%x,", curarg[i]);
-	fprintf(outs, "0\n");
-}
-
-fixinstr(x)
-struct inst *x;
-{
-	if(x->iname[0] == 'b')
-		*ptr = 'j';	/* let assembler worry about branches */
-	/* this is where the code for aob and sob goes */
-}
//GO.SYSIN DD bb.c
echo instr.c 1>&2
sed 's/.//' >instr.c <<'//GO.SYSIN DD instr.c'
-#define K	1	/* kills all condition codes */
-#define JUMP	2	/* ends a basic block */
-#define BYTE	4	/* target is byte offset */
-#define C	8	/* kills all condition codes but for C bit*/
-/* if((p->type & EXPAND) && p->iname[0] == 'b') replace first char with j */
-/* aob and sob get replaced by two instructions */
-
-struct inst {
-	char *iname;
-	short type;
-} insts[] = {
-"acbb", C | JUMP,
-"acbd", C | JUMP,
-"acbf", C | JUMP,
-"acbg", C | JUMP,
-"acbh", C | JUMP,
-"acbl", C | JUMP,
-"acbw", C | JUMP,
-"adawi", K,
-"addb2", K,
-"addb3", K,
-"addd2", K,
-"addd3", K,
-"addf2", K,
-"addf3", K,
-"addg2", K,
-"addg3", K,
-"addh2", K,
-"addh3", K,
-"addl2", K,
-"addl3", K,
-"addp4", K,
-"addp6", K,
-"addw2", K,
-"addw3", K,
-"adwc", K,
-"aobleq", C | JUMP | BYTE,
-"aoblss", C | JUMP | BYTE,
-"ashl", C,
-"ashp", K,
-"ashq", C,
-"bbc", JUMP | BYTE,
-"bbcc", JUMP | BYTE,
-"bbcci", JUMP | BYTE,
-"bbcs", JUMP | BYTE,
-"bbs", JUMP | BYTE,
-"bbsc", JUMP | BYTE,
-"bbss", JUMP | BYTE,
-"bbssi", JUMP | BYTE,
-"bcc", JUMP | BYTE,
-"bcs", JUMP | BYTE,
-"beql", JUMP | BYTE,
-"beqlu", JUMP | BYTE,
-"bgeq", JUMP | BYTE,
-"bgequ", JUMP | BYTE,
-"bgtr", JUMP | BYTE,
-"bgtru", JUMP | BYTE,
-"bicb2", C,
-"bicb3", C,
-"bicl2", C,
-"bicl3", C,
-"bicpsw", K,
-"bicw2", C,
-"bicw3", C,
-"bisb2", C,
-"bisb3", C,
-"bisl2", C,
-"bisl3", C,
-"bispsw", K,
-"bisw2", C,
-"bisw3", C,
-"bitb", C,
-"bitl", C,
-"bitw", C,
-"blbc", JUMP | BYTE,
-"blbs", JUMP | BYTE,
-"bleq", JUMP | BYTE,
-"blequ", JUMP | BYTE,
-"blss", JUMP | BYTE,
-"blssu", JUMP | BYTE,
-"bneq", JUMP | BYTE,
-"bnequ", JUMP | BYTE,
-"bpt",	K,
-"brb", JUMP | BYTE,
-"brw", JUMP,
-"bsbb", JUMP | BYTE,
-"bsbw", JUMP,
-"bugl", 0,
-"bugw", 0,
-"bvc", JUMP | BYTE,
-"bvs", JUMP | BYTE,
-"callg", K,
-"calls", K,
-"caseb", K | JUMP,
-"casel", K | JUMP,
-"casew", K | JUMP,
-"chme", K,
-"chmk", K,
-"chms", K,
-"chmu", K,
-"clrb", C,
-"clrd", C,
-"clrf", C,
-"clrg", C,
-"clrh", C,
-"clrl", C,
-"clro", C,
-"clrq", C,
-"clrw", C,
-"cmpb", K,
-"cmpc3", K,
-"cmpc5", K,
-"cmpd", K,
-"cmpf", K,
-"cmpg", K,
-"cmph", K,
-"cmpl", K,
-"cmpp3", C,
-"cmpp4", C,
-"cmpv", K,
-"cmpw", K,
-"cmpzv", K,
-"crc", C,
-"cvtbd", K,
-"cvtbf", K,
-"cvtbg", K,
-"cvtbh", K,
-"cvtbl", K,
-"cvtbw", K,
-"cvtdb", K,
-"cvtdf", K,
-"cvtdh", K,
-"cvtdl", K,
-"cvtdw", K,
-"cvtfb", K,
-"cvtfd", K,
-"cvtfg", K,
-"cvtfh", K,
-"cvtfl", K,
-"cvtfw", K,
-"cvtgb", K,
-"cvtgf", K,
-"cvtgh", K,
-"cvtgl", K,
-"cvtgw", K,
-"cvthb", K,
-"cvthd", K,
-"cvthf", K,
-"cvthg", K,
-"cvthl", K,
-"cvthw", K,
-"cvtlb", K,
-"cvtld", K,
-"cvtlf", K,
-"cvtlg", K,
-"cvtlh", K,
-"cvtlp", K,
-"cvtlw", K,
-"cvtpl", K,
-"cvtps", K,
-"cvtpt", K,
-"cvtrdl", K,
-"cvtrfl", K,
-"cvtrgl", K,
-"cvtrhl", K,
-"cvtsp", K,
-"cvttp", K,
-"cvtwb", K,
-"cvtwd", K,
-"cvtwf", K,
-"cvtwg", K,
-"cvtwh", K,
-"cvtwl", K,
-"decb", K,
-"decl", K,
-"decw", K,
-"divb2", K,
-"divb3", K,
-"divd2", K,
-"divd3", K,
-"divf2", K,
-"divf3", K,
-"divg2", K,
-"divg3", K,
-"divh2", K,
-"divh3", K,
-"divl2", K,
-"divl3", K,
-"divp", K,
-"divw2", K,
-"divw3", K,
-"editpc", K,
-"ediv", K,
-"emodd", K,
-"emodf", K,
-"emodg", K,
-"emodh", K,
-"emul", K,
-"escd", 0,
-"esce", 0,
-"escf", 0,
-"extv", K,
-"extzv", K,
-"ffc", K,
-"ffs", K,
-"halt",	JUMP,
-"incb", K,
-"incl", K,
-"incw", K,
-"index", K,
-"insqhi", K,
-"insqti", K,
-"insque", K,
-"insv",	0,
-"jbc", JUMP,
-"jbcc", JUMP,
-"jbcs", JUMP,
-"jbr", JUMP,
-"jbs", JUMP,
-"jbsc", JUMP,
-"jbss", JUMP,
-"jcc", JUMP,
-"jcs", JUMP,
-"jeql", JUMP,
-"jeqlu", JUMP,
-"jgeq", JUMP,
-"jgequ", JUMP,
-"jgtr", JUMP,
-"jgtru", JUMP,
-"jlbc", JUMP,
-"jlbs", JUMP,
-"jleq", JUMP,
-"jlequ", JUMP,
-"jlss", JUMP,
-"jlssu", JUMP,
-"jmp", JUMP,
-"jneq", JUMP,
-"jnequ", JUMP,
-"jsb", JUMP,
-"jvc", JUMP,
-"jvs", JUMP,
-"ldpctx", 0,
-"locc", K,
-"matchc", K,
-"mcomb", C,
-"mcoml", C,
-"mcomw", C,
-"mfpr",	C,
-"mnegb", K,
-"mnegd", K,
-"mnegf", K,
-"mnegg", K,
-"mnegh", K,
-"mnegl", K,
-"mnegw", K,
-"movab", C,
-"movad", C,
-"movaf", C,
-"movag", C,
-"movah", C,
-"moval", C,
-"movao", C,
-"movaq", C,
-"movaw", C,
-"movb",	C,
-"movc3", K,
-"movc5", K,
-"movd",	C,
-"movf",	C,
-"movg", C,
-"movh", C,
-"movl",	C,
-"movo", C,
-"movp", C,
-"movpsl", 0,
-"movq",	C,
-"movtc", K,
-"movtuc", K,
-"movw",	C,
-"movzbl", C,
-"movzbw", C,
-"movzwl", C,
-"mtpr",	C,
-"mulb2", K,
-"mulb3", K,
-"muld2", K,
-"muld3", K,
-"mulf2", K,
-"mulf3", K,
-"mulg2", K,
-"mulg3", K,
-"mulh2", K,
-"mulh3", K,
-"mull2", K,
-"mull3", K,
-"mulp", K,
-"mulw2", K,
-"mulw3", K,
-"nop", 0,
-"polyd", K,
-"polyf", K,
-"polyg", K,
-"polyh", K,
-"popr", 0,
-"prober", K,
-"probew", K,
-"pushab", C,
-"pushad", C,
-"pushaf", C,
-"pushag", C,
-"pushah", C,
-"pushal", C,
-"pushao", C,
-"pushaq", C,
-"pushaw", C,
-"pushl", C,
-"pushr", 0,
-"rei", K,
-"remqhi", K,
-"remqti", K,
-"remque", K,
-"ret", K | JUMP,
-"rotl", C,
-"rsb", 0,
-"sbwc", K,
-"scanc", K,
-"skpc", K,
-"sobgeq", C | JUMP | BYTE,
-"sobgtr", C | JUMP | BYTE,
-"spanc", K,
-"subb2", K,
-"subb3", K,
-"subd2", K,
-"subd3", K,
-"subf2", K,
-"subf3", K,
-"subg2", K,
-"subg3", K,
-"subh2", K,
-"subh3", K,
-"subl2", K,
-"subl3", K,
-"subp4", K,
-"subp6", K,
-"subw2", K,
-"subw3", K,
-"svpctx", 0,
-"tstb", K,
-"tstd", K,
-"tstf", K,
-"tstg", K,
-"tstl", K,
-"tstw", K,
-"tstw", K,
-"xfc",	K | JUMP,
-"xorb2", C,
-"xorb3", C,
-"xorl2", C,
-"xorl3", C,
-"xorw2", C,
-"xorw3", C,
-0, 0
-};
//GO.SYSIN DD instr.c
echo lcomp.1 1>&2
sed 's/.//' >lcomp.1 <<'//GO.SYSIN DD lcomp.1'
-.TH LCOMP 1
-.SH NAME
-lcomp, lprint \(mi line-by-line profiler
-.SH SYNOPSIS
-.B lcomp
-[ option ... ] file ...
-.PP
-.B lprint
-[ option ] [ file ... ]
-.SH DESCRIPTION
-.I Lcomp
-is used in place of
-.I cc (1)
-or
-.I f77 (1)
-to insert instruction-counting code into programs.
-It recognizes options whose initial letters are taken from the string
-.LR CwpDUIRdlNnz ,
-and accepts files whose names end in
-.LR .c ,
-.LR .f ,
-.LR .s ,
-or
-.LR .o .
-From each source file it derives a 
-.L .o
-file and a
-.L .sL
-file which
-.I lprint
-uses to correlate source lines with basic blocks.
-.PP
-Option
-.B -C
-declares that
-.L .c
-files (and
-.L .o
-files, if no source files are named)
-are C++ files.
-If the
-.B -c
-option is not present
-.I lcomp
-creates
-.FR a.out .
-Each time
-.F a.out
-is run statistics are added
-to a profiling file
-.FR prof.out .
-.PP
-.I Lprint
-produces on the standard output a listing (in the style of
-.IR pr (1))
-of the programs compiled by
-.I lcomp.
-Without arguments or files,
-each line of the listing is preceded by the number of times it was executed,
-as determined from the data in
-.FR prof.out .
-.I Lprint
-interprets the following options.
-.TP
-.B -a
-Detailed listing of every machine instruction and how often it was executed.
-.TP
-.B -b
-How often each basic block was executed.
-.TP
-.B -c
-Compress the
-.F prof.out
-file, which otherwise grows with every execution of
-.LR a.out .
-.TP
-.B -f
-Print summary information by function: instruction executions, number of
-invocations, source instructions, and number of instructions never executed.
-.TP
-.B -i
-Before each line of source print the number of machine instructions executed.
-.TP
-.B -p
-Before each line of source print the number of times the first basic block
-in that line was executed.
-.TP
-.B -s
-Summarize the counts by source file: instruction exectuions, source
-instructions, instructions never executed, basic block executions, total
-number of source basic blocks, and how many were never executed.
-.PP
-If any file names are given, the arguments
-.L abip
-apply only to them.
-If no options are given,
-.L -p
-is assumed.
-Any combination of options is allowed.
-.SH FILES
-.TF /usr/lib/nexit.o	
-.TP
-.F prof.out
-counts
-.TP
-.F *.sL
-for correlating with source
-.TP
-.F /usr/lib/bb
-for finding basic blocks and inserting counting code
-.TP
-.F /usr/lib/nexit.o
-for printing counts when
-.L a.out
-exits
-.SH "SEE ALSO"
-cc(1), f77(1)
-.SH BUGS
-A line in the source file may be in zero, one, or more basic
-blocks;
-the count given in the listing corresponds to some particular
-choice of the basic block to associate with the line.
-.br
-Processing the output of
-.IR yacc (1)
-without removing
-.L #line
-directives will produce unsatisfactory results.
-.br
-Option
-.B -C
-masks an option of
-.IR cc (1).
//GO.SYSIN DD lcomp.1
echo lprint.c 1>&2
sed 's/.//' >lprint.c <<'//GO.SYSIN DD lprint.c'
-#include "stdio.h"
-#include "ctype.h"
-typedef unsigned long ul;
-typedef struct {
-	char *fname;
-	int len;	/* how many counts have been seen */
-	int quot;	/* how much has been allocated for cnt */
-	int flag;
-	unsigned long *cnt;	/* the basic block counts */
-	int *instrcnt;		/* instrs per basic block, from .sL */
-	int *lastline;		/* last source line containing instr from bb */
-} stab;
-stab *tab;
-int ntab, ltab;
-unsigned long N, B, L, V;	/* for summary */
-double A, U;
-FILE *fd, *sfd, *cfd;
-extern FILE *popen();
-char fname[512] = "/";	/* not checked for overflow */
-char buf[256];
-char curfunc[256];
-extern char *malloc();
-char flg[128];
-unsigned long val;
-char prcmd[128] = "pr -h %s ";	/* space for extra args */
-
-main(argc, argv)
-char **argv;
-{	int i, j, seenpart = 0;
-	if((fd = fopen("prof.out", "r")) == 0) {
-		perror("prof.out");
-		exit(1);
-	}
-	readall();
-	fclose(fd);
-	for(i = 1; i < argc; i++)
-		if(argv[i][0] != '-') {
-			seenpart++;
-			okfile(argv[i]);
-		}
-		else for(j = 1; argv[i][j]; j++)
-			switch(argv[i][j]) {
-			default:	/* assume whole thing is for pr */
-				strcat(prcmd, argv[i]);
-				strcat(prcmd, " ");
-				break;
-			case 'b':	/* each bb */
-				flg['b']++;
-				break;
-			case 'a':	/* intermediate everything */
-				flg['a']++;
-				break;
-			case 'i':	/* count machine instrs */
-				flg['i']++;
-				break;
-			case 'f':	/* counts by function */
-				flg['f']++;
-				flg['s']++;
-				break;
-			case 'p':	/* print, in addition */
-				flg['p']++;
-				break;
-			case 's':	/* bb summary */
-				flg['s']++;
-				break;
-			case 'c':	/* compress prof.out */
-				flg['c']++;
-				break;
-			}
-	if(argc <= seenpart + 1)
-		flg['p']++;
-	if(!seenpart)
-		for(i = 0; i < ntab; i++)
-			tab[i].flag = 1;
-	if(flg['f']) {
-		for(i = 0; i < ntab; i++)
-			fsum(tab + i);
-	}
-	if(flg['s']) {
-		for(i = 0; i < ntab; i++)
-			summary(tab + i);
-		if(ntab > 1)
-			printf("%.0fie %ui %uin %.0fbbe %ubb %ubbne total\n",
-				A, N, B, U, L, V);
-	}
-	if(flg['c']) {
-		fd = fopen("prof.out", "w");
-		if(fd == 0) {
-			perror("rewriting prof.out");
-			exit(1);
-		}
-		for(i = 0; i < ntab; i++) {
-			fprintf(fd, "%s\n", tab[i].fname);
-			for(j = 0; j < tab[i].len; j++)
-				fprintf(fd, "%u\n", tab[i].cnt[j]);
-		}
-		fclose(fd);
-	}
-	if(flg['p'] || flg['i'] || flg['a'] || flg['b'])
-		giantprint();
-	exit(0);
-}
-
-okfile(s)
-char *s;
-{	int i, j, k;
-	j = strlen(s);
-	for(i = 0; i < ntab; i++) {
-		k = strlen(tab[i].fname);
-		if(strcmp(s, tab[i].fname + k - j) == 0) {
-			tab[i].flag = 1;
-			return;
-		}
-	}
-	fprintf(stderr, "argument %s not a source file\n", s);
-	exit(1);
-}
-
-readall()
-{	int c, i, index;
-	stab *curtab = 0;
-sawnl:
-	if((c = getc(fd)) == EOF)
-		return;
-	if(c == '\n')
-		goto sawnl;
-	if(c == '/') {
-		fscanf(fd, "%s", fname+1);
-		for(i = 0; i < ntab; i++)
-			if(strcmp(fname, tab[i].fname) == 0)
-				break;
-		if(i >= ntab) {	/* new file */
-			if(ltab == 0) {
-				tab = (stab *)malloc(20 * sizeof(stab));
-				ltab = 20;
-			}
-			else if(ntab >= ltab)
-				tab = (stab *)realloc((char *)tab,
-					(ltab += 20) * sizeof(stab));
-			tab[ntab].fname = malloc(sizeof(fname) + 1);
-			strcpy(tab[ntab].fname, fname);
-			tab[ntab].flag = tab[ntab].len = tab[ntab].quot = 0;
-			ntab++;
-		}
-		curtab = tab + i;
-		index = 0;
-	}
-	else if(c < '0' || c > '9') {
-		fprintf(stderr, "prof.out has weird format\n");
-		abort();
-	}
-	else {
-		ungetc(c, fd);
-		fscanf(fd, "%d", &val);
-		if(curtab->len <= index) {
-			if(curtab->quot == 0) {
-				curtab->cnt = (ul *)malloc(100*sizeof(long));
-				curtab->quot = 100;
-				for(i = 0; i < 100; i++)
-					curtab->cnt[i] = 0;
-			}
-			else if(curtab->len >= curtab->quot) {
-				curtab->cnt = (ul *)realloc((char *)curtab->cnt,
-					(curtab->quot += 200) * sizeof(long));
-				for(i = curtab->quot-200; i < curtab->quot; i++)
-					curtab->cnt[i] = 0;
-			}
-			curtab->len++;
-		}
-		curtab->cnt[index++] += val;
-	}
-	goto sawnl;
-}
-
-summary(x)
-stab *x;
-{	unsigned long i, v, n, b;
-	double a, u;
-	for(i = u = v = 0; i < x->len; i++)
-		if(x->cnt[i])
-			u += x->cnt[i];
-		else
-			v++;
-	n = strlen(x->fname);
-	strcpy(buf, x->fname);
-	strcpy(buf + n - 2, ".sL");
-	if((fd = fopen(buf, "r")) == 0) {
-		perror(buf);
-		printf("%s %u bbs %.0f execs %u untouched\n",
-			x->fname, x->len, u, v);
-		return;
-	}
-	for(n = a = b = 0; ;) {
-		(void) fgets(buf, sizeof(buf), fd);
-		if(feof(fd))
-			break;
-		if(hascolon(buf))
-			continue;
-		n++;
-		i = atoi(buf)/4 - 3;
-		if(x->cnt[i])
-			a += x->cnt[i];
-		else
-			b++;
-	}
-	printf("%.0fie %ui %uine %.0fbbe %ubb %ubbne %s\n", a, n, b, u, x->len,
-		v, x->fname);
-	fclose(fd);
-	A += a; N += n; B += b; U += u; L += x->len; V += v;
-}
-
-fsum(x)
-stab *x;
-{	unsigned i, v, n, b, cnt;
-	double a, u;
-	char *p;
-	strcpy(buf, x->fname);
-	n = strlen(x->fname);
-	strcpy(buf + n - 2, ".sL");
-	if((fd = fopen(buf, "r")) == 0) {
-		perror(buf);
-		return;
-	}
-	curfunc[0] = 0;
-	for(cnt = v = n = b = a = u = 0;;) {
-		(void) fgets(buf, sizeof(buf), fd);
-		if(feof(fd))
-			break;
-		if(hascolon(buf)) {
-			/* 24 foo.c: 456	or
-			 * 24 foo.c: _funcjunk */
-			for(p = buf; *p != ':'; p++)
-				;
-			while(isspace(*++p))
-				;
-			if(isdigit(*p))
-				continue;
-			if(curfunc[0] != 0)
-				printf("%.0fie %dcalls %ui %uine %s\n",
-					a, v, n, b, curfunc);
-			for(i = 0; *p && *p != '\n'; i++)
-				curfunc[i] = *p++;
-			curfunc[i] = 0;
-			a = n = b = 0;
-			i = atoi(buf)/4 - 3;
-			v = x->cnt[i];
-			continue;
-		}
-		n++;
-		i = atoi(buf)/4 - 3;
-		if(x->cnt[i])
-			a += x->cnt[i];
-		else
-			b++;
-	}
-	if(n > 0)
-		printf("%.0fie %dcalls %ui %uine %s\n", a, v, n, b, curfunc);
-	fclose(fd);
-}
-
-giantprint()
-{	int i, n;
-	for(i = 0; i < ntab; i++) {
-		if(tab[i].flag == 0)
-			continue;
-	/* the fname file is the source, there should be a corresponding
-	 * .sL file for correlation between basic blocks and source.
-	 * If fname is a .s file, the .sL file is all there is */
-		n = strlen(tab[i].fname);
-		if(strcmp(".s", tab[i].fname + n - 2) == 0) {
-			sfile(tab + i);
-			continue;
-		}
-		sfd = fopen(tab[i].fname, "r");
-		if(sfd == 0 && !flg['a']) {
-			perror(tab[i].fname);
-			return;
-		}
-		strcpy(buf, tab[i].fname);
-		strcpy(buf + n - 1, "sL");
-		if((cfd = fopen(buf, "r")) == 0) {
-			fprintf(stderr, "no intermediate listing file ");
-			perror(buf);
-			fclose(sfd);
-			return;
-		}
-		sprintf(buf, prcmd, tab[i].fname);
-		if(!flg['a'])
-			fd = popen(buf, "w");
-		if(!flg['a'])
-			xlistit(tab + i);
-		else
-			listit(tab + i);
-		if(fd)
-			pclose(fd);
-		if(sfd)
-			fclose(sfd);
-		fclose(cfd);
-	}
-}
-
-sfile(x)
-stab *x;
-{	int i;
-	char *p;
-	strcpy(buf, x->fname);
-	strcat(buf, "L");
-	sfd = fopen(buf, "r");
-	if(sfd == 0) {
-		perror(buf);
-		return;
-	}
-	sprintf(buf, "pr -h %s", x->fname);
-	fd = popen(buf, "w");
-	if(fd == 0) {
-		perror(buf);
-		fclose(sfd);
-		return;
-	}
-	for(;;) {
-		(void) fgets(buf, sizeof(buf), sfd);
-		if(feof(sfd)) {
-			pclose(fd);
-			fclose(sfd);
-			return;
-		}
-		for(i = 0, p = buf; *p >= '0' && *p <= '9'; p++)
-			i = 10 * i + *p - '0';
-		i = i/4 - 3;
-		fprintf(fd, "%u\t%s", x->cnt[i], p);
-	}
-}
-
-/* function added, so name (stripnum) is now misleading */
-char *
-stripnum(s)
-char *s;
-{	char *p;
-	while(*s && (isdigit(*s) || isspace(*s)))
-		s++;
-	for(p = s; *p && *p != '\n'; p++)
-		;
-	if(*p == '\n')
-		*p = ' ';
-	return(s);
-}
-
-listit(x)
-stab *x;
-{	int i;
-	char *p;
-	for(;;) {
-		(void) fgets(buf, sizeof(buf), cfd);
-		if(feof(cfd))
-			break;
-		for(p = buf; *p && *p != ':' ; p++)
-			;
-		if(*p++ != ':') {	/* these are instructions */
-			i = x->cnt[atoi(buf)/4 - 3];
-			printf("%d\t%s\n", i, stripnum(buf));
-			continue;
-		}
-		else {
-			printf("%s", stripnum(buf));
-			if(atoi(p) == 0) {	/* foo.c: _main */
-				putchar('\n');
-				continue;
-			}
-			(void) fgets(buf, sizeof(buf), sfd);
-			printf("%s", buf);
-			continue;
-		}
-	}
-}
-
-xlistit(x)
-stab *x;
-{	int lnum, i, icnt, bcnt;
-	char *p;
-	x->instrcnt = (int *) malloc(x->len * sizeof(int));
-	x->lastline = (int *) malloc(x->len * sizeof(int));
-	if(!x->instrcnt || !x->lastline) {
-		fprintf(stderr, "out of memory\n");
-		return;
-	}
-	for(i = 0; i < x->len; i++)
-		x->instrcnt[i] = x->lastline[i] = 0;
-	for(;;) {
-		(void) fgets(buf, sizeof(buf), cfd);
-		if(feof(cfd))
-			break;
-		for(p = buf; *p && *p != ':'; p++)
-			;
-		if(*p++ != ':') {	/* instruction */
-			x->instrcnt[atoi(buf)/4 - 3]++;
-			continue;
-		}
-		lnum = atoi(p);		/* hmm (atoi (" x..") is zero?)*/
-		if(lnum <= 0)
-			continue;
-		i = atoi(buf)/4 - 3;
-		x->lastline[i] = lnum;
-	}
-	/* now read all the source lines and print out appropriate stuff */
-	for(lnum = 1, i = 0;; lnum++) {
-		(void) fgets(buf, sizeof(buf), sfd);
-		if(feof(sfd))
-			return;
-		icnt = bcnt = 0;
-		for(; i < x->len && x->lastline[i] <= lnum; i++) {
-			if(flg['b'] && flg['i'])
-				fprintf(fd, "%u,%ui ", x->cnt[i],
-					x->cnt[i] * x->instrcnt[i]);
-			else if(flg['b'])
-				fprintf(fd, "%u ", x->cnt[i]);
-			else {
-				icnt += x->cnt[i] * x->instrcnt[i];
-				bcnt += x->cnt[i];
-			}
-		}
-		if(!flg['b'] && flg['p'] && bcnt)
-			fprintf(fd, "%u ", bcnt);
-		if(!flg['b'] && flg['i'] && icnt)
-			fprintf(fd, "%ui ", icnt);
-		fprintf(fd, "\t%s", buf);
-	}
-}
-
-hascolon(s)
-register char *s;
-{
-	for(; *s && *s != ':'; s++)
-		;
-	if(*s == ':')
-		return(1);
-	else
-		return(0);
-}
//GO.SYSIN DD lprint.c
echo lsub.c 1>&2
sed 's/.//' >lsub.c <<'//GO.SYSIN DD lsub.c'
-#include "stdio.h"
-typedef unsigned long ul;
-typedef struct {
-	char *fname;
-	int len;	/* how many counts have been seen */
-	int quot;	/* how much has been allocated for cnt */
-	unsigned long *cnt;
-} stab;
-stab *tab;
-int ntab, ltab;
-FILE *fd, *sfd, *cfd;
-char buf[256];
-char fname[512] = "/";
-extern char *malloc();
-char flg[128];
-unsigned long val;
-
-main(argc, argv)
-char **argv;
-{	int i, j;
-	if(argc <= 1) {
-		fprintf(stderr, "subtract from where?\n");
-		exit(1);
-	}
-	if((fd = fopen("prof.out", "r")) == 0) {
-		perror("prof.out");
-		exit(1);
-	}
-	readall(fd);
-	fclose(fd);
-	sfd = fopen(argv[1], "r");
-	if(sfd == 0) {
-		perror(argv[1]);
-		exit(1);
-	}
-	suball(sfd);
-	fclose(sfd);
-	if((fd = fopen("prof.out", "w")) == 0) {
-		perror(argv[1]);
-		exit(1);
-	}
-	for(i = 0; i < ntab; i++)
-		rewrite(tab + i);
-	exit(0);
-}
-
-readall(fd)
-FILE *fd;
-{	int c, i, index;
-	stab *curtab = 0;
-sawnl:
-	if((c = getc(fd)) == EOF)
-		return;
-	if(c == '\n')
-		goto sawnl;
-	if(c == '/') {
-		fscanf(fd, "%s", fname+1);
-		for(i = 0; i < ntab; i++)
-			if(strcmp(fname, tab[i].fname) == 0)
-				break;
-		if(i >= ntab) {	/* new file */
-			if(ltab == 0) {
-				tab = (stab *)malloc(20 * sizeof(stab));
-				ltab = 20;
-			}
-			else if(ntab >= ltab)
-				tab = (stab *)realloc((char *)tab,
-					(ltab += 20) * sizeof(stab));
-			tab[ntab].fname = malloc(sizeof(fname) + 1);
-			strcpy(tab[ntab].fname, fname);
-			tab[ntab].len = tab[ntab].quot = 0;
-			ntab++;
-		}
-		curtab = tab + i;
-		index = 0;
-	}
-	else if(c < '0' || c > '9') {
-		fprintf(stderr, "prof.out has weird format\n");
-		abort();
-	}
-	else {
-		ungetc(c, fd);
-		fscanf(fd, "%d", &val);
-		if(curtab->len <= index) {
-			if(curtab->quot == 0) {
-				curtab->cnt = (ul *)malloc(100*sizeof(long));
-				curtab->quot = 100;
-				for(i = 0; i < 100; i++)
-					curtab->cnt[i] = 0;
-			}
-			else if(curtab->len >= curtab->quot) {
-				curtab->cnt = (ul *)realloc(curtab->cnt,
-					(curtab->quot += 200) * sizeof(long));
-				for(i = curtab->quot-200; i < curtab->quot; i++)
-					curtab->cnt[i] = 0;
-			}
-			curtab->len++;
-		}
-		curtab->cnt[index++] += val;
-	}
-	goto sawnl;
-}
-
-rewrite(x)
-stab *x;
-{	int i;
-	for(i = 0; i < x->len; i++)
-		if(x->cnt[i])
-			break;
-	if(i >= x->len)
-		return;
-	fprintf(fd, "%s\n", x->fname);
-	for(i = 0; i < x->len; i++)
-		fprintf(fd, "%u\n", x->cnt[i]);
-}
-suball(fd)
-FILE *fd;
-{	int c, i, index;
-	stab *curtab = 0;
-sawnl:
-	if((c = getc(fd)) == EOF)
-		return;
-	if(c == '\n')
-		goto sawnl;
-	if(c == '/') {
-		fscanf(fd, "%s", fname+1);
-		for(i = 0; i < ntab; i++)
-			if(strcmp(fname, tab[i].fname) == 0)
-				break;
-		if(i >= ntab) {	/* new file */
-			fprintf(stderr, "new file %s ignored\n", fname);
-			goto sawnl;
-		}
-		curtab = tab + i;
-		index = 0;
-	}
-	else if(c < '0' || c > '9') {
-		fprintf(stderr, "prof.out has weird format\n");
-		abort();
-	}
-	else {
-		ungetc(c, fd);
-		fscanf(fd, "%d", &val);
-		curtab->cnt[index++] -= val;
-	}
-	goto sawnl;
-}
//GO.SYSIN DD lsub.c
echo lcomp 1>&2
sed 's/.//' >lcomp <<'//GO.SYSIN DD lcomp'
-# lcomp recognizes the following arguments to cc: c, w, p, D, U, I g.
-# lcomp recognizes the following arguments to f77: c, w, p.
-# it does not accept ratfor or efl
-# lcomp recognizes the following argument to as: R
-# lcomp recognizes the following arguments to ld: d, l, N, n, z
-# the output from -c is .o plus .sL
-DIR=/usr/lib
-COMP=${COMP-cc}
-PATH=/bin:/usr/bin
-for i in $*
-do
-	case $i in
-	-c)	compflag=1
-		;;
-	*.c)	clist="$clist $i"
-		u=`basename $i | sed 's/c$//'`
-		bblist="$bblist "$u"s"
-		rmlist="$rmlist "$u"s"
-		slist="$slist "X$u"s"
-		llist="$llist "$u"o"
-		;;
-	-D*|-I*|-U*)
-		clist="$clist $i"
-		;;
-	*.f)	flist="$flist "$i
-		u=`basename $i | sed 's/f$//'`
-		bblist="$bblist "$u"s"
-		rmlist="$rmlist "$u"s"
-		slist="$slist "X$u"s"
-		llist="$llist "$u"o"
-		;;
-	*.s)	bblist="$bblist "$i
-		u=`basename $i | sed 's/s$//'`
-		slist="$slist "X$u"s"
-		llist="$llist "$u"o"
-		;;
-	-w|-p|-R|-d|-l*|-N|-n|-t|-z|*.o|*.a)
-		llist="$llist "$i
-		;;
-	*)	echo incomprehensible argument $i ignored
-		;;
-	-g)
-		;;
-	esac
-done
-# get .s files
-if test "$flist"
-then
-	f77 -g -S $flist
-fi
-if test "$clist"
-then
-	$COMP -g -S $clist
-fi
-# create X*.s and *.sL files
-if test "$bblist"
-then
-	$DIR/bb $bblist
-fi
-# create X*.o files
-if test "$flist"
-then
-	f77 -g -c $slist
-elif test "$clist"
-then
-	$COMP -g -c $slist
-fi
-# make them into real .o files
-if test "$rmlist"
-then
-	for i in X*.o
-		do
-		mv $i `echo $i | sed s/X//`
-	done
-fi
-rm -f X*.s $rmlist prof.out
-
-if test $compflag
-then	exit 0
-fi
-if test "$flist"
-then
-	f77 -g $DIR/nexit.o $llist
-else
-	$COMP -g $DIR/nexit.o $llist $lC
-fi
//GO.SYSIN DD lcomp
