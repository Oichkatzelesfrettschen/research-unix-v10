#define K	1	/* kills all condition codes */
#define JUMP	2	/* ends a basic block */
#define BYTE	4	/* target is byte offset */
#define C	8	/* kills all condition codes but for C bit*/
/* if((p->type & EXPAND) && p->iname[0] == 'b') replace first char with j */
/* aob and sob get replaced by two instructions */

struct inst {
	char *iname;
	short type;
} insts[] = {
{ "abcd", K},
{ "add", K},
{ "addx", K},
{ "and", K},
{ "asl", K},
{ "asr", K},
{ "bcc", 0},
{ "bchg", 0},
{ "bclr", 0},
{ "bcs", 0},
{ "beq", 0},
{ "bge", 0},
{ "bgt", 0},
{ "bhi", 0},
{ "bhs", 0},
{ "ble", 0},
{ "blo", 0},
{ "bls", 0},
{ "blt", 0},
{ "bmi", 0},
{ "bne", 0},
{ "bpl", 0},
{ "br", 0},
{ "bra", 0},
{ "bset", 0},
{ "bsr", 0},
{ "btst", 0},
{ "bvc", 0},
{ "bvs", 0},
{ "chk", K},
{ "clr", K},
{ "cmp", K},
{ "dbcc", 0},
{ "dbcs", 0},
{ "dbeq", 0},
{ "dbge", 0},
{ "dbgt", 0},
{ "dbhi", 0},
{ "dbhs", 0},
{ "dble", 0},
{ "dblo", 0},
{ "dbls", 0},
{ "dblt", 0},
{ "dbmi", 0},
{ "dbne", 0},
{ "dbpl", 0},
{ "dbr", 0},
{ "dbra", 0},
{ "dbvc", 0},
{ "dbvs", 0},
{ "divs", K},
{ "divu", K},
{ "eor", K},
{ "exg", 0},
{ "ext", K},
{ "jmp", 0},
{ "jsr", 0},
{ "lea", 0},
{ "link", 0},
{ "lsl", K},
{ "lsr", K},
{ "mov", K},
{ "movea", 0},
{ "movm", 0},
{ "muls", K},
{ "mulu", K},
{ "nbcd", K},
{ "neg", K},
{ "negx", K},
{ "nop", 0},
{ "not", K},
{ "or", K},
{ "pea", 0},
{ "reset", 0},
{ "rol", K},
{ "ror", K},
{ "roxl", K},
{ "roxr", K},
{ "rte", K},
{ "rtr", K},
{ "rts", 0},
{ "sbcd", K},
{ "scc", 0},
{ "scs", 0},
{ "seq", 0},
{ "sf", 0},
{ "sge", 0},
{ "sgt", 0},
{ "shi", 0},
{ "shs", 0},
{ "sle", 0},
{ "slo", 0},
{ "sls", 0},
{ "slt", 0},
{ "smi", 0},
{ "sne", 0},
{ "spl", 0},
{ "st", 0},
{ "stop", K},
{ "sub", K},
{ "suba", 0},
{ "subx", K},
{ "svc", 0},
{ "svs", 0},
{ "swap", K},
{ "tas", K},
{ "trap", 0},
{ "trapv", 0},
{ "tst", K},
{ "unlk", 0},
{ 0, 0},
};
